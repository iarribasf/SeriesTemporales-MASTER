<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Iván Arribas (Depto. Análisis Económico. Universitat de València)" />


<title>Series Temporales: Alisado Exponencial</title>

<script src="site_libs/header-attrs-2.5/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Series Temporales</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="01-Guia-curso.html">
    <span class="fa fa-graduation-cap"></span>
     
    Guía del curso
  </a>
</li>
<li>
  <a href="02-Logistica.html">
    <span class="fa fa-laptop"></span>
     
    Logística
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-book"></span>
     
    Diapos
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Teoría</li>
    <li>
      <a href="03-01-Tema1.html">Tema 1: Introducción</a>
    </li>
    <li>
      <a href="03-02-Tema2.html">Tema 2: Alisado</a>
    </li>
    <li>
      <a href="03-03-Tema3.html">Tema 3: Procesos estocásticos</a>
    </li>
    <li>
      <a href="03-04-Tema4.html">Tema 4: ARIMA</a>
    </li>
    <li>
      <a href="03-05-Tema5.html">Tema 5: SARIMA</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Ejemplo de aplicación</li>
    <li>
      <a href="03-06-Ejemplo1.html">Ejemplo Tema 1</a>
    </li>
    <li>
      <a href="03-07-Ejemplo2.html">Ejemplo Tema 2</a>
    </li>
    <li>
      <a href="03-08-Ejemplo3.html">Ejemplo Tema 3</a>
    </li>
    <li>
      <a href="03-09-Ejemplo4.html">Ejemplo Tema 4</a>
    </li>
    <li>
      <a href="03-10-Ejemplo5.html">Ejemplo Tema 5</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Otro ejemplo</li>
    <li>
      <a href="03-11-Ejemplo-Pasajeros.html">Ejemplo de Pasajeros</a>
    </li>
  </ul>
</li>
<li>
  <a href="04-Recursos-R.html">
    <span class="fa fa-code"></span>
     
    Recursos de R
  </a>
</li>
<li>
  <a href="05-Practica.html">
    <span class="fa fa-edit"></span>
     
    Practica
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-download"></span>
     
    Más
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">R</li>
    <li>
      <a href="https://cran.r-project.org">Dónde está R</a>
    </li>
    <li>
      <a href="https://rstudio.com">Donde está RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Markdown</li>
    <li>
      <a href="https://bookdown.org/yihui/rmarkdown/">Markdown</a>
    </li>
    <li>
      <a href="https://rmarkdown.rstudio.com/lesson-1.html">R Markdown</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Otros</li>
    <li>
      <a href="https://www.r-bloggers.com">Blog sobre R</a>
    </li>
    <li>
      <a href="https://bookdown.org">Libros online que debes conocer</a>
    </li>
  </ul>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Series Temporales: Alisado Exponencial</h1>
<h3 class="subtitle">Máster de Bioestadística (Modelización Estadística)</h3>
<h4 class="author">Iván Arribas (Depto. Análisis Económico. Universitat de València)</h4>

</div>


<div id="introducción" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> Introducción</h1>
<p>En muchos casos es preciso aplicar un método de predicción rápido y sencillo:</p>
<ul>
<li>A causa del elevado número de series que tienen que ser analizadas.</li>
<li>Debido a la rapidez con que las predicciones se han de dar.</li>
</ul>
<p>Actualmente existen muchos métodos sencillos de predicción, entre lo que cabe destacar dos:</p>
<ul>
<li><strong>Métodos de media móvil</strong> (no los veremos en este curso pero puedes aprender sobre ellos <a href="http://uc-r.github.io/ts_moving_averages">aqui</a> y <a href="https://cran.r-project.org/web/packages/smooth/vignettes/sma.html">aqui</a>).</li>
<li><strong>Métodos de alisado exponencial</strong>.</li>
</ul>
<p>Estas técnicas, a pesar de su sencillez, son bastante adecuadas cuando la previsión es a corto plazo:</p>
<blockquote>
<p>“Statistically sophisticated or complex methods do not necessarily produce more accurate forecasts than simpler ones.” Makridakis y Hibon (2000).</p>
</blockquote>
<p>Veremos en detalle los métodos de alisado exponencial por ser muy versátiles, pudiéndose aplicar a cualquier serie, independientemente de sus componentes, y haber demostrado una gran capacidad de ajuste y calidad de predicción. En ellos se hace uso de datos pasados para obtener una nueva serie más <em>suave</em> o alisada, a partir de la cual se realizarán las predicciones. Existe un amplio menú de métodos de alisado alternativos y la elección del más adecuado dependerá de las componentes que presenta la serie y del tipo de esquema.</p>
<p><br />
<br />
</p>
</div>
<div id="criterios-de-calidad" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> Criterios de calidad</h1>
<p>En este tema y en los siguientes se verán diferentes métodos para predecir una serie temporal. Así, es preciso definir criterios de bondad de ajuste que permitan estimar tanto la calidad del ajuste como de las predicciones de un método.</p>
<blockquote>
<p>“The rankings of the performance of the various methods vary according to the accuracy measure being used.” Makridakis y Hibon (2000).</p>
</blockquote>
<p><br />
</p>
<div id="notación-y-definiciones" class="section level2" number="2.1">
<h2 number="2.1"><span class="header-section-number">2.1</span> Notación y definiciones</h2>
<p>Dada una serie temporal <span class="math inline">\(\{y_t\}_{t=1}^T\)</span>, se define:</p>
<ul>
<li><strong>Previsión <span class="math inline">\(h\)</span> periodos adelante</strong>, como la previsión de la serie para el periodo <span class="math inline">\(t+h\)</span> disponiendo de información hasta el periodo <span class="math inline">\(t\)</span>, y se denota por <span class="math inline">\(\hat{y}_{t+h|t}\)</span>. Por simplicidad lo escribiremos también como <span class="math inline">\(\hat{y}_{t+h}\)</span>.</li>
</ul>
<ul>
<li>Así, <span class="math inline">\(\hat{y}_{t+1|t}\)</span> es la <strong>previsión un periodo adelante</strong> o a un periodo vista. Es decir, la previsión de la serie en <span class="math inline">\(t+1\)</span> desde el periodo <span class="math inline">\(t\)</span>.</li>
</ul>
<ul>
<li>De nuevo, por simplicidad denotaremos a <span class="math inline">\(\hat{y}_{t+1|t}\)</span> como <span class="math inline">\(\hat{y}_{t+1}\)</span>; y como <span class="math inline">\(\hat{y}_{t}\)</span> a la previsión en <span class="math inline">\(t\)</span>, con datos hasta el periodo <span class="math inline">\(t-1\)</span> (<span class="math inline">\(\hat{y}_{t} = \hat{y}_{t|t-1}\)</span>).</li>
</ul>
<p>Se define como <strong>error de previsión</strong> a un periodo vista a <span class="math display">\[\hat{e}_t=y_t-\hat{y}_t,\]</span> de forma que la serie <span class="math inline">\(\{\hat{e}_t\}_{t=1}^T\)</span> nos permitirá definir varios criterios de calidad de ajuste.</p>
<p><br />
</p>
</div>
<div id="medidas-de-precisión-de-la-predicción" class="section level2" number="2.2">
<h2 number="2.2"><span class="header-section-number">2.2</span> Medidas de precisión de la predicción</h2>
<p>Dada una serie <span class="math inline">\(\{y_t\}_{t=1}^T\)</span>, un método de predicción y su vector de errores asociado <span class="math inline">\(\{\hat{e}_t\}_{t=1}^T\)</span>, podemos definir múltiples medidas de calidad del método de predicción que hacen referencia a la presencia de sesgo en las predicciones, la magnitud del error cometido y la calidad del intervalo de confianza de las predicciones. Las más habituales son (siglas en inglés):</p>
<ul>
<li>Error medio (ME): <span class="math inline">\(\frac{1}{T}\sum_{t=1}^T \hat{e}_t\)</span></li>
</ul>
<ul>
<li><strong>Raíz del error cuadrático medio (RMSE)</strong>: <span class="math inline">\(\sqrt{\frac{1}{T}\sum_{t=1}^T \hat{e}^2_t}\)</span></li>
</ul>
<ul>
<li>Error absoluto medio (MAE): <span class="math inline">\(\frac{1}{T}\sum_{t=1}^T |\hat{e}_t|\)</span></li>
</ul>
<ul>
<li>Error porcentual medio (MPE): <span class="math inline">\(\frac{100}{T}\sum_{t=1}^T \frac{\hat{e}_t}{y_t}\)</span></li>
</ul>
<ul>
<li><strong>Error porcentual absoluto medio (MAPE)</strong>: <span class="math inline">\(\frac{100}{T}\sum_{t=1}^T \big|\frac{\hat{e}_t}{y_t}\big|\)</span></li>
</ul>
<ul>
<li>Error porcentual absoluto medio simétrico (sMAPE): <span class="math inline">\(\frac{200}{T}\sum_{t=1}^T \Big|\frac{\hat{e}_t}{y_t + \hat{y}_t}\Big|\)</span></li>
</ul>
<ul>
<li>Error escalado absoluto medio (MASE): <span class="math inline">\(\big(\frac{1}{T}\sum_{t=1}^T |\hat{e}_t|\big)/q\)</span>, donde <span class="math inline">\(q\)</span> es el error absoluto medio para un método ingenuo de predicción:
<ul>
<li><span class="math inline">\(q=\frac{1}{T-1}\sum_{t=2}^T |y_t-y_{t-1}|\)</span> para series <em>sin</em> estacionalidad</li>
<li><span class="math inline">\(q=\frac{1}{T-m}\sum_{t=m+1}^T |y_t-y_{t-m}|\)</span> para series <em>con</em> estacionalidad</li>
</ul></li>
</ul>
<ul>
<li>Correlación entre <span class="math inline">\(\hat{e}_t\)</span> y <span class="math inline">\(\hat{e}_{t-1}\)</span> (ACF1).</li>
</ul>
<p><br />
</p>
<p>ME y MPE permiten valorar el sesgo de las predicciones (que estas estén sistemáticamente por encima o por debajo de los valores reales).</p>
<ul>
<li>Lo esperado es un valor cercano a cero (con relación al valor medio de la serie). Valores muy alejados de cero son indicadores de sesgo de predicción.</li>
</ul>
<p>RMSE y MAE indican el error medio cometido, medido en las mismas unidades que la serie temporal.</p>
<ul>
<li>Están acotadas inferiormente por el valor óptimo de 0, pero no hay cota superior.</li>
</ul>
<p>MAPE y sMAPE indican el error porcentual medio cometido.</p>
<ul>
<li>Están acotadas inferiormente por el valor óptimo de 0%, y la cota superior natural es 100%, aunque podría sobrepasarse.</li>
<li>Si <span class="math inline">\(y_t\)</span> puede valer 0, entonces MAPE no se puede calcular. Además, MAPE penaliza más los errores negativos frente a los errores positivos. La medida de precisión sMAPE se define a fin de corregir estos problemas.</li>
</ul>
<p>MASE es la ratio entre el error del método usado y el error de un método ingenuo de predicción. Permite saber cuánto ganamos en capacidad predictiva al pasar de un método ingenuo a otro más complicado.</p>
<ul>
<li>Un valor cercano a 1 indica que el método usado no es mejor que el método ingenuo</li>
<li>Cuanto más cercano a 0, mejor es el método usado respecto del método ingenuo</li>
<li>Su complementario a 1 se puede interpretar como la tasa de mejora</li>
</ul>
<p>ACF1 evalúa la capacidad de mejora que hay en la estimación del intervalo de confianza de las predicciones. Lo veremos con más detalle en el tema de modelos ARIMA. Por ahora basta saber que:</p>
<ul>
<li>Un valor muy cercano a 0 indica que hay poca capacidad de mejora.</li>
<li>Un valor cercano a 1 o -1 indica que hay mucha capacidad de mejora.</li>
</ul>
<p>Las <em>medias</em> se pueden sustituir por <em>medianas</em>. Esto es especialmente útil cuando para algunas observaciones hay errores atípicamente altos.</p>
<p><br />
</p>
<p>Si para realizar la predicción del periodo <span class="math inline">\(t\)</span> se usa una metodología que utiliza datos hasta dicho periodo, se hablará de <strong>predicción y error intra-muestral</strong>. En caso contrario, la predicción del periodo <span class="math inline">\(t\)</span> usa una metodología que solo necesita de datos hasta el periodo <span class="math inline">\(t-1\)</span>, se hablará de <strong>predicción y error extra-muestral</strong>.</p>
<p>Si los indicadores de calidad se basan en predicciones intra-muestrales a un periodo vista, presentan dos problemas. Primero, evalúan el error de predicción a un periodo vista, cuando en muchas situaciones reales las predicciones se realizan sobre un horizonte temporal más amplio. Segundo, son errores intra-muestrales, resultantes de predecir los mismos datos que se ha usado el método para calcular la predicción y, por tanto, sobre-estiman la capacidad predictiva del modelo.</p>
<p>Veremos durante en este tema métodos de evaluación de la calidad de las predicciones que superan estas limitaciones.</p>
<p><br />
<br />
</p>
</div>
</div>
<div id="métodos-sencillos-de-predicción" class="section level1" number="3">
<h1 number="3"><span class="header-section-number">3</span> Métodos sencillos de predicción</h1>
<p>Algunos métodos de predicción son extremadamente sencillos y sorprendentemente eficaces, son los denominados métodos ingenuos. Estos métodos:</p>
<ul>
<li>posibilitan realizar predicciones prácticamente sin realizar ningún cálculo.</li>
<li>como son muy sencillos, dan las previsiones con mayor error (menos precisas). El error de un método ingenuo sirve de punto de referencia (<em>benchmark</em>) para valorar la necesidad de aplicar otros métodos más complicados con el objetivo de mejorar la calidad de las predicciones.</li>
</ul>
<p>Veamos algunos métodos ingenuos y sus funciones en el paquete <code>forecast</code>.</p>
<p><br />
</p>
<div id="métodos-sencillos-de-predicción-1" class="section level2" number="3.1">
<h2 number="3.1"><span class="header-section-number">3.1</span> Métodos sencillos de predicción</h2>
<div id="series-sin-tendencia-y-sin-estacionalidad" class="section level3 unnumbered">
<h3 class="unnumbered">Series <em>sin</em> tendencia y <em>sin</em> estacionalidad</h3>
<p><strong>Método de la Media</strong>: <span class="math inline">\(\hat{y}_{T+h}=(y_1+\ldots,y_T)/T\)</span>.</p>
<ul>
<li>La predicción para cualquier periodo futuro es la <strong>media</strong> de las observaciones disponibles previas.</li>
<li>Función de <code>R</code>: <code>meanf(y, h)</code></li>
</ul>
<p><strong>Método ingenuo I</strong>: <span class="math inline">\(\hat{y}_{T+h}=y_T\)</span>.</p>
<ul>
<li>La predicción para cualquier periodo futuro es la <strong>última</strong> observación disponible.</li>
<li>Función de <code>R</code>: <code>naive(y, h)</code> o <code>rwf(y, h)</code> (<em>rw</em> de random walk)</li>
</ul>
</div>
<div id="series-con-tendencia-y-sin-estacionalidad" class="section level3 unnumbered">
<h3 class="unnumbered">Series <em>con</em> tendencia y <em>sin</em> estacionalidad</h3>
<p><strong>Método ingenuo II</strong>: <span class="math inline">\(\hat{y}_{T+h}=y_T + h(y_T-y_{T-1})\)</span>.</p>
<ul>
<li>La predicción <span class="math inline">\(h\)</span> periodos adelante es la <strong>última observación</strong> disponible más <span class="math inline">\(h\)</span> veces el <strong>último incremento</strong> observado.</li>
<li>No tiene función en <code>R</code>, pero se podría emular mediante la función <code>holt</code> (véase epígrafe de 4.5 Alisado exponencial de Holt).</li>
</ul>
<p><strong>Método de la deriva</strong>: <span class="math inline">\(\hat{y}_{T+h}=y_T+h\frac{y_T - y_1}{T-1}\)</span>.</p>
<ul>
<li>La predicción <span class="math inline">\(h\)</span> periodos adelante es la <strong>última observación</strong> disponible más <span class="math inline">\(h\)</span> veces el <strong>incremento medio</strong> observado.</li>
<li>Función de <code>R</code>: <code>rwf(y, h, drift = TRUE)</code></li>
</ul>
</div>
<div id="series-sin-tendencia-y-con-estacionalidad" class="section level3 unnumbered">
<h3 class="unnumbered">Series <em>sin</em> tendencia y <em>con</em> estacionalidad</h3>
<p><strong>Método ingenuo con estacionalidad</strong>: <span class="math inline">\(\hat{y}_{T+h}=y_{T-m(k+1)}\)</span>.</p>
<ul>
<li><span class="math inline">\(k\)</span> es la parte entera de <span class="math inline">\((h-1)/m\)</span>, es decir, el número de años completos en el periodo de predicción previo al periodo <span class="math inline">\(T+h\)</span>.</li>
<li>La predicción para un periodo es la <strong>última observación disponible de la misma estación que la fecha que se desea predecir</strong>.</li>
<li>Función de <code>R</code>: <code>snaive(y, h)</code></li>
</ul>
<p><strong>No hay métodos ingenuos cuando la serie tiene tendencia y estacionalidad</strong>, aunque la aplicación del método ingenuo con estacionalidad suele ser muy efectiva.</p>
<p><br />
</p>
</div>
</div>
<div id="ejemplo-de-aplicación" class="section level2" number="3.2">
<h2 number="3.2"><span class="header-section-number">3.2</span> Ejemplo de aplicación</h2>
<div id="serie-libros" class="section level3 unnumbered">
<h3 class="unnumbered">Serie Libros</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>libros <span class="ot">&lt;-</span> <span class="fu">read.csv2</span>(<span class="st">&quot;./series/libros.csv&quot;</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>libros <span class="ot">&lt;-</span> <span class="fu">ts</span>(libros[ ,<span class="dv">2</span>], <span class="at">start =</span> <span class="dv">1993</span>, <span class="at">frequency  =</span> <span class="dv">1</span>)</span></code></pre></div>
<p>En la figura 1 se muestra el resultado gráfico de la aplicación de algunos de estos métodos sencillos a la serie Libros (número de títulos publicados anualmente en España desde 1993 hasta 2018), con independencia de su adecuación dadas las componentes de esta serie. Se ha fijado un horizonte de previsión de cinco años (<code>h = 5</code>). El argumento <code>PI = FALSE</code> hace que no se impriman los intervalos de confianza de las predicciones.</p>
<p>Los métodos de la Media e Ingenuo I realizan una predicción constante, el primero la media de títulos en el periodo de análisis (61786) y el segundo el último dato observado (62180). El método de deriva ofrece una predicción creciente porque la serie Libros tiene una pendiente media positiva en el periodo de análisis.</p>
<p>Recuerda que debes cargar las librerías <code>forecast</code> y <code>ggplot2</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(mediaLibros <span class="ot">&lt;-</span> <span class="fu">meanf</span>(libros, <span class="at">h =</span> <span class="dv">5</span>))</span></code></pre></div>
<pre><code>     Point Forecast   Lo 80    Hi 80    Lo 95    Hi 95
2019       61786.23 47291.7 76280.76 39108.25 84464.21
2020       61786.23 47291.7 76280.76 39108.25 84464.21
2021       61786.23 47291.7 76280.76 39108.25 84464.21
2022       61786.23 47291.7 76280.76 39108.25 84464.21
2023       61786.23 47291.7 76280.76 39108.25 84464.21</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(naiveLibros <span class="ot">&lt;-</span> <span class="fu">naive</span>(libros, <span class="at">h =</span> <span class="dv">5</span>))</span></code></pre></div>
<pre><code>     Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
2019          62180 54474.50 69885.50 50395.46 73964.54
2020          62180 51282.78 73077.22 45514.14 78845.86
2021          62180 48833.68 75526.32 41768.57 82591.43
2022          62180 46769.00 77591.00 38610.91 85749.09
2023          62180 44949.98 79410.02 35828.96 88531.04</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(derivaLibros <span class="ot">&lt;-</span> <span class="fu">rwf</span>(libros,  <span class="at">h =</span> <span class="dv">5</span>, <span class="at">drift =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<pre><code>     Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
2019       63036.88 55252.76 70821.00 51132.10 74941.66
2020       63893.76 52667.34 75120.18 46724.44 81063.08
2021       64750.64 50739.23 78762.05 43322.03 86179.25
2022       65607.52 49131.65 82083.39 40409.84 90805.20
2023       66464.40 47717.76 85211.04 37793.89 95134.91</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(libros, <span class="at">series =</span> <span class="st">&quot;Libros&quot;</span>,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">ylab =</span> <span class="st">&quot;Títulos&quot;</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">main =</span> <span class="st">&quot;Figura 1. Libros y predicción por métodos sencillos&quot;</span>) <span class="sc">+</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autolayer</span>(mediaLibros, <span class="at">series=</span><span class="st">&quot;Media&quot;</span>, <span class="at">PI =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autolayer</span>(naiveLibros, <span class="at">series=</span><span class="st">&quot;Ingenuo&quot;</span>, <span class="at">PI =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autolayer</span>(derivaLibros, <span class="at">series=</span><span class="st">&quot;Deriva&quot;</span>, <span class="at">PI =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_colour_discrete</span>(<span class="at">limits=</span><span class="fu">c</span>(<span class="st">&quot;Libros&quot;</span>, <span class="st">&quot;Media&quot;</span>, <span class="st">&quot;Ingenuo&quot;</span>, <span class="st">&quot;Deriva&quot;</span>)) <span class="sc">+</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">guides</span>(<span class="at">colour =</span> <span class="fu">guide_legend</span>(<span class="at">title =</span> <span class="st">&quot;Métodos&quot;</span>)) <span class="sc">+</span> </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="fu">c</span>(<span class="fl">0.02</span>,<span class="fl">0.98</span>), <span class="at">legend.justification=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-2-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Con la función <code>accuracy</code> se puede obtener el error de predicción intra-muestral a un periodo vista de cada método:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(mediaLibros)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(naiveLibros)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(derivaLibros)</span></code></pre></div>
<pre><code>              ME     RMSE     MAE   MPE  MAPE MASE  ACF1
Media       0.00 10595.53 8155.92 -3.17 14.03 1.76  0.77
Ingenuo I 856.88  6012.63 4626.40  1.27  7.30 1.00 -0.04
Deriva      0.00  5951.26 4364.46 -0.13  6.87 0.94 -0.04</code></pre>
<p>Podemos destacar que:</p>
<ul>
<li>El método de <em>Media</em> presenta una baja capacidad predictiva debido a que la serie Libros tiene tendencia (MAPE = 14%). Además, el intervalo de confianza de las predicciones no es fiable (ACF1 = 0.77).</li>
<li>El método de <em>Deriva</em> tiene la mejor calidad de ajuste, con un error porcentual del 6.9% (MAPE), y un error medio aproximado de 6,000 títulos (RMSE). No presenta sesgo (ME = 0) y el intervalo de confianza de las predicciones es fiable (ACF1 = -0.04).</li>
<li>El método <em>Ingenuo I</em> tiene buena calidad de ajuste, pero las previsiones están muy sesgadas (ME = 857).</li>
<li>Para series sin estacionalidad el método sencillo de comparación usado en el cálculo del MASE es el <em>Ingenuo I</em>. Es por ello que este indicador vale 1 para este método.</li>
<li>El error medio (ME) siempre será nulo para el método de la <em>Media</em> y de la <em>Deriva</em>, lo que indica que nos equivocamos tanto por exceso como por defecto. Esta es una buena propiedad, que el método <em>Ingenuo I</em> no verifica.</li>
</ul>
</div>
<div id="serie-nacimientos" class="section level3 unnumbered">
<h3 class="unnumbered">Serie Nacimientos</h3>
<p>Podemos usar el método ingenuo con estacionalidad con la serie Nacimientos para obtener una previsión a dos años vista. El error absoluto porcentual medio es del 3.6%. Es decir, aplicando algo tan simple como predecir el número de nacimientos para un mes como los nacimientos del mismo mes del año previo, tenemos ya un error de predicción muy bajo. La figura 2 muestra la serie y la predicción que, debido al método usado, no incorpora la tendencia decreciente de los últimos años.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>nacimientos <span class="ot">&lt;-</span> <span class="fu">read.csv2</span>(<span class="st">&quot;./series/nacimientos.csv&quot;</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>nacimientos <span class="ot">&lt;-</span> <span class="fu">ts</span>(nacimientos[, <span class="dv">2</span>],</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">start =</span> <span class="fu">c</span>(<span class="dv">1975</span>, <span class="dv">1</span>),</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">frequency =</span> <span class="dv">12</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>(snaive.nacimientos <span class="ot">&lt;-</span> <span class="fu">snaive</span>(nacimientos, <span class="at">h =</span> <span class="dv">24</span>, <span class="at">level =</span> <span class="dv">95</span>))</span></code></pre></div>
<pre><code>         Point Forecast   Lo 95   Hi 95
Jan 2019          31772 28378.6 35165.4
Feb 2019          28211 24817.6 31604.4
Mar 2019          30340 26946.6 33733.4
Apr 2019          29436 26042.6 32829.4
May 2019          31061 27667.6 34454.4
Jun 2019          30546 27152.6 33939.4
Jul 2019          32521 29127.6 35914.4
Aug 2019          33059 29665.6 36452.4
Sep 2019          31406 28012.6 34799.4
Oct 2019          33059 29665.6 36452.4
Nov 2019          30696 27302.6 34089.4
Dec 2019          30670 27276.6 34063.4
Jan 2020          31772 26973.0 36571.0
Feb 2020          28211 23412.0 33010.0
Mar 2020          30340 25541.0 35139.0
Apr 2020          29436 24637.0 34235.0
May 2020          31061 26262.0 35860.0
Jun 2020          30546 25747.0 35345.0
Jul 2020          32521 27722.0 37320.0
Aug 2020          33059 28260.0 37858.0
Sep 2020          31406 26607.0 36205.0
Oct 2020          33059 28260.0 37858.0
Nov 2020          30696 25897.0 35495.0
Dec 2020          30670 25871.0 35469.0</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(snaive.nacimientos)</span></code></pre></div>
<pre><code>                    ME     RMSE      MAE       MPE     MAPE MASE      ACF1
Training set -574.8081 1731.361 1396.684 -1.456378 3.647108    1 0.7179587</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(snaive.nacimientos,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Nacimientos&quot;</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 2. Nacimientos y predicción por el método Ingenuo con estacionalidad&quot;</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-5-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
<br />
</p>
</div>
</div>
</div>
<div id="evaluación-de-las-predicciones" class="section level1" number="4">
<h1 number="4"><span class="header-section-number">4</span> Evaluación de las predicciones</h1>
<p>Las medidas que hemos usado hasta ahora para valorar la calidad de las predicciones son realmente medidas de bondad de ajuste, es decir, medidas de la calidad de <strong>previsiones intra-muestrales a un periodo vista</strong>. Valoran en que medida los datos se ajustan a un patrón o modelo, pero no evalúan la calidad de la previsiones ante nuevos datos.</p>
<p>En este epígrafe vamos a ver dos metodologías que podemos usar para valorar la calidad de las <strong>previsiones extra-muestrales</strong>, que es realmente los que nos interesa. Estas dos metodologías están relacionadas con los métodos de <em>Training set/Test set</em> y <em>Cross-validation</em> usuales en el análisis de las predicciones con datos transversales, pero adaptadas a datos temporales.</p>
<div id="validación-por-la-metodología-de-training-settest-set-para-series-temporales" class="section level2" number="4.1">
<h2 number="4.1"><span class="header-section-number">4.1</span> Validación por la metodología de <em>Training set/Test set</em> para Series Temporales</h2>
<p>Vamos a mejorar la estimación de la calidad de las predicciones obteniendo las medidas de error para <strong>previsiones extra-muestrales a varios periodos vista</strong> usando la filosofía del método <em>training set/test set</em>. Dividimos la serie temporal <span class="math inline">\(\{y_t\}_{t=1}^T\)</span> en dos subseries, los primeros datos <span class="math inline">\(\{y_t\}_{t=1}^{T_0}\)</span>, <span class="math inline">\(T_0 &lt; T\)</span> se usarán para estimar el modelo, y los últimos datos <span class="math inline">\(\{y_t\}_{t={T_0+1}}^{T}\)</span> para validar el modelo.</p>
<p>Esta metodología, muy efectiva para datos de corte transversal, genera dos problemas cuando se aplica a series temporales: <em>i</em>) el error obtenido es una mezcla de errores de predicción a corto, medio y largo plazo difícil de valorar; <em>ii</em>) los resultados dependen tremendamente del punto de corte temporal seleccionado.</p>
<div id="serie-libros-1" class="section level3 unnumbered">
<h3 class="unnumbered">Serie Libros</h3>
<p>Vamos a reservar, por ejemplo, las últimas 6 observaciones de la serie Libros y ajustar el modelo con las restantes. Después usaremos este modelo para calcular las predicciones a 6 periodos vista y compararlas con los valores reales de la serie.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Definimos las observaciones intra- y extra-muestrales</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>librosIntra <span class="ot">&lt;-</span> <span class="fu">subset</span>(libros, <span class="at">end =</span> <span class="fu">length</span>(libros) <span class="sc">-</span> <span class="dv">6</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>librosExtra <span class="ot">&lt;-</span> <span class="fu">subset</span>(libros, <span class="at">start =</span> <span class="fu">length</span>(libros) <span class="sc">-</span> <span class="dv">5</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimamos el modelo con todos los datos menos los 6 ultimos y</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"># predecimos los 6 años que hemos quitado de la serie </span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>librosExtraPre <span class="ot">&lt;-</span> <span class="fu">rwf</span>(librosIntra,  <span class="at">h =</span> <span class="dv">6</span>, <span class="at">drift =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Vemos la calidad del ajuste. Primero la predicción y luego los datos reales</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(librosExtraPre, librosExtra)</span></code></pre></div>
<pre><code>                    ME     RMSE      MAE    MPE  MAPE MASE  ACF1 Theil&#39;s U
Training set      0.00  5863.85  4279.52  -0.05  6.53 0.87 -0.19        NA
Test set     -15759.36 15817.29 15759.36 -26.65 26.65 3.22 -0.24      6.19</code></pre>
<p>Atendiendo al MAPE se tiene que el error de <strong>previsión a un periodo vista</strong> en el <strong>periodo intra-muestral</strong> de <strong>1993 a 2012</strong> es del 6.5%; mientras que el error de <strong>previsión a largo plazo</strong> en el <strong>periodo extra-muestral</strong> de <strong>2013 a 2018</strong> es del 26.6%. Ademas, para el periodo extra-muestral el error medio (ME) es negativo y muy elevado, un indicativo de que las previsiones están segadas (sobre-estiman la realidad). En resumen, la calidad del modelo se deteriora muy rápidamente en cuanto nos salimos de las condiciones óptimas.</p>
<p>Un gráfico puede ayudar a entender este proceso de validación. En la figura 3:</p>
<ul>
<li>La línea de puntos vertical separa el periodo muestral (1993-2012) usado para estimar el modelo, del periodo extra-muestral (2013-2018) usado sólo para hacer las previsiones.</li>
<li>La serie Libros aparece como una línea sólida en negro, desde 1993 hasta 2018.</li>
<li>La previsión <em>intra</em>-muestral (a un periodo vista) de la serie Libros aparece como una línea azul.</li>
<li>La línea en rojo es la previsión <em>extra</em>-muestral a largo plazo. Observa que todas las previsiones están por encima del valor real de la serie.</li>
<li>Al lado de cada previsión (intra- y extra-muestral) se ha indicado el error estimado (MAPE).</li>
</ul>
<p>Claramente estos resultados dependen del punto de corte seleccionado.</p>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-8-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="serie-nacimientos-1" class="section level3 unnumbered">
<h3 class="unnumbered">Serie Nacimientos</h3>
<p>Calculamos de nuevo los diferentes criterios de bondad de ajuste para valorar la calidad de las previsiones extra-muestrales a largo plazo. En este caso vamos a reservar los últimos 36 meses como periodo extra-muestral.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>nacimientosIntra <span class="ot">&lt;-</span> <span class="fu">subset</span>(nacimientos, <span class="at">end =</span> <span class="fu">length</span>(nacimientos) <span class="sc">-</span> <span class="dv">36</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>nacimientosExtra <span class="ot">&lt;-</span> <span class="fu">subset</span>(nacimientos, <span class="at">start =</span> <span class="fu">length</span>(nacimientos) <span class="sc">-</span> <span class="dv">35</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>nacimientosExtraPre <span class="ot">&lt;-</span> <span class="fu">snaive</span>(nacimientosIntra, <span class="at">h =</span> <span class="dv">36</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(nacimientosExtraPre, nacimientosExtra)</span></code></pre></div>
<pre><code>                   ME    RMSE     MAE   MPE MAPE MASE ACF1 Theil&#39;s U
Training set  -518.93 1742.83 1394.96 -1.26 3.59 1.00 0.72        NA
Test set     -2342.47 2783.26 2440.75 -7.37 7.66 1.75 0.68      1.68</code></pre>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-11-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Las previsiones extra-muestrales muestran una menor pendiente que los casos reales de nacimientos. Así, conforme se avanza en el horizonte temporal las previsiones se van alejando de la realidad y el error extra-muestral es del 7.7%, reducido pero que duplica el error de estimación intra-muestral (3.6%).</p>
<p><br />
</p>
</div>
</div>
<div id="validación-cruzada-para-series-temporales" class="section level2" number="4.2">
<h2 number="4.2"><span class="header-section-number">4.2</span> Validación cruzada para Series Temporales</h2>
<p>Hemos visto dos alternativas para evaluar la calidad de un método de predicción de series temporales, uno basado en predicciones intra-muestrales a un periodo vista y otro basado en predicciones extra-muestrales a largo plazo, ambas con sus inconvenientes.</p>
<p>Veamos ahora una técnica, basada en el concepto de validación cruzada (<em>cross validation</em>) que permite obtener de forma individualizada los errores de previsión extra-muestral a un periodo vista, a dos periodos vista, etc.</p>
<p>Supongamos que para estimar el modelo se necesita un mínimo de <span class="math inline">\(k\)</span> observaciones y que se desea predecir hasta un horizonte temporal <span class="math inline">\(h\)</span>.</p>
<ul>
<li><p>Seleccionamos las observaciones <span class="math inline">\(1,2,...,k\)</span> para estimar el modelo y predecimos las observaciones desde <span class="math inline">\(k+1\)</span> hasta <span class="math inline">\(k+h\)</span>. Tenemos, por tanto, <span class="math inline">\(h\)</span> predicciones.</p></li>
<li><p>Calculamos el error de predicción para las predicciones desde <span class="math inline">\(k+1\)</span> hasta <span class="math inline">\(k+h\)</span>.</p></li>
<li><p>Repetimos este proceso desplazando el número de observaciones seleccionadas para la estimación un periodo adelante. Es decir, ahora usamos las observaciones <span class="math inline">\(2,3,...,k+1\)</span> para estimar el modelo, predecimos las observaciones desde <span class="math inline">\(k+2\)</span> hasta <span class="math inline">\(k+1+h\)</span> y calculamos el error de predicción.</p></li>
<li><p>Iteramos el proceso, desplazando cada vez las observaciones de la estimación un periodo adelante.</p></li>
<li><p>En general para <span class="math inline">\(i=0,1,...,T-k-h\)</span>, donde <span class="math inline">\(T\)</span> es el número total de observaciones:</p>
<ol style="list-style-type: decimal">
<li>Seleccionamos las observaciones <span class="math inline">\(i+1,i+2,...,i+k\)</span> para estimar el modelo.</li>
<li>Predecimos las observaciones desde <span class="math inline">\(i+k+1\)</span> hasta <span class="math inline">\(i+k+h\)</span>.</li>
<li>Calculamos el error de predicción para las observaciones desde <span class="math inline">\(i+k+1\)</span> hasta <span class="math inline">\(i+k+h\)</span>.</li>
<li>Para cada horizonte temporal de predicción se calcula la medida de error deseada.</li>
</ol></li>
</ul>
<p><br />
<br />
</p>
<p><img src="imagenes/RollingWindows.png" /></p>
<p>Este procedimiento se denomina <strong>origen de predicción móvil</strong> (<em>rolling forecast origin</em>) o <em>rolling windows</em>.</p>
<p>Cuando se aplica esta metodología hay que tener en cuenta que los resultados pueden depender del número <span class="math inline">\(k\)</span> de datos usados para la estimación del modelo.</p>
<div id="ejemplo-de-aplicación-con-nacimientos" class="section level3 unnumbered">
<h3 class="unnumbered">Ejemplo de aplicación con Nacimientos</h3>
<p>Vamos a aplicar la metodología previa a la serie anual de Nacimientos. Asumimos que se precisan veinte años para hacer una buena estimación, <span class="math inline">\(k=20\)</span>, y que el horizonte temporal es de cinco años, <span class="math inline">\(h = 5\)</span> meses. La siguiente rutina permite obtener el MAPE para previsiones con un horizonte temporal desde uno a cinco años.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>nacAnual <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(nacimientos, <span class="at">FUN =</span> sum)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">20</span>                   <span class="co">#Minimo numero de datos para estimar</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>h <span class="ot">&lt;-</span> <span class="dv">5</span>                    <span class="co">#Horizonte de las prediciciones</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>TT <span class="ot">&lt;-</span> <span class="fu">length</span>(nacAnual)    <span class="co">#Longitud serie</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>s <span class="ot">&lt;-</span> TT <span class="sc">-</span> k <span class="sc">-</span> h           <span class="co">#Total de estimaciones</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>mapeRwf <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, s <span class="sc">+</span> <span class="dv">1</span>, h)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">0</span><span class="sc">:</span>s) {</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  train.set <span class="ot">&lt;-</span> <span class="fu">subset</span>(nacAnual, <span class="at">start =</span> i <span class="sc">+</span> <span class="dv">1</span>, <span class="at">end =</span> i <span class="sc">+</span> k)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  test.set <span class="ot">&lt;-</span>  <span class="fu">subset</span>(nacAnual, <span class="at">start =</span> i <span class="sc">+</span> k <span class="sc">+</span> <span class="dv">1</span>, <span class="at">end =</span> i <span class="sc">+</span> k <span class="sc">+</span> h)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>  fcast <span class="ot">&lt;-</span> <span class="fu">rwf</span>(train.set, <span class="at">h =</span> h, <span class="at">drift =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>  mapeRwf[i <span class="sc">+</span> <span class="dv">1</span>,] <span class="ot">&lt;-</span> <span class="dv">100</span><span class="sc">*</span><span class="fu">abs</span>(test.set <span class="sc">-</span> fcast<span class="sc">$</span>mean)<span class="sc">/</span>test.set</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>mapeRwf <span class="ot">&lt;-</span> <span class="fu">colMeans</span>(mapeRwf)</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(mapeRwf, <span class="dv">2</span>)</span></code></pre></div>
<pre><code>[1]  4.21  8.16 12.15 16.20 20.42</code></pre>
<p>El error de previsión extra-muestral crece linealmente con el horizonte de previsión. Para el primer año el error de predicción se mantiene en un moderado 4.2%. Sin embargo, para el segundo año de predicción el MAPE salta al 8.2% y para los restantes años sigue creciendo rápidamente. Predecir usando la tendencia media solo es un buen método para predecir a un año vista.</p>
<p><br />
<br />
</p>
</div>
</div>
</div>
<div id="métodos-de-alisado-exponencial" class="section level1" number="5">
<h1 number="5"><span class="header-section-number">5</span> Métodos de Alisado Exponencial</h1>
<div id="introducción-1" class="section level2" number="5.1">
<h2 number="5.1"><span class="header-section-number">5.1</span> Introducción</h2>
<p>Los métodos de alisado exponencial aparecen en los años 50 de la mano de Brown, Holt y Winters y han sido la raíz de uno de los métodos de predicción más sencillos y eficaces. La idea básica es predecir usando una media ponderada de los datos pasados, donde los más recientes tienen un peso mayor y este decae exponencialmente conforme usamos observaciones más antiguas.</p>
<p>El alisado exponencial es una familia de métodos de ajuste y previsión que ofrece muy buenos resultados para predicciones a corto plazo o para predecir series con pocos datos o <em>sencillas</em> (sin mucho <em>ruido</em>).</p>
<p>Suponen un grado de modelización mayor que los métodos sencillos vistos previamente, pero sin alcanzar la complejidad de otras metodologías (modelos ARIMA).</p>
<p>En origen, son métodos descriptivos con el único objetivo de producir <strong>predicciones puntuales</strong>. Sin embargo, su enfoque como modelos de <em>espacio de estados</em> posibilita un marco teórico para obtener <strong>intervalos de predicción</strong>.</p>
<p><br />
</p>
</div>
<div id="componentes-de-una-serie-en-el-contexto-del-alisado-exponencial" class="section level2" number="5.2">
<h2 number="5.2"><span class="header-section-number">5.2</span> Componentes de una serie en el contexto del alisado exponencial</h2>
<p>Para obtener una predicción en el periodo <span class="math inline">\(t+1\)</span> con datos hasta el periodo <span class="math inline">\(t\)</span> necesitamos tres componentes:</p>
<ul>
<li>La estimación del nivel de la serie en el periodo <span class="math inline">\(t\)</span>: <span class="math inline">\(l_t\)</span></li>
<li>La estimación de la pendiente de la serie en el periodo <span class="math inline">\(t\)</span>: <span class="math inline">\(b_t\)</span></li>
<li>La estimación de la estacionalidad en el mes correspondiente al periodo <span class="math inline">\(t+1\)</span> con datos hasta <span class="math inline">\(t\)</span>: <span class="math inline">\(s_{t + 1 - m}\)</span> (recuerda, <span class="math inline">\(m\)</span> es el orden estacional</li>
</ul>
<p>A partir de estas componentes, obtenidas en el periodo <span class="math inline">\(t\)</span> y para un esquema aditivo, se tendría que la predicción en el periodo <span class="math inline">\(t+1\)</span> es: <span class="math display">\[\widehat{y}_{t+1} = l_t+b_t+s_{t+1-m}.\]</span> En general, las componentes pueden <strong>existir o no</strong> y se pueden combinar entre ellas <strong>aditiva o multiplicativamente</strong>. Veamos algunos casos:</p>
<ul>
<li>Existen todas y son multiplicativas: <span class="math display">\[\widehat{y}_{t+1}=l_t \cdot b_t \cdot s_{t + 1 - m}\]</span></li>
<li>Existen todas, nivel y pendiente aditivas, y estacionalidad multiplicativa: <span class="math display">\[\widehat{y}_{t+1}=(l_t+b_t)s_{t + 1 - m}\]</span></li>
<li>No hay pendiente y la estacionalidad es aditiva: <span class="math display">\[\widehat{y}_{t+1}=l_t+s_{t + 1 - m}\]</span></li>
</ul>
<p>¿Como obtenemos los valores de <span class="math inline">\(l_t\)</span>, <span class="math inline">\(b_t\)</span> y <span class="math inline">\(s_{t + 1 - m}\)</span>? Mediante <strong>expresiones recursivas</strong>, donde cada componente se calcula a partir de los valores hasta <span class="math inline">\(t\)</span> de la serie y de las componentes: <span class="math display">\[
\begin{aligned}
l_t&amp; = f_l(y_t,y_{t-1}\ldots, l_{t-1},l_{t-2}\ldots,b_{t-1},b_{t-2}\ldots,s_{t-1},s_{t-2}\ldots) \\
b_t&amp; = f_b(y_t,y_{t-1}\ldots, l_{t},l_{t-1}\ldots,b_{t-1},b_{t-2}\ldots,s_{t-1},s_{t-2}\ldots) \\
s_t&amp; = f_s(y_t,y_{t-1}\ldots, l_{t},l_{t-1}\ldots,b_{t},b_{t-1}\ldots,s_{t-1},s_{t-2}\ldots)
\end{aligned}
\]</span> Por ejemplo, el <em>método ingenuo I</em> se puede interpretar dentro de este contexto como un método de alisado donde <span class="math inline">\(l_t = y_t\)</span> y no hay ni pendiente ni estacionalidad. Por tanto, <span class="math inline">\(\widehat{y}_{T+1} = l_{T} = y_{T}\)</span>.</p>
<p>De la misma forma, el <em>método ingenuo II</em> se puede interpretar como un método de alisado donde <span class="math inline">\(l_t = y_t\)</span>, <span class="math inline">\(b_t = y_t - y_{t-1}\)</span> y no hay estacionalidad. Entonces, <span class="math inline">\(\widehat{y}_{T+1}=l_T + b_T = y_T + (y_T - y_{T-1})\)</span>.</p>
<p>En las expresiones previas hemos supuesto que se quería obtener una predicción a un periodo vista (<span class="math inline">\(\widehat{y}_{t+1}\)</span>). Si el objetivo es estimar una previsión <span class="math inline">\(h\)</span> periodos hacia delante desde el periodo <span class="math inline">\(t\)</span>, <span class="math inline">\(\widehat{y}_{t+h}\)</span>, hay que realizar algunas modificaciones. Por ejemplo, para el caso aditivo se tendría que <span class="math display">\[\widehat{y}_{t+h} = l_t+hb_t+s_{t+h-m(k+1)}\]</span> donde <span class="math inline">\(k = \lfloor (h-1)/m\rfloor\)</span>.</p>
<p>El concepto de componentes aquí visto no coincide con el definido en el Tema 1. Sin embargo, podemos asimilar la tendencia de una serie como la suma (multiplicación) del nivel y la pendiente <span class="math inline">\(T_{t+1} = l_t + b_t\)</span> (<span class="math inline">\(T_{t+1} = l_t \cdot b_t\)</span>) y de esta forma ambas definiciones de componentes de una serie se hacen compatibles.</p>
<p><br />
<br />
</p>
</div>
<div id="casos-posibles" class="section level2" number="5.3">
<h2 number="5.3"><span class="header-section-number">5.3</span> Casos posibles</h2>
<p>Todas las series tiene nivel, pero dependiendo del tipo de pendiente y estacionalidad hay 15 casos posibles, mostrados en la tabla siguiente.</p>
<table>
<thead>
<tr class="header">
<th align="left">Tendencia</th>
<th align="center"></th>
<th align="center">Estacionalidad</th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="center">Ninguna (N)</td>
<td align="center">Aditiva (A)</td>
<td align="center">Multiplicativa (M)</td>
</tr>
<tr class="even">
<td align="left">Ninguna (N)</td>
<td align="center"><strong>N, N</strong></td>
<td align="center">N, A</td>
<td align="center">N, M</td>
</tr>
<tr class="odd">
<td align="left">Aditiva (A)</td>
<td align="center"><strong>A, N</strong></td>
<td align="center"><strong>A, A</strong></td>
<td align="center"><strong>A, M</strong></td>
</tr>
<tr class="even">
<td align="left">Aditiva Amortiguada (Ad)</td>
<td align="center"><strong>Ad, N</strong></td>
<td align="center">Ad, A</td>
<td align="center">Ad, M</td>
</tr>
<tr class="odd">
<td align="left">Multiplicativa (M)</td>
<td align="center">M, N</td>
<td align="center">M, A</td>
<td align="center">M, M</td>
</tr>
<tr class="even">
<td align="left">Multiplicativa Amortiguada (Md)</td>
<td align="center">Md, N</td>
<td align="center">Md, A</td>
<td align="center">Md, M</td>
</tr>
</tbody>
</table>
<p>Cada caso difiere en las componentes que se observan y su esquema, dando lugar a un conjunto diferente de ecuaciones recursivas de actualización.</p>
<p>Si se añade que el error puede ser aditivo o multiplicativo, da 30 posibilidades. <strong>El tipo de error (aditivo o multiplicativo) no afecta ni a la estimación ni a la previsión puntual, sólo es relevante en el cálculo del intervalo de confianza de las predicciones.</strong></p>
<p>Los modelos más usuales son:</p>
<ul>
<li>(N, N): Alisado exponencial simple</li>
<li>(A, N): Alisado de Holt</li>
<li>(Ad, N): Alisado con tendencia amortiguada (d de <em>damped</em>)</li>
<li>(A, A): Alisado de Holt-Winters aditivo</li>
<li>(A, M): Alisado de Holt-Winters multiplicativo</li>
</ul>
<p>Acude al artículo de <a href="http://www.jstatsoft.org/v27/i03/paper">Rob J. Hyndman y Yeasmin Khandakar (2008)</a> para saber más de cada modelo, o al libro <em>Forecasting with Exponential Smoothing: the State Space Approach</em> (2008) de Hyndman y otros autores.</p>
<p><br />
</p>
</div>
<div id="alisado-exponencial-simple-n-n" class="section level2" number="5.4">
<h2 number="5.4"><span class="header-section-number">5.4</span> Alisado exponencial simple (N, N)</h2>
<div id="definición" class="section level3 unnumbered">
<h3 class="unnumbered">Definición</h3>
<p>El alisado exponencial simple es adecuado para una serie estacionaria y sin estacionalidad. Es decir, una serie que se mueve alrededor de un nivel constante.</p>
<p>La ecuación de la <strong>predicción intra-muestral</strong> es <span class="math display">\[\hat{y}_{t+1} = \alpha y_t + \alpha (1-\alpha) y_{t-1} + \alpha (1-\alpha)^2 y_{t-2} + \alpha (1-\alpha)^3 y_{t-3} + \ldots =  \alpha y_t + (1-\alpha)\hat{y}_{t},\]</span> donde <span class="math inline">\(0 \leq \alpha \leq 1\)</span> es el parámetro de suavizado. La primera <strong>predicción extra-muestral</strong> queda <span class="math display">\[\hat{y}_{T+1}=\alpha y_T + (1-\alpha)\hat{y}_{T}\]</span> y para las restantes <span class="math display">\[\hat{y}_{T+h} = \hat{y}_{T+1}.\]</span></p>
</div>
<div id="formulas-interactivas-de-sus-componentes" class="section level3 unnumbered">
<h3 class="unnumbered">Formulas interactivas de sus componentes</h3>
<p>En el alisado exponencial simple solo hay una componente, el nivel <span class="math inline">\(l_t\)</span>.</p>
<ul>
<li>La <strong>ecuación recursiva</strong> de suavizado es <span class="math inline">\(l_t=\alpha y_t + (1-\alpha)l_{t-1}\)</span></li>
<li>La ecuación de <strong>predicción intra-muestral</strong> es <span class="math inline">\(\hat{y}_{t+1} = l_t\)</span></li>
<li>La ecuación de <strong>predicción extra-muestral</strong> es <span class="math inline">\(\hat{y}_{T+h} = \hat{y}_{T+1} = l_T\)</span></li>
</ul>
<p>Dos estimaciones razonables de <span class="math inline">\(l_t\)</span>, el nivel de la serie en el periodo <span class="math inline">\(t\)</span>, son el valor observado para la serie en ese periodo <span class="math inline">\(y_t\)</span> y el nivel del periodo previo <span class="math inline">\(l_{t-1}\)</span>. La estimación final de <span class="math inline">\(l_t\)</span> es una media ponderada de ambas y esta estimación final es la previsión de la serie para el periodo siguiente.</p>
</div>
<div id="estimación-de-los-parámetros-del-modelo" class="section level3 unnumbered">
<h3 class="unnumbered">Estimación de los parámetros del modelo</h3>
<p>Dado el proceso iterativo para el cálculo de <span class="math inline">\(l_t\)</span> se necesita un <strong>valor inicial</strong> de arranque <span class="math inline">\(l_0\)</span>. Cada programa estadístico usa su propio método para obtener <span class="math inline">\(l_0\)</span>.</p>
<p>Respecto de <span class="math inline">\(\alpha\)</span>, usualmente se estima el valor <strong>optimo</strong> según un criterio de precisión de la predicción. El parámetro <span class="math inline">\(\alpha\)</span> <strong>se puede interpretar</strong> como:</p>
<ul>
<li>Si <span class="math inline">\(\alpha = 1\)</span> se tiene el <em>método ingenuo I</em> (<span class="math inline">\(\hat{y}_{t+1}=y_t\)</span>), óptimo cuando el nivel de la serie varía constantemente en el tiempo.</li>
<li>Si <span class="math inline">\(\alpha = 0\)</span> se tiene <span class="math inline">\(\hat{y}_{t} =l_0\)</span>, óptimo cuando el nivel permanece constante en el tiempo.</li>
</ul>
</div>
<div id="ejemplo" class="section level3 unnumbered">
<h3 class="unnumbered">Ejemplo</h3>
<p>Vamos a usar el método de alisado exponencial simple para predecir la serie Libros. Usaremos para ello la función <code>ses</code> (<em>simple exponential smoothing</em>) con una previsión a 5 años vista (<code>h = 5</code>). Esta función estima los valores de <span class="math inline">\(l_0\)</span> y <span class="math inline">\(\alpha\)</span> que maximizan la función de verosimilitud, pero se pueden elegir otros criterios con el parámetro <code>opt.crit</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>librosf <span class="ot">&lt;-</span> <span class="fu">ses</span>(libros, <span class="at">h =</span> <span class="dv">5</span>, <span class="at">level =</span> <span class="dv">95</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(librosf)</span></code></pre></div>
<pre><code>
Forecast method: Simple exponential smoothing

Model Information:
Simple exponential smoothing 

Call:
 ses(y = libros, h = 5, level = 95) 

  Smoothing parameters:
    alpha = 0.9756 

  Initial states:
    l = 40846.9233 

  sigma:  6135.033

     AIC     AICc      BIC 
542.1615 543.2524 545.9358 

Error measures:
                   ME     RMSE      MAE      MPE     MAPE     MASE        ACF1
Training set 839.0525 5894.349 4452.239 1.240605 7.032466 0.962355 -0.01829562

Forecasts:
     Point Forecast    Lo 95    Hi 95
2019       62131.07 50106.63 74155.52
2020       62131.07 45331.71 78930.44
2021       62131.07 41640.83 82621.32
2022       62131.07 38520.03 85742.12
2023       62131.07 35766.08 88496.07</code></pre>
<p>Veamos la salida en detalle:</p>
<ul>
<li>El valor de <span class="math inline">\(\alpha\)</span> que optimiza el criterio usado para medir la calidad del ajuste es <span class="math inline">\(\alpha =\)</span> 0.98, un valor muy cercano a 1. Esto es un indicativo de que: i) la serie Libros cambia de nivel de forma constante, un rasgo en los procesos puramente estocásticos como el paseo aleatorio; ii) y el método de alisado exponencial simple se aproxima al método Ingenuo I.</li>
<li>El valor de arranque <span class="math inline">\(l_0\)</span> óptimo es 40846.92.</li>
<li><em>sigma</em> es la desviación típica del error (aditivo) de predicción. Se diferencia de RMSE en el denominador. Para calcular sigma en lugar de dividir por <span class="math inline">\(T\)</span> se divide por <span class="math inline">\(T\)</span> menos el número de parámetros estimados (en este caso 3, <span class="math inline">\(l_0\)</span>, <span class="math inline">\(\alpha\)</span> y <em>sigma</em>).</li>
<li>La calidad de ajuste es razonable, como evidencia el error porcentual medio del 7%.</li>
<li>Las predicciones son las mismas para los 5 años, como cabe esperar (recuerda que <span class="math inline">\(\hat{y}_{T+h} = \hat{y}_{T+1}\)</span>).</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(librosf<span class="sc">$</span>model<span class="sc">$</span>states, <span class="at">n =</span> <span class="dv">4</span>)</span></code></pre></div>
<pre><code>Time Series:
Start = 2015 
End = 2018 
Frequency = 1 
            l
[1,] 60887.22
[2,] 59599.15
[3,] 60170.73
[4,] 62131.07</code></pre>
<p>En el objeto <code>librosf</code> la matriz <code>librosf$model$states</code> guarda todos los valores del nivel obtenidos con la ecuación recursiva, incluidos el valor de arranque, así que es una matriz con <span class="math inline">\(T+1\)</span> filas. Puedes ver el valor de <span class="math inline">\(l_{2018}\)</span> en su última fila, que vale 62131.07. Así, la predicción para <span class="math inline">\(2019\)</span> es <span class="math inline">\(\widehat{y}_{2019}=l_{2018}=\)</span> 62131.07. Igualmente <span class="math inline">\(\widehat{y}_{2020}=l_{2018}=\)</span> 62131.07. Es decir, todas las previsiones son iguales a <span class="math inline">\(l_{2018}\)</span>.</p>
<p>La figura 6 muestra la serie Libros y las previsiones extra-muestrales, que son constantes, y el intervalo de confianza. Conforme aumentamos el horizonte de predicción, el intervalo de confianza es más amplio como reflejo de la mayor incertidumbre en la predicción.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(librosf,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Títulos&quot;</span>,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 6. Libros y predicción con alisado simple&quot;</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-15-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
</div>
<div id="alisado-exponencial-de-holt-a-n" class="section level2" number="5.5">
<h2 number="5.5"><span class="header-section-number">5.5</span> Alisado exponencial de Holt (A, N)</h2>
<p>El alisado exponencial de Holt es adecuado para una serie no estacionaria y sin estacionalidad.</p>
<div id="formulas-interactivas-de-sus-componentes-1" class="section level3 unnumbered">
<h3 class="unnumbered">Formulas interactivas de sus componentes</h3>
<p>Las <strong>ecuaciones recursivas</strong> son <span class="math display">\[
\begin{aligned}
l_t &amp; =\alpha y_t + (1-\alpha)(l_{t-1}+b_{t-1}) \\
b_t &amp; =\beta (l_t - l_{t-1}) + (1-\beta)b_{t-1} 
\end{aligned}
\]</span> La ecuación de la <strong>predicción intra-muestral</strong> a un periodo vista es <span class="math display">\[\hat{y}_{t+1} = l_t + b_t,\]</span> de forma que la ecuación de <strong>predicción extra-muestral</strong> es <span class="math display">\[\hat{y}_{T+h}=l_T + h b_T.\]</span></p>
<p>Dos estimaciones razonables del nivel de la serie en el periodo <span class="math inline">\(t\)</span> son el valor observado para la serie en ese periodo <span class="math inline">\(y_t\)</span>, y una estimación del nivel del periodo <span class="math inline">\(t\)</span> realizada desde el periodo <span class="math inline">\(t-1\)</span>: <span class="math inline">\(l_{t-1} + b_{t-1}\)</span>. Por otro lado, dos estimaciones razonables de la pendiente de la serie en el periodo <span class="math inline">\(t\)</span> son el último cambio de nivel observado <span class="math inline">\(l_t-l_{t-1}\)</span>, y el valor de la pendiente en el periodo previo, <span class="math inline">\(b_{t-1}\)</span>. En ambos casos, nivel y pendiente, la estimación final es una media ponderada, parametrizada por <span class="math inline">\(0 \leq \alpha, \: \beta \leq 1\)</span>.</p>
</div>
<div id="estimación-de-los-parámetros-del-modelo-1" class="section level3 unnumbered">
<h3 class="unnumbered">Estimación de los parámetros del modelo</h3>
<p>Para aplicar este método es necesario estimar unos valores iniciales <span class="math inline">\(l_0\)</span> y <span class="math inline">\(b_0\)</span> de las ecuaciones recursivas e identificar los valores más adecuados de los parámetros <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span>. Los <strong>valores óptimos</strong> de estos cuatro parámetros se obtienen optimizando una medida de precisión de las predicciones.</p>
<p>La interpretación del parámetro <span class="math inline">\(\alpha\)</span> es similar al caso del alisado exponencial simple.</p>
<p><strong>Interpretación del parámetro <span class="math inline">\(\beta\)</span></strong>:</p>
<ul>
<li>Si <span class="math inline">\(\beta = 1\)</span>, <span class="math inline">\(b_t = l_t - l_{t-1}\)</span>, la pendiente se actualiza constantemente porque varía periodo a periodo Puede ser un indicador de mal ajuste (tendencia no lineal o pendiente no aditiva).</li>
<li>Si <span class="math inline">\(\beta = 0\)</span>, <span class="math inline">\(b_t = b_{t-1}= \ldots = b_0\)</span>, la pendiente se mantiene constante en el tiempo.</li>
</ul>
<p>El <em>método ingenuo II</em> es un caso concreto de Alisado de Holt. Si hacemos <span class="math inline">\(\alpha=\beta = 1\)</span>, queda <span class="math inline">\(l_t=y_t\)</span> y <span class="math inline">\(b_t=y_t-y_{t-1}\)</span>, por tanto <span class="math display">\[\hat{y}_{T+h}=l_T + h \cdot b_T = y_T + h(y_T - y_{T-1}).\]</span></p>
</div>
<div id="ejemplo-1" class="section level3 unnumbered">
<h3 class="unnumbered">Ejemplo</h3>
<p>Vamos a usar el método de alisado de Holt para predecir de nuevo la serie Libros. Usaremos para ello la función <code>holt</code> con una previsión a 5 años vista (<code>h = 5</code>).</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>librosf <span class="ot">&lt;-</span> <span class="fu">holt</span>(libros, <span class="at">h =</span> <span class="dv">5</span>, <span class="at">level =</span> <span class="dv">95</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(librosf)</span></code></pre></div>
<pre><code>
Forecast method: Holt&#39;s method

Model Information:
Holt&#39;s method 

Call:
 holt(y = libros, h = 5, level = 95) 

  Smoothing parameters:
    alpha = 0.9513 
    beta  = 0.0001 

  Initial states:
    l = 41061.2751 
    b = 808.0212 

  sigma:  6342.639

     AIC     AICc      BIC 
545.6297 548.6297 551.9202 

Error measures:
                   ME    RMSE      MAE        MPE     MAPE      MASE       ACF1
Training set 1.059887 5834.38 4235.524 -0.1683705 6.717033 0.9155118 0.00362974

Forecasts:
     Point Forecast    Lo 95    Hi 95
2019       62930.86 50499.52 75362.21
2020       63738.89 46580.48 80897.29
2021       64546.91 43706.74 85387.08
2022       65354.93 41391.54 89318.33
2023       66162.96 39438.34 92887.57</code></pre>
<p>Los valores óptimos de los cuatro parámetros son <span class="math inline">\(\alpha=\)</span> 0.95, <span class="math inline">\(\beta=\)</span> 0, <span class="math inline">\(l_0 =\)</span> 41061.28 y <span class="math inline">\(b_0 =\)</span> 808.02. Observa que <span class="math inline">\(\alpha\)</span> es prácticamente 1 y que <span class="math inline">\(\beta\)</span> es cero. Si aplicamos estos valores de los parámetros a las ecuaciones recursivas y la predicción extra-muestral, obtenemos <span class="math inline">\(y_{T+h}=y_T + hb_0\)</span>: la predicción es el último valor observado más la primera pendiente estimada.</p>
<p>La calidad de las predicciones es razonable, con un error porcentual medio del 6.7%, y se ha mejorado respecto del alisado exponencial simple.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(librosf<span class="sc">$</span>model<span class="sc">$</span>states, <span class="at">n =</span> <span class="dv">4</span>)</span></code></pre></div>
<pre><code>Time Series:
Start = 2015 
End = 2018 
Frequency = 1 
            l        b
2015 60809.31 808.1407
2016 59666.92 807.9356
2017 60199.13 807.9066
2018 62122.84 808.0240</code></pre>
<p>De nuevo, en el objeto <code>librosf</code> la matriz <code>librosf$model$states</code> guarda todos los valores obtenidos con las ecuaciones recursivas, en este caso el nivel y la pendiente, incluidos los valores de arranque. Puedes ver los valores de <span class="math inline">\(l_{2018}\)</span> y <span class="math inline">\(b_{2018}\)</span> en su última fila, que valen respectivamente 62122.84, 808.02. Así, la predicción para <span class="math inline">\(2019\)</span> es <span class="math inline">\(\widehat{y}_{2019}=l_{2018} + b_{2018}=\)</span> 62122.84 <span class="math inline">\(+\)</span> 808.02 <span class="math inline">\(=\)</span> 62930.86. Igualmente <span class="math inline">\(\widehat{y}_{2020}=l_{2018} + 2\cdot b_{2018}=\)</span> 63738.89. Es decir, el incremento entre previsiones es contante e igual a <span class="math inline">\(b_{2018}\)</span> que, por ser <span class="math inline">\(\beta\)</span> prácticamente nulo, coincide con <span class="math inline">\(b_0\)</span>.</p>
<p>La figura 7 muestra la serie Libros y las previsiones extra-muestrales que muestran una ligera tendencia creciente.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(librosf,</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Títulos&quot;</span>,</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 7. Libros y predicción con alisado de Holt&quot;</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-18-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
</div>
<div id="alisado-exponencial-con-pendiente-amortiguada-ad-n" class="section level2" number="5.6">
<h2 number="5.6"><span class="header-section-number">5.6</span> Alisado exponencial con pendiente amortiguada (Ad, N)</h2>
<p>Las previsiones con el método de Holt presentan siempre una pendiente constante. En previsiones a corto plazo esto no es un problema, pero para previsiones a largo plazo la experiencia indica que suele aparecer un sesgo de previsión. El alisado exponencial con pendiente amortiguada trata de corregir esta limitación. El mecanismo, propuesto por Gardner y McKenzie en 1985, es introducir un nuevo parámetro <span class="math inline">\(0 \leq \phi \leq 1\)</span> que <em>amortigua</em> la tendencia hasta hacerla plana en el largo plazo.</p>
<div id="formulas-interactivas-de-sus-componentes-2" class="section level3 unnumbered">
<h3 class="unnumbered">Formulas interactivas de sus componentes</h3>
<p>Las <strong>ecuaciones recursivas</strong> son <span class="math display">\[
\begin{aligned}
l_t &amp; =\alpha y_t + (1-\alpha)(l_{t-1}+\phi b_{t-1}) \\
b_t &amp; =\beta (l_t - l_{t-1}) + (1-\beta)\phi b_{t-1} 
\end{aligned}
\]</span> La ecuación de la <strong>predicción intra-muestral</strong> a un periodo vista es <span class="math display">\[\hat{y}_{t+1} = l_t + \phi b_t,\]</span> de forma que la ecuación de <strong>predicción extra-muestral</strong> es <span class="math display">\[\hat{y}_{T+h}=l_T + (\phi + \phi^2 + \ldots + \phi^h) b_T.\]</span></p>
<p>Si <span class="math inline">\(\phi = 1\)</span> se tiene el alisado de Holt y si <span class="math inline">\(\phi = 0\)</span> se tiene el alisado simple. Para valores entre <span class="math inline">\(0\)</span> y <span class="math inline">\(1\)</span> en el corto plazo las predicciones tienen pendiente y en el largo plazo se hacen constantes e iguales a <span class="math inline">\(l_T + \phi b_T/(1 - \phi)\)</span>.</p>
</div>
<div id="ejemplo-2" class="section level3 unnumbered">
<h3 class="unnumbered">Ejemplo</h3>
<p>Vamos a usar el método de alisado con amortiguamiento para predecir, una vez más, la serie Libros añadiendo a la función <code>holt</code> el argumento <code>damped = TRUE</code>. Por razones prácticas el rango de búsqueda de <span class="math inline">\(\phi\)</span> queda en el intervalo <span class="math inline">\([0.8, 0.98]\)</span>. En este caso, para ver el efecto del <em>amortiguamiento</em> vamos a fijar el valor de <span class="math inline">\(\phi\)</span> a <span class="math inline">\(0.9\)</span> y vamos a pedir un horizonte temporal más largo.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>librosfd <span class="ot">&lt;-</span> <span class="fu">holt</span>(libros, <span class="at">damped =</span> <span class="cn">TRUE</span>, <span class="at">h =</span> <span class="dv">15</span>, <span class="at">phi =</span> <span class="fl">0.9</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(librosfd)</span></code></pre></div>
<pre><code>
Forecast method: Damped Holt&#39;s method

Model Information:
Damped Holt&#39;s method 

Call:
 holt(y = libros, h = 15, damped = TRUE, phi = 0.9) 

  Smoothing parameters:
    alpha = 0.8885 
    beta  = 0.0001 
    phi   = 0.9 

  Initial states:
    l = 39515.4609 
    b = 4345.5669 

  sigma:  6337.754

     AIC     AICc      BIC 
544.3801 547.3801 550.6706 

Error measures:
                    ME     RMSE      MAE       MPE     MAPE      MASE
Training set -610.6056 5695.848 3943.135 -1.422026 6.229522 0.8523118
                   ACF1
Training set 0.00189887

Forecasts:
     Point Forecast    Lo 80    Hi 80    Lo 95     Hi 95
2019       62238.63 54116.47 70360.79 49816.86  74660.40
2020       62465.35 51599.92 73330.77 45848.12  79082.58
2021       62669.39 49625.05 75713.74 42719.79  82619.00
2022       62853.04 47944.62 77761.45 40052.58  85653.49
2023       63018.31 46454.06 79582.57 37685.47  88351.16
2024       63167.06 45097.88 81236.24 35532.64  90801.49
2025       63300.94 43842.72 82759.15 33542.17  93059.71
2026       63421.42 42666.80 84176.05 31679.96  95162.89
2027       63529.86 41555.06 85504.67 29922.30  97137.43
2028       63627.46 40496.65 86758.26 28251.94  99002.97
2029       63715.29 39483.49 87947.10 26655.95 100774.64
2030       63794.34 38509.37 89079.32 25124.31 102464.38
2031       63865.49 37569.42 90161.56 23649.12 104081.86
2032       63929.52 36659.77 91199.28 22224.03 105635.01
2033       63987.15 35777.26 92197.05 20843.84 107130.47</code></pre>
<p>La figura 8 muestra la serie Libros, su estimación (intra-muestral) y las predicciones a 15 años vista. Observa que la pendiente de las previsiones se <em>amortigua</em> en el tiempo, de forma que al principio las previsiones crecen más rápidamente que en los últimos años.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(librosfd,</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Títulos&quot;</span>,</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 8. Libros y predicción con alisado exponencial con amortiguamiento&quot;</span>,</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">PI =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-20-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
</div>
<div id="alisado-de-holt-winters-aditivo-a-a-y-multiplicativo-a-m" class="section level2" number="5.7">
<h2 number="5.7"><span class="header-section-number">5.7</span> Alisado de Holt-Winters aditivo (A, A) y multiplicativo (A, M)</h2>
<p>El método de alisado exponencial de Holt-Winters es adecuado para una serie con tendencia y con estacionalidad. Existen dos versiones según que el esquema sea aditivo o multiplicativo.</p>
<div id="alisado-de-holt-winters-aditivo-a-a" class="section level3 unnumbered">
<h3 class="unnumbered">Alisado de Holt-Winters aditivo (A, A)</h3>
<p>Las <strong>ecuaciones recursivas</strong> de actualización son: <span class="math display">\[
\begin{aligned}
l_t &amp; =\alpha (y_t - s_{t-m} ) + (1-\alpha)(l_{t-1}+b_{t-1}) \\
b_t &amp; =\beta (l_t - l_{t-1}) + (1-\beta)b_{t-1} \\
s_t &amp; =\gamma (y_t - l_{t-1} - b_{t-1}) + (1 - \gamma)s_{t-m}
\end{aligned}
\]</span> con <span class="math inline">\(0 \leq \alpha, \beta, \gamma \leq 1\)</span>.</p>
<p>La ecuación de la <strong>predicción intra-muestral</strong> a un periodo vista es <span class="math display">\[\hat{y}_{t+1}  = l_t + b_t + s_{t+1-m},\]</span> de forma que la ecuación de <strong>predicción extra-muestral es</strong>: <span class="math display">\[\hat{y}_{T+h}=l_T + h b_T + s_{T+h - m(k+1)},\]</span> con <span class="math inline">\(k = \lfloor(h-1)/m\rfloor\)</span>.</p>
</div>
<div id="alisado-de-holt-winters-multiplicativo-a-m" class="section level3 unnumbered">
<h3 class="unnumbered">Alisado de Holt-Winters multiplicativo (A, M)</h3>
<p>Las <strong>ecuaciones recursivas</strong> de actualización son: <span class="math display">\[
\begin{aligned}
l_t &amp; =\alpha \frac{y_t}{s_{t-m}} + (1-\alpha)(l_{t-1}+b_{t-1}) \\
b_t &amp; =\beta (l_t - l_{t-1}) + (1-\beta)b_{t-1} \\
s_t &amp; =\gamma \frac{y_t}{l_{t-1} + b_{t-1}} + (1 - \gamma)s_{t-m}
\end{aligned}
\]</span></p>
<p>La ecuación de la <strong>predicción intra-muestral</strong> a un periodo vista es <span class="math display">\[\hat{y}_{t+1}  = (l_t + b_t)s_{t+1-m},\]</span> de forma que la ecuación de <strong>predicción extra-muestral es</strong>: <span class="math display">\[\hat{y}_{T+h}=(l_T + h b_T)s_{T+h - m(k+1)}.\]</span></p>
</div>
<div id="ejemplo-3" class="section level3 unnumbered">
<h3 class="unnumbered">Ejemplo</h3>
<p>Vamos a usar el método de Holt-Winters para predecir la serie Nacimientos, que presentaba un esquema multiplicativo. Para ello usaremos la función <code>hw</code> con el argumento <code>seasonal = "multiplicative"</code> (que sería <code>seasonal = "additive"</code> en caso de esquema aditivo). Vamos a considerar la serie Nacimientos desde enero de 2000 y pedir una previsión a dos años vista.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>nacimientosb <span class="ot">&lt;-</span> <span class="fu">window</span>(nacimientos, <span class="at">start =</span> <span class="dv">2000</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>nacimientosbf <span class="ot">&lt;-</span> <span class="fu">hw</span>(nacimientosb, <span class="at">seasonal =</span> <span class="st">&quot;mult&quot;</span>, <span class="at">h =</span> <span class="dv">24</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(nacimientosbf)</span></code></pre></div>
<pre><code>
Forecast method: Holt-Winters&#39; multiplicative method

Model Information:
Holt-Winters&#39; multiplicative method 

Call:
 hw(y = nacimientosb, h = 24, seasonal = &quot;mult&quot;) 

  Smoothing parameters:
    alpha = 0.3892 
    beta  = 0.0148 
    gamma = 0.0425 

  Initial states:
    l = 33009.2785 
    b = 145.6544 
    s = 1.0025 0.9974 1.0527 1.0436 1.0281 1.0366
           0.9722 1.0146 0.9623 0.9901 0.9043 0.9958

  sigma:  0.023

     AIC     AICc      BIC 
4329.668 4332.583 4387.967 

Error measures:
                    ME     RMSE     MAE        MPE    MAPE      MASE      ACF1
Training set -74.07627 832.4718 662.566 -0.2262176 1.79118 0.4718897 0.0605442

Forecasts:
         Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
Jan 2019       30514.76 29617.09 31412.44 29141.88 31887.64
Feb 2019       27577.35 26701.93 28452.78 26238.50 28916.20
Mar 2019       30121.05 29094.43 31147.67 28550.97 31691.14
Apr 2019       29081.10 28021.40 30140.80 27460.42 30701.78
May 2019       30487.72 29304.26 31671.17 28677.78 32297.66
Jun 2019       29290.89 28083.51 30498.26 27444.37 31137.40
Jul 2019       31030.75 29676.27 32385.24 28959.25 33102.26
Aug 2019       30723.23 29306.62 32139.85 28556.71 32889.76
Sep 2019       30978.00 29472.49 32483.50 28675.53 33280.47
Oct 2019       31294.54 29694.70 32894.37 28847.80 33741.28
Nov 2019       29527.19 27942.21 31112.16 27103.17 31951.20
Dec 2019       29549.08 27886.35 31211.81 27006.15 32092.00
Jan 2020       29307.40 27570.10 31044.70 26650.43 31964.37
Feb 2020       26482.60 24842.63 28122.56 23974.48 28990.71
Mar 2020       28921.35 27052.66 30790.03 26063.44 31779.25
Apr 2020       27918.96 26038.95 29798.96 25043.73 30794.18
May 2020       29265.29 27213.70 31316.88 26127.65 32402.92
Jun 2020       28112.50 26062.87 30162.14 24977.86 31247.15
Jul 2020       29778.17 27522.36 32033.99 26328.20 33228.14
Aug 2020       29478.88 27160.65 31797.11 25933.45 33024.31
Sep 2020       29719.07 27294.94 32143.21 26011.68 33426.47
Oct 2020       30018.43 27480.73 32556.12 26137.36 33899.49
Nov 2020       28319.03 25839.72 30798.35 24527.25 32110.82
Dec 2020       28335.89 25768.57 30903.21 24409.51 32262.27</code></pre>
<p>Los valores óptimos de los parámetros son <span class="math inline">\(\alpha=\)</span> 0.39, <span class="math inline">\(\beta=\)</span> 0.01 y <span class="math inline">\(\gamma=\)</span> 0.04. Los valores tan bajos para <span class="math inline">\(\beta\)</span> y <span class="math inline">\(\gamma\)</span> indican que ambas, la pendiente y la estacionalidad, modifican su valor muy lentamente. Es decir, hay pendiente y hay efecto estacional, pero permanecen constantes en el tiempo.</p>
<p>La calidad de las predicciones es notable, con un error porcentual medio del 1.8%. Recuerda que con el método ingenuo con estacionalidad el error era del 3.6%.</p>
<p>Los últimos valores de las componentes son</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>TT <span class="ot">&lt;-</span> <span class="fu">nrow</span>(nacimientosbf<span class="sc">$</span>model<span class="sc">$</span>states)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>nacimientosbf<span class="sc">$</span>model<span class="sc">$</span>states[TT,]</span></code></pre></div>
<pre><code>        l         b        s1        s2        s3        s4        s5        s6 
30722.451  -100.998     1.001     0.997     1.053     1.039     1.027     1.034 
       s7        s8        s9       s10       s11       s12 
    0.973     1.009     0.959     0.990     0.904     0.997 </code></pre>
<p>Como el último dato de la serie es diciembre de 2018, los valores del nivel <span class="math inline">\(l\)</span> y la pendiente <span class="math inline">\(b\)</span> mostrados corresponden a ese periodo. Sin embargo, la componente estacional tiene un orden muy peculiar: s1 es el valor estacional para diciembre (mes del último dato), s2 el de noviembre, s3 de octubre, hasta s11 que sería febrero y s12 que es enero. Podemos reproducir las predicciones para los primeros 12 meses de enero a diciembre con (ojo, el etiquetado de la salida no es correcto):</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>(nacimientosbf<span class="sc">$</span>model<span class="sc">$</span>states[TT, <span class="dv">1</span>] <span class="sc">+</span> (<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>)<span class="sc">*</span>nacimientosbf<span class="sc">$</span>model<span class="sc">$</span>states[TT, <span class="dv">2</span>]) <span class="sc">*</span> </span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  nacimientosbf<span class="sc">$</span>model<span class="sc">$</span>states[TT, <span class="dv">14</span><span class="sc">:</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>     s12      s11      s10       s9       s8       s7       s6       s5 
30514.76 27577.35 30121.05 29081.10 30487.72 29290.89 31030.75 30723.23 
      s4       s3       s2       s1 
30978.00 31294.54 29527.19 29549.08 </code></pre>
<p>La figura 9 muestra la serie Nacimientos y las previsiones extra-muestrales.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(nacimientosbf,</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Nacimientos&quot;</span>,</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 9. Nacimientos y predicción con alisado de Holt-Winters multiplicativo&quot;</span>,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">PI =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-25-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="ejemplo-con-transformación-logarítmica" class="section level2" number="5.8">
<h2 number="5.8"><span class="header-section-number">5.8</span> Ejemplo con transformación logarítmica</h2>
<p>Una alternativa a predecir la serie Nacimientos, que tiene esquema multiplicativo, es predecir la transformación logarítmica de la serie, que tendrá un esquema aditivo. Después, se aplica la transformación inversa y se obtienen las predicciones de la serie original.</p>
<p>Este proceso se puede realizar de forma sencilla y transparente con cualquiera de las funciones de alisado exponencial que hemos visto a partir de los argumentos <code>lambda</code> y <code>biasadj</code>.</p>
<ul>
<li><code>lambda = 0</code> indica a la función de alisado que se ha de realizar la transformación logarítmica de la serie. Es un parámetro de la transformación Box-Cox que veremos en detalle en el tema 3.</li>
<li><code>biasadj = TRUE</code> es necesario si tras una transformación de la serie original queremos que las predicciones sean insesgadas. Sea <span class="math inline">\(y_t\)</span> la serie original y <span class="math inline">\(z_t=log(y_t)\)</span> su transformación logarítmica. Si obtenemos una predicción <span class="math inline">\(\hat{y}_t\)</span> de la serie original, esta será insesgada <span class="math inline">\(E[\hat{y}_t]=y_t\)</span>. Ahora bien, si obtenemos una predicción <span class="math inline">\(\hat{z}_t\)</span> de la serie transformada, podemos pensar que <span class="math inline">\(e^{\hat{z}_t}\)</span> es una predicción insesgada de la serie original, pero resulta que <span class="math inline">\(E[e^{\hat{z}_t}] \neq y_t\)</span>. Es decir, la exponencial de la predicción de la serie transformada logarítmicamente no es insesgada. Si el argumento <code>biasadj</code> es fijado a FALSE, las predicciones se calcularan de forma directa deshaciendo la transformación y serán sesgadas; si es fijado a TRUE, las predicciones se calcularan por medio de una fórmula alternativa y serán insesgadas. En ambos casos las estimaciones son consistentes, así que para series largas no debería observarse mucha diferencia entre las dos alternativas.</li>
</ul>
<p>Vamos a practicar el uso de estos argumentos con la serie Nacimientos. Como se va a predecir el logaritmo de la serie, se debe indicar a la función <code>hw</code> que use el modelo Holt-Winters aditivo.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>nacimientosbfl <span class="ot">&lt;-</span> <span class="fu">hw</span>(nacimientosb, </span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">seasonal =</span> <span class="st">&quot;addit&quot;</span>, </span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">h =</span> <span class="dv">24</span>, </span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">lambda =</span> <span class="dv">0</span>, </span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">biasadj =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(nacimientosbfl)</span></code></pre></div>
<pre><code>
Forecast method: Holt-Winters&#39; additive method

Model Information:
Holt-Winters&#39; additive method 

Call:
 hw(y = nacimientosb, h = 24, seasonal = &quot;addit&quot;, lambda = 0,  

 Call:
     biasadj = TRUE) 

  Box-Cox transformation: lambda= 0 

  Smoothing parameters:
    alpha = 0.2611 
    beta  = 0.0478 
    gamma = 0.0001 

  Initial states:
    l = 10.4305 
    b = 0.0097 
    s = 0.0043 -0.0008 0.0526 0.0381 0.0245 0.0318
           -0.0282 0.01 -0.0338 -0.0047 -0.0961 0.0023

  sigma:  0.0246

      AIC      AICc       BIC 
-435.1078 -432.1936 -376.8090 

Error measures:
                    ME     RMSE     MAE        MPE     MAPE     MASE      ACF1
Training set -50.30465 885.6888 713.322 -0.1715636 1.929063 0.508039 0.2646609

Forecasts:
         Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
Jan 2019       30643.42 29685.38 31613.34 29195.06 32144.27
Feb 2019       27694.28 26788.35 28611.96 26325.44 29115.08
Mar 2019       30259.54 29214.19 31319.20 28681.11 31901.31
Apr 2019       29309.36 28231.72 30402.72 27683.51 31004.78
May 2019       30537.11 29335.00 31758.03 28725.20 32432.21
Jun 2019       29309.90 28069.48 30571.20 27442.29 31269.90
Jul 2019       31036.27 29620.72 32477.54 28907.57 33278.76
Aug 2019       30724.51 29212.67 32266.04 28454.02 33126.32
Sep 2019       31060.84 29411.90 32744.77 28588.01 33688.47
Oct 2019       31427.98 29629.37 33267.80 28734.81 34303.48
Nov 2019       29715.86 27885.00 31591.96 26978.83 32653.07
Dec 2019       29785.78 27813.47 31810.58 26842.30 32961.51
Jan 2020       29646.88 27541.13 31812.87 26509.83 33050.47
Feb 2020       26799.16 24761.67 28899.17 23769.40 30105.59
Mar 2020       29288.00 26909.63 31744.51 25758.10 33163.67
Apr 2020       28375.09 25919.20 30917.19 24737.31 32394.33
May 2020       29571.25 26849.15 32395.21 25547.33 34045.98
Jun 2020       28390.55 25616.78 31274.77 24298.78 32971.15
Jul 2020       30071.41 26959.40 33315.04 25490.46 35234.88
Aug 2020       29778.39 26520.45 33182.40 24993.09 35210.21
Sep 2020       30114.00 26637.35 33755.60 25018.83 35939.32
Oct 2020       30480.19 26773.45 34372.72 25060.14 36722.70
Nov 2020       28829.86 25142.93 32711.70 23451.24 35071.41
Dec 2020       28908.35 25026.90 33005.90 23259.27 35514.24</code></pre>
<p>Observa que en este caso la calidad de las predicciones (MAPE = 1.9%) es inferior a la obtenida con la serie sin transformar.</p>
<p>La figura 10 muestra la serie Nacimientos y las previsiones extra-muestrales obtenidas con y sin la transformación logarítmica.</p>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-27-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>La siguiente tabla muestra las predicciones de Nacimientos obtenidas sin transformar la serie, con transformación logarítmica y predicciones insesgadas (<code>biasadj = TRUE</code>), y con transformación logarítmica y predicciones sesgadas (<code>biasadj = FALSE</code>).</p>
<pre><code>         Sin transformar log(Nac) insesgadas log(Nac) sesgadas
Jan 2019        30514.76            30643.42          30634.19
Feb 2019        27577.35            27694.28          27685.14
Mar 2019        30121.05            30259.54          30248.39
Apr 2019        29081.10            29309.36          29297.12
May 2019        30487.72            30537.11          30522.48
Jun 2019        29290.89            29309.90          29293.65
Jul 2019        31030.75            31036.27          31016.26
Aug 2019        30723.23            30724.51          30701.42
Sep 2019        30978.00            31060.84          31033.63
Oct 2019        31294.54            31427.98          31395.92
Nov 2019        29527.19            29715.86          29680.66
Dec 2019        29549.08            29785.78          29744.96</code></pre>
<p>Observa que las predicciones sesgadas son menores que las insesgadas. Esto siempre es así. La diferencia depende fundamentalmente de la varianza del error, <em>sigma</em> al cuadrado en la salida de los métodos de alisado exponencial. Cuanto mayor es la varianza del error, mayores son las diferencias.</p>
<p>Por otro lado, las predicciones obtenidas sin y con la transformación logarítmica no guardan ninguna relación.</p>
<p><strong>Ni la transformación logarítmica ni el uso de predicciones insesgadas aseguran mejores predicciones respecto de otras opciones</strong>, como pueden ser trabajar con predicciones sesgadas o no realizar la transformación logarítmica.</p>
<p><br />
</p>
</div>
<div id="casos-generales-de-alisado-exponencial" class="section level2" number="5.9">
<h2 number="5.9"><span class="header-section-number">5.9</span> Casos generales de alisado exponencial</h2>
<p>En los epígrafes previos hemos visto cinco de los casos expuestos en la taxonomía del epígrafe 4.3, y las funciones de <code>R</code> asociadas. Veamos ahora como estimar cualquiera de los quince modelos que surgen según las diferentes posibilidades de la tendencia (N, A, Ad, M y Md) y de la estacionalidad (N, A y M).</p>
<p>Recordemos que al añadir el error, aditivo o multiplicativo, estos quince modelos se convierten en treinta. Sin embargo, el tipo de error no influye en el cálculo de las previsiones, solo influye en el cálculo del intervalo de confianza de estas.</p>
<div id="la-función-ets" class="section level3 unnumbered">
<h3 class="unnumbered">La función <code>ets</code></h3>
<p>Podemos estimar cualquiera de los treinta modelos usando la función <code>ets</code> del paquete <code>forecast</code>. A diferencia de las funciones previas <code>ses</code>, <code>holt</code> y <code>hw</code>, la función <code>ets</code> solo estima los modelos, pero no produce predicciones. Para ello habrá que usar la función <code>forecast</code> sobre un modelo estimado con <code>ets</code>. Mira la ayuda para ver una explicación detallada de los argumentos de estas funciones.</p>
<ul>
<li>El tipo de modelo en <code>ets</code> se especifica con el argumento <code>model</code>, un código de tres letras indicando el tipo de Error, Tendencia y eStacionalidad (ETS). Por ejemplo, <code>model = "ANN"</code> indica un modelo con error aditivo, sin tendencia ni estacionalidad, es decir, el alisado exponencial simple; <code>model = "AAN"</code> indica un modelo con error aditivo, pendiente aditiva, pero sin estacionalidad, el alisado exponencial de Holt. El alisado exponencial de Holt-Winters multiplicativo sería <code>model = "AAM"</code>.</li>
<li>Si se desea incluir amortiguamiento, hay que incluir el argumento <code>damped = TRUE</code>.</li>
<li>Por defecto <code>ets</code> no considera modelos con tendencia multiplicativa (últimas dos líneas de la taxonomía del epígrafe 5.3). Debes fijar el parámetro <code>allow.multiplicative.trend=TRUE</code> para contemplar esta opción.</li>
<li>Además, se sigue disponiendo de los argumentos <code>lambda</code> y <code>biasadj</code>.</li>
</ul>
<p><strong>Criterios de optimización</strong></p>
<p>Fijado un modelo, <code>ets</code> estima por defecto sus parámetros maximizando la función de verosimilitud. Esta búsqueda esta restringida a <span class="math inline">\(0 &lt; \beta &lt; \alpha &lt; 1\)</span>, <span class="math inline">\(0 &lt; \gamma &lt; 1 - \alpha\)</span> y <span class="math inline">\(0.8 &lt; \phi &lt; 0.98\)</span>. Es decir, los tres primeros parámetros nunca pueden ser 0 o 1, y en la práctica sus valores límite son 0.0001 y 0.9999.</p>
<p>Puedes cambiar el criterio de optimización con el argumento <code>opt.crit</code>. Por defecto vale “lik”, pero si lo fijas a <code>opt.crit = "mse"</code> se estiman los parámetros que minimizan el error cuadrático medio. Otra opción interesante es <code>opt.crit = "amse"</code> que minimiza la media de los errores cuadráticos medios obtenido sobre las previsiones a <code>nmse</code> periodos vista. En este caso usa el argumento <code>nmse</code> para fijar el valor numérico del horizonte temporal.</p>
<p><strong>Selección de modelos</strong></p>
<p>Lo más habitual es no saber cual es el mejor modelo, entendiendo como tal, el que mejor se ajusta a la serie temporal. De hecho, si lo que buscamos es predecir bien, más que entender la naturaleza del proceso generador de datos, el mejor modelo será el que mejor prediga.</p>
<p>Si en una de las tres letras del código del modelo se indica “Z”, la función <code>ets</code> selecciona de entre los modelos posibles el que mejor se ajusta. Por ejemplo, <code>model = "AAZ"</code> indica un modelo con error y pendiente aditivos y dejaría a <code>ets</code> la búsqueda de la mejor opción para la estacionalidad (nula, aditiva o multiplicativa). Si se especifica <code>model = "ZZZ</code> junto con <code>damped = NULL</code> (opciones por defecto) se dejaría a la función total libertad para buscar entre todos los modelos (excepto aquellos con pendiente multiplicativa). Si se desea restringir la búsqueda a modelos sin amortiguamiento basta indicar <code>damped = FALSE</code> y si se desea restringir la búsqueda solo a modelos aditivos se puede usar el argumento <code>additive.only = TRUE</code>.</p>
<p>Queda pendiente saber que criterio se usa para seleccionar el modelo cuando se ofrece esta opción. Esto se hace a partir de un criterio de información entre Akaike (aic), Akaike corregido para pequeñas muestras (aicc) y el Bayesiano (bic). Sus fórmulas son: <span class="math display">\[aic = -2log(L) + 2k\]</span> <span class="math display">\[aicc = aic + \frac{k(k+1)}{T-k-1}\]</span> <span class="math display">\[bic=aic + k(log(T) - 2)\]</span> donde <span class="math inline">\(L\)</span> es la verosimilitud, <span class="math inline">\(T\)</span> el número de datos y <span class="math inline">\(k\)</span> el de parámetros (incluidos los puntos iniciales de arranque y la varianza residual).</p>
<p>Por defecto se usa Akaike corregido para pequeñas muestras, pero el argumento <code>ic</code> permite cambiar de criterio.</p>
</div>
<div id="una-reflexión-sobre-los-métodos-automáticos-de-selección-de-modelos" class="section level3 unnumbered">
<h3 class="unnumbered">Una reflexión sobre los métodos automáticos de selección de modelos</h3>
<p>Con el comando <code>forecast(ets(nacimientos), h = 24)</code> obtenemos una predicción mensual a dos años vista del número de nacimientos en España. Así de simple, solo 31 caracteres. Todo esto gracias a que un algoritmo interno ha estimado los parámetros de múltiples modelos, elegido el mejor modelo de todos y lo ha usado para obtener las predicciones. Podemos afirmar que tenemos las mejores predicciones. Un momento, ¿podemos?</p>
<p>Parémonos a reflexionar sobre lo que hemos hecho –más bien lo que el algoritmo ha hecho– y a contrastarlo con lo que nosotros queríamos. Por un lado, el algoritmo estima los parámetros de un menú fijo de modelos y para ello usa un criterio de optimización, que por defecto es maximizar la función de verosimilitud; cuando ya tiene estimados todos los modelos, elije el mejor usando el criterio de información de Akaike corregido para muestras pequeñas; y finalmente, nosotros medimos la capacidad predictiva del modelo seleccionado usando el error absoluto porcentual medio. Vaya, resulta que en los procesos de identificación y estimación del mejor modelo se usan dos criterios diferentes, que además no coinciden con nuestro criterio de calidad de las predicciones.</p>
<p>Si consideramos que la calidad de un modelo viene dada por el error absoluto porcentual medio en las predicciones intra-muestrales a un periodo vista (lo que hemos decidido llamar MAPE), ¿no deberíamos estimar los parámetros del modelo usando como criterio la minimización del MAPE?, ¿no deberíamos elegir entre varios modelos aquel que presenta un MAPE menor? De esta forma, en todos los pasos del proceso se usa el mismo criterio, que es, además, el criterio que hemos considerado adecuado para valorar la calidad de las predicciones.</p>
<p>Pero no es esto lo que hacemos.</p>
<p>Nada nos garantiza que el modelo estimado y seleccionado por el algoritmo estime las mejores predicciones posibles. Y por <em>mejores</em> quiero decir que de entre todos los posibles modelos del menú y todos los posibles valores de sus parámetros, el seleccionado sea que el minimiza nuestro criterio de calidad de las predicciones.</p>
<p>Ahora ya podemos dar respuesta a la pregunta del primer párrafo: no, no podemos afirmar que nuestras predicciones sean las mejores.</p>
<p>Alguien dirá que casi seguro entre las predicciones sub-óptimas obtenidas por el algoritmo con su extraña mezcla de criterios y las predicciones óptimas de verdad no habrá mucha diferencia. Total, que más da una función de verosimilitud que un criterio de información que una medida del error medio. Pero lo cierto es que no lo sabemos, no tenemos ni idea de la distancia que hay entre lo óptimo y lo sub-óptimo, y si el coste de equivocarme en las predicciones es alto, puede que incluso una pequeña diferencia sea relevante.</p>
<p>Esta reflexión realizada en el contexto de series temporales y para la función <code>ets</code> es aplicable a todos los casos donde dejamos que un algoritmo ya programado elija el mejor modelo, y se basa en el hecho de que rara vez los criterios de estimación y elección que usan los algoritmos coinciden con el concepto de calidad de ajuste que estamos interesados.</p>
<p>A pesar de lo aquí expuesto, como es más cómodo (y rápido) tirar de rutinas ya programadas que escribir tu propio código, seguiremos trabajando con modelos sub-óptimos y obteniendo estimaciones sub-óptimas, pero diciendo que son las mejores.</p>
<p><br />
</p>
</div>
<div id="residuo-aditivo-versus-residuo-multiplicativo" class="section level3 unnumbered">
<h3 class="unnumbered">Residuo aditivo versus residuo multiplicativo</h3>
<p>En los modelos de alisado estimados por la función <code>ets</code> la fórmula para el cálculo del residuo estimado depende de su naturaleza aditiva o multiplicativa.</p>
<p>Si el <strong>residuo es aditivo</strong>, entonces el modelo es <span class="math inline">\(y_t = \hat{y}_t + \hat{\varepsilon}_t\)</span> y el residuo se define de la forma usual <span class="math display">\[\hat{\varepsilon}_t = y_t - \hat{y}_t.\]</span> Ahora bien, si el <strong>residuo es multiplicativo</strong>, entonces el modelo es <span class="math inline">\(y_t = \hat{y}_t \cdot (1 + \hat{\varepsilon}_t)\)</span>, y no <span class="math inline">\(y_t = \hat{y}_t \cdot \hat{\varepsilon}_t\)</span>, como se podría esperar. Por tanto, el residuo multiplicativo se define como <span class="math display">\[\varepsilon_t = (y_t - \hat{y}_t)/\hat{y}_t.\]</span> De esta forma en ambos casos el residuo evoluciona alrededor del valor 0 y se le pueden imponer las hipótesis usuales de ruido blanco.</p>
<p>La función <code>residual</code> permite extraer de un objeto <code>ets</code> el residuo del modelo. Si el modelo tiene residuo multiplicativo y se desea obtener el residuo aditivo, se debe usar con el argumento <code>type = "response"</code>.</p>
<p><br />
<br />
</p>
</div>
</div>
</div>
<div id="ejemplo-de-aplicación-libros" class="section level1" number="6">
<h1 number="6"><span class="header-section-number">6</span> Ejemplo de aplicación: Libros</h1>
<p><br />
</p>
<div id="identificación-y-estimación-del-mejor-modelo" class="section level2" number="6.1">
<h2 number="6.1"><span class="header-section-number">6.1</span> Identificación y estimación del mejor modelo</h2>
<p>Si estimamos el mejor modelo de alisado exponencial para la serie Libros sin ningún tipo de restricción, nos encontramos:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>librosEts <span class="ot">&lt;-</span> <span class="fu">ets</span>(libros)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(librosEts) </span></code></pre></div>
<pre><code>ETS(M,N,N) 

Call:
 ets(y = libros) 

  Smoothing parameters:
    alpha = 0.9999 

  Initial states:
    l = 40449.9278 

  sigma:  0.0919

     AIC     AICc      BIC 
536.4611 537.5520 540.2354 

Training set error measures:
                   ME     RMSE      MAE      MPE    MAPE      MASE       ACF1
Training set 835.8489 5896.169 4460.311 1.251566 7.04867 0.9640998 -0.0393776</code></pre>
<p>El modelo estimado es ETS(M,N,N) o “MNN”, un modelo sin pendiente ni estacionalidad y con error multiplicativo. Es decir, <span class="math inline">\(y_{t+1} = l_t \cdot (1 + \varepsilon_{t+1})\)</span>.</p>
<p>El valor de <span class="math inline">\(\alpha\)</span> técnicamente es 1, indicando que el nivel de la serie varia en el tiempo y que realmente estamos usando para las previsiones el método ingenuo I.</p>
<p>Respecto de la calidad del modelo, el valor de MAPE= <span class="math inline">\(7\)</span>% evidencia que estamos ante un modelo que ajusta razonablemente bien a los datos, y MASE= <span class="math inline">\(0.96\)</span> indica que el modelo de alisado exponencial simple reduce en solo un <span class="math inline">\(4\)</span>% el error del método ingenuo I.</p>
</div>
<div id="predicción" class="section level2" number="6.2">
<h2 number="6.2"><span class="header-section-number">6.2</span> Predicción</h2>
<p>Mediante la función <code>forecast</code> podemos predecir los casos de Libros. Por tratarse de un modelo de alisado exponencial simple, la predicción es constante en el tiempo (véase figura 11).</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>librosEtsPre <span class="ot">&lt;-</span> <span class="fu">forecast</span>(librosEts, <span class="at">h =</span> <span class="dv">5</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>librosEtsPre</span></code></pre></div>
<pre><code>     Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
2019        62179.8 54859.93 69499.66 50985.03 73374.56
2020        62179.8 51806.66 72552.93 46315.46 78044.14
2021        62179.8 49448.76 74910.83 42709.36 81650.24
2022        62179.8 47448.33 76911.26 39649.96 84709.63
2023        62179.8 45674.75 78684.84 36937.51 87422.08</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(librosEtsPre,</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Títulos&quot;</span>,</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 11. Libros y predicción a 5 años vista&quot;</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-30-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="análisis-del-error" class="section level2" number="6.3">
<h2 number="6.3"><span class="header-section-number">6.3</span> Análisis del error</h2>
<p>El error de un modelo de alisado <em>contiene</em> la componente de <strong>Intervención</strong> y el propio término de <strong>Error</strong>. Ver numérica o gráficamente el error permite identificar fácilmente la presencia de valores atípicos (intervención).</p>
<p>El modelo de alisado tiene error multiplicativo así que debemos usar el argumento <code>type = "response"</code> para obtener el error aditivo con <code>residuals</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>error <span class="ot">&lt;-</span> <span class="fu">residuals</span>(librosEts, <span class="at">type =</span> <span class="st">&quot;response&quot;</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>sderror <span class="ot">&lt;-</span> <span class="fu">sd</span>(error)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(error, <span class="at">series=</span><span class="st">&quot;Error&quot;</span>,</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">colour =</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;Periodo&quot;</span>,</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Error&quot;</span>,</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 12: Error + Intervención&quot;</span>) <span class="sc">+</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">3</span>, <span class="sc">-</span><span class="dv">2</span>, <span class="dv">2</span> ,<span class="dv">3</span>)<span class="sc">*</span>sderror, </span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>             <span class="at">colour =</span> <span class="fu">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>), <span class="at">lty =</span> <span class="dv">2</span>) <span class="sc">+</span> </span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks=</span> <span class="fu">seq</span>(<span class="dv">1993</span>, <span class="dv">2019</span>, <span class="dv">2</span>)) </span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-31-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>La figura 12 muestra que aunque algún error supera las dos desviaciones típicas, ninguno puede ser considerado como claramente atípico.</p>
</div>
<div id="validación-error-extra-muestral" class="section level2" number="6.4">
<h2 number="6.4"><span class="header-section-number">6.4</span> Validación: error extra-muestral</h2>
<p>Vamos a mejorar la estimación de la calidad de las predicciones obteniendo el MAPE para <strong>previsiones extra-muestrales a varios periodos vista</strong>. Para ello vamos a reservar, por ejemplo, las últimas 6 observaciones de la serie Libros y ajustar el modelo con las restantes. Después usaremos este modelo para calcular las predicciones a 6 periodos vista y compararlas con los valores reales de la serie Libros.</p>
<p>Recordemos que los resultados dependen tremendamente del punto de corte temporal seleccionado.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Definimos las observaciones intra- y extra-muestrales</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>librosIntra <span class="ot">&lt;-</span> <span class="fu">subset</span>(libros, <span class="at">end =</span> <span class="fu">length</span>(libros) <span class="sc">-</span> <span class="dv">6</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>librosExtra <span class="ot">&lt;-</span> <span class="fu">subset</span>(libros, <span class="at">start =</span> <span class="fu">length</span>(libros) <span class="sc">-</span> <span class="dv">5</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimamos el modelo con todos los datos menos los 6 ultimos</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>librosIntraEts <span class="ot">&lt;-</span> <span class="fu">ets</span>(librosIntra, <span class="at">model =</span> <span class="st">&quot;MNN&quot;</span>)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Predecimos los 7 años que hemos quitado de la serie y </span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="co"># vemos la calidad del ajuste.</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>librosExtraPre <span class="ot">&lt;-</span> <span class="fu">forecast</span>(librosIntraEts, <span class="at">h =</span> <span class="dv">6</span>)</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(librosExtraPre, librosExtra)</span></code></pre></div>
<pre><code>                     ME     RMSE       MAE        MPE      MAPE      MASE
Training set   1462.163  5905.05  4665.937   2.339602  7.216588 0.9533584
Test set     -10434.291 10678.54 10434.291 -17.790750 17.790750 2.1319661
                   ACF1 Theil&#39;s U
Training set -0.1925569        NA
Test set      0.2260149  3.937573</code></pre>
<p>Atendiendo al MAPE se tiene que el error de <strong>previsión a un periodo vista</strong> en el <strong>periodo intra-muestral</strong> de <strong>1993 a 2012</strong> es del 7.2%; mientras que el error de <strong>previsión a largo plazo</strong> en el <strong>periodo extra-muestral</strong> de <strong>2013 a 2018</strong> es del 17.8%. Ademas, para el periodo extra-muestral el error medio (ME) es negativo y muy elevado, un indicativo de que las previsiones están segadas. En resumen, la calidad del modelo se deteriora muy rápidamente en cuanto nos salimos de las condiciones óptimas.</p>
<p>Un gráfico puede ayudar a entender este proceso de validación. En la figura 13:</p>
<ul>
<li>La línea de puntos vertical separa el periodo muestral (1993-2012) usado para estimar el modelo, del periodo extra-muestral (2013-2018) usado sólo para hacer las previsiones.</li>
<li>La serie Libros aparece como una línea sólida en negro, desde 1993 hasta 2018.</li>
<li>La previsión <em>intra</em>-muestral (a un periodo vista) de la serie Libros aparece como una línea azul.</li>
<li>La línea en rojo es la previsión <em>extra</em>-muestral a largo plazo: <span class="math inline">\(\hat{y}_{T+h}=l_T\)</span>, donde <span class="math inline">\(T=2012\)</span>. Observa que todas las previsiones están por encima del valor real de la serie.</li>
<li>Al lado de cada previsión se ha indicado el error estimado (MAPE).</li>
</ul>
<p>Claramente estos resultados dependen del punto de corte seleccionado.</p>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-34-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
<br />
</p>
<p><strong>Nota:</strong> La presencia de tendencia, primero creciente y luego decreciente, en la serie Libros puede hacernos pensar que un modelo más adecuado para su ajuste y predicción sería ETS(M,A,N), forzando a que haya pendiente. De hecho, el error de estimación de este modelo es del 6.2%, frente al 7% para el modelo ETS(M,N,N). Sin embargo, el error de previsión extra-muestral a largo plazo para el modelo ETS(M,A,N) es del 31.5%, frente al 17.8% para el modelo ETS(M,N,N). De nuevo, incidir en que mayor calidad de ajuste no implica mayor calidad de predicción; y en que estos resultados dependen del punto de corte seleccionado.</p>
</div>
</div>
<div id="ejemplo-de-aplicación-nacimientos" class="section level1" number="7">
<h1 number="7"><span class="header-section-number">7</span> Ejemplo de aplicación: Nacimientos</h1>
<p>Veamos un segundo ejemplo con la serie Nacimientos (desde el año 2000).</p>
<div id="identificación-y-estimación-del-mejor-modelo-1" class="section level2" number="7.1">
<h2 number="7.1"><span class="header-section-number">7.1</span> Identificación y estimación del mejor modelo</h2>
<p>Si damos total libertad al proceso de selección del mejor modelo, el óptimo tiene tendencia amortiguada con un parámetro <span class="math inline">\(\phi = 0.98\)</span>, su máximo valor permitido. Este resultado aconseja repetir el proceso de selección del modelo restringido a aquellos sin amortiguamiento.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>nacimientosEts <span class="ot">&lt;-</span> <span class="fu">ets</span>(nacimientosb, <span class="at">damped =</span> <span class="cn">FALSE</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(nacimientosEts) </span></code></pre></div>
<pre><code>ETS(M,A,A) 

Call:
 ets(y = nacimientosb, damped = FALSE) 

  Smoothing parameters:
    alpha = 0.453 
    beta  = 0.0129 
    gamma = 0.0001 

  Initial states:
    l = 33060.0131 
    b = 133.8359 
    s = 186.0139 -23.5386 1964.614 1476.782 838.1165 1139.429
           -1049.547 364.3884 -1322.119 -197.631 -3356.247 -20.2609

  sigma:  0.0226

     AIC     AICc      BIC 
4323.210 4326.124 4381.509 

Training set error measures:
                   ME     RMSE      MAE        MPE     MAPE      MASE
Training set -78.9317 819.2494 647.6997 -0.2429001 1.751808 0.4613018
                    ACF1
Training set -0.01764952</code></pre>
<p>El modelo estimado es ETS(M,A,A), es decir, <span class="math inline">\(y_{t+1} = (l_t + b_t + s_{t+1-m}) \cdot (1+ \varepsilon_{t+1})\)</span>.</p>
<p>El bajo valor de <span class="math inline">\(\beta\)</span> y <span class="math inline">\(\gamma\)</span> indican que ambas, la pendiente y la estacionalidad, varían muy lentamente en el tiempo (véase la figura 14).</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(nacimientosEts,</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;Periodo&quot;</span>,</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 14. Componentes del modelo óptimo para Nacimientos&quot;</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-36-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Respecto de la calidad del modelo, el MAPE de 1.8% indica que estamos ante un modelo que se ajusta muy bien a los datos; y el valor de MASE igual a 0.46 indica que este modelo reduce en un 54% el error del método ingenuo con estacionalidad, el más sencillo posible, que ya utilizamos en el epígrafe 3 (aunque para la serie nacimientos completa).</p>
<p>Podemos ver los últimos valores estimados del nivel, la pendiente y la estacionalidad para interpretarlos.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>TT <span class="ot">&lt;-</span> <span class="fu">nrow</span>(nacimientosEts<span class="sc">$</span>states)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>nacimientosEts<span class="sc">$</span>states[TT,]</span></code></pre></div>
<pre><code>       l        b       s1       s2       s3       s4       s5 
30579.27   -97.62   185.84   -23.71  1964.49  1476.46   838.07 </code></pre>
<pre><code>      s6       s7       s8       s9      s10      s11      s12 
 1139.30 -1049.77   364.26 -1322.26  -197.71 -3356.56   -20.23 </code></pre>
<p>También podemos usarlos para predecir un año:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>nacimientosEts<span class="sc">$</span>states[TT, <span class="dv">1</span>] <span class="sc">+</span> (<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>) <span class="sc">*</span> nacimientosEts<span class="sc">$</span>states[TT, <span class="dv">2</span>] <span class="sc">+</span> </span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  nacimientosEts<span class="sc">$</span>states[TT, <span class="dv">14</span><span class="sc">:</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>     s12      s11      s10       s9       s8       s7       s6       s5 
30461.42 27027.46 30088.70 28866.53 30455.42 28943.77 31035.22 30636.37 
      s4       s3       s2       s1 
31177.13 31567.54 29481.72 29593.65 </code></pre>
<p>Febrero es el mes con menor número de nacimientos: nacen 3356 bebés menos, respecto de la media anual. En octubre es cuando más niños nacen: 1964 más que la media anual.</p>
<p>Nuestra predicción para enero de 2019 es de 30461 bebés y para diciembre de 2019 de 29593 bebés.</p>
</div>
<div id="predicción-1" class="section level2" number="7.2">
<h2 number="7.2"><span class="header-section-number">7.2</span> Predicción</h2>
<p>Si pedimos los valores de predicción tenemos (sólo se muestran los primeros meses):</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>nacimientosEtsPre <span class="ot">&lt;-</span> <span class="fu">forecast</span>(nacimientosEts, <span class="at">h =</span> <span class="dv">24</span>, <span class="at">level =</span> <span class="dv">95</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>nacimientosEtsPre</span></code></pre></div>
<pre><code>         Point Forecast    Lo 95    Hi 95
Jan 2019       30461.42 29110.45 31812.39
Feb 2019       27027.46 25673.56 28381.37
Mar 2019       30088.70 28504.04 31673.36
Apr 2019       28866.53 27194.30 30538.76
May 2019       30455.42 28611.33 32299.52</code></pre>
<p>Gráficamente,</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(nacimientosEtsPre,</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Bebés&quot;</span>,</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 15. Nacimientos y predicción&quot;</span>)</span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-43-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="análisis-del-error-1" class="section level2" number="7.3">
<h2 number="7.3"><span class="header-section-number">7.3</span> Análisis del error</h2>
<p>El modelo de alisado tiene error multiplicativo así que debemos usar el argumento <code>type = "response"</code> para obtener el error aditivo con <code>residuals</code>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>error <span class="ot">&lt;-</span> <span class="fu">residuals</span>(nacimientosEts, <span class="at">type =</span> <span class="st">&quot;response&quot;</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>sderror <span class="ot">&lt;-</span> <span class="fu">sd</span>(error)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(error, <span class="at">series=</span><span class="st">&quot;Error&quot;</span>,</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">colour =</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlab =</span> <span class="st">&quot;Periodo&quot;</span>,</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>         <span class="at">ylab =</span> <span class="st">&quot;Error&quot;</span>,</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>         <span class="at">main =</span> <span class="st">&quot;Figura 16: Error + Intervención&quot;</span>) <span class="sc">+</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">3</span>, <span class="sc">-</span><span class="dv">2</span>, <span class="dv">2</span> ,<span class="dv">3</span>)<span class="sc">*</span>sderror, </span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>             <span class="at">colour =</span> <span class="fu">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>), <span class="at">lty =</span> <span class="dv">2</span>) <span class="sc">+</span> </span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks=</span> <span class="fu">seq</span>(<span class="dv">2000</span>, <span class="dv">2019</span>, <span class="dv">2</span>)) </span></code></pre></div>
<p><img src="03-02-Tema2_files/figure-html/unnamed-chunk-44-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Se identifica un valor claramente atípico –supera las 4 desviaciones típicas– que corresponde a enero de 2011. Abril de 2008 es otro candidato a intervención por alcanzar las 3 desviaciones típicas.</p>
</div>
<div id="validación-error-extra-muestral-1" class="section level2" number="7.4">
<h2 number="7.4"><span class="header-section-number">7.4</span> Validación: error extra-muestral</h2>
<p>En este caso vamos a aplicar la metodología <strong>origen de predicción móvil</strong> (<em>rolling forecast origin</em>) o <em>rolling windows</em>. Asumimos que se precisan diez años para hacer una buena estimación, <span class="math inline">\(k=120\)</span>, y que el horizonte temporal es de 12 meses, <span class="math inline">\(h = 12\)</span>. La siguiente rutina permite obtener el MAPE para previsiones con un horizonte temporal desde uno a doce meses.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">120</span>                  <span class="co">#Minimo numero de datos para estimar</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>h <span class="ot">&lt;-</span> <span class="dv">12</span>                   <span class="co">#Horizonte de las prediciciones</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>TT <span class="ot">&lt;-</span> <span class="fu">length</span>(nacimientosb)    <span class="co">#Longitud serie</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>s <span class="ot">&lt;-</span> TT <span class="sc">-</span> k <span class="sc">-</span> h           <span class="co">#Total de estimaciones</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>mapeEts <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, s <span class="sc">+</span> <span class="dv">1</span>, h)</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">0</span><span class="sc">:</span>s) {</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  train.set <span class="ot">&lt;-</span> <span class="fu">subset</span>(nacimientosb, <span class="at">start =</span> i <span class="sc">+</span> <span class="dv">1</span>, <span class="at">end =</span> i <span class="sc">+</span> k)</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  test.set <span class="ot">&lt;-</span>  <span class="fu">subset</span>(nacimientosb, <span class="at">start =</span> i <span class="sc">+</span> k <span class="sc">+</span> <span class="dv">1</span>, <span class="at">end =</span> i <span class="sc">+</span> k <span class="sc">+</span> h)</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  fit <span class="ot">&lt;-</span> <span class="fu">ets</span>(train.set,  <span class="at">model =</span> <span class="st">&quot;MAA&quot;</span>, <span class="at">damped =</span> <span class="cn">FALSE</span>)</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>  fcast <span class="ot">&lt;-</span> <span class="fu">forecast</span>(fit, <span class="at">h =</span> h)</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  mapeEts[i <span class="sc">+</span> <span class="dv">1</span>,] <span class="ot">&lt;-</span> <span class="dv">100</span><span class="sc">*</span><span class="fu">abs</span>(test.set <span class="sc">-</span> fcast<span class="sc">$</span>mean)<span class="sc">/</span>test.set</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>mapeEts <span class="ot">&lt;-</span> <span class="fu">colMeans</span>(mapeEts)</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(mapeEts, <span class="dv">2</span>)</span></code></pre></div>
<pre><code> [1] 1.92 2.16 2.29 2.67 2.70 2.74 2.88 2.91 3.03 3.16 3.22 3.50</code></pre>
<p>El error extra-muestral a un periodo vista es comparable al error intra-muestral (1.9% frente a 1.8%). Aunque el error de previsión aumenta conforme lo hace el horizonte temporal, siempre se mantiene muy bajo. Por ejemplo, en las previsiones a 12 meses vista el error es del 3.5%.</p>
<p><br />
</p>
</div>
<div id="otras-alternativas-para-predecir-nacimientos" class="section level2" number="7.5">
<h2 number="7.5"><span class="header-section-number">7.5</span> Otras alternativas para predecir Nacimientos</h2>
<p>A la hora de predecir hay que ser un poco imaginativos, dedicarle tiempo y probar cosas. Por ejemplo, podríamos predecir los nacimientos a partir del ajuste de la transformación logarítmica. O podemos probar a cambiar el criterio de estimación de los parámetros o el de selección del modelo óptimo.</p>
<p>Yendo un poco más lejos, y dado que el número de nacimientos depende forzosamente del número de días del mes, podemos predecir los nacimientos medios por día (cociente entre los nacimientos de cada mes y el número de días del mes). Esta serie tendrá una componente estacional más suave, elimina el efecto de los febreros bisiestos y tendrá, previsiblemente un mejor ajuste.</p>
<p>También podemos mezclar varios de los enfoques previos o ser aún más imaginativos.</p>
<p>El siguiente código muestra el MAPE (para previsiones intra-muestrales a un periodo vista) para varias de estas opciones. Puedes deducir que se está haciendo en cada caso a partir del código. Sería más adecuado usar otro criterio de validación diferente, pero el objetivo de este epígrafe es recalcar que no hay que quedarse con lo inmediato (predecir Nacimientos con las opciones por defecto de las funciones), sino probar y probar.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Serie Nacimientos</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb, </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.751808</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb, </span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>, </span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">opt.crit =</span> <span class="st">&quot;mse&quot;</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.757418</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformación logarítmica</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb, </span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">lambda =</span> <span class="dv">0</span>, </span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.773713</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb, </span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">lambda =</span> <span class="dv">0</span>, </span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>, </span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">opt.crit =</span> <span class="st">&quot;mse&quot;</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.773713</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformación logarítmica insesgada</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb, </span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">lambda =</span> <span class="dv">0</span>, </span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">biasadj =</span> <span class="cn">TRUE</span>,</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.773718</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb, </span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">lambda =</span> <span class="dv">0</span>, </span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">biasadj =</span> <span class="cn">TRUE</span>,</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>, </span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>             <span class="at">opt.crit =</span> <span class="st">&quot;mse&quot;</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.773718</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Nacimientos por dia</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb<span class="sc">/</span><span class="fu">monthdays</span>(nacimientosb), </span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.677256</code></pre>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">accuracy</span>(<span class="fu">ets</span>(nacimientosb<span class="sc">/</span><span class="fu">monthdays</span>(nacimientosb), </span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">damped =</span> <span class="cn">FALSE</span>, </span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">opt.crit =</span> <span class="st">&quot;mse&quot;</span>))[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>[1] 1.671269</code></pre>
<p>La principal conclusión en este caso es que salirse de la estimación directa sobre la serie original no reduce el error significativamente. Sin embargo, cabe destacar que,</p>
<ul>
<li>El error de estimación de los nacimientos por día es menor, al tratarse de una serie con mejor comportamiento, aunque la ganancia no es mucha. (Véanse los dos últimos modelos respecto de los dos primeros)</li>
<li>Usar la transformación logarítmica (con o sin predicciones insesgadas) no mejora la capacidad predictiva del modelo. (Véanse los modelos 3 a 6 respecto de los modelos 1 y 2)</li>
<li>El mejor modelo estima los nacimientos por día y estima los parámetros minimizando el error cuadrático medio (“mse”). Todo menos lo <em>directo</em>.</li>
</ul>
<p><br />
<br />
</p>
</div>
</div>
<div id="resumen-de-los-comandos-utilizados" class="section level1" number="8">
<h1 number="8"><span class="header-section-number">8</span> Resumen de los comandos utilizados</h1>
<table>
<colgroup>
<col width="18%" />
<col width="14%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Función</th>
<th align="left">Paquete</th>
<th align="left">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>meanf</code></td>
<td align="left">forecast</td>
<td align="left">Predicción por media</td>
</tr>
<tr class="even">
<td align="left"><code>naive</code></td>
<td align="left">forecast</td>
<td align="left">Predicción por método ingenuo I</td>
</tr>
<tr class="odd">
<td align="left"><code>rwf</code></td>
<td align="left">forecast</td>
<td align="left">Predicción con tendencia media</td>
</tr>
<tr class="even">
<td align="left"><code>snaive</code></td>
<td align="left">forecast</td>
<td align="left">Predicción por método ingenuo con estacionalidad</td>
</tr>
<tr class="odd">
<td align="left"><code>accuracy</code></td>
<td align="left">forecast</td>
<td align="left">Calculo de la precisión del modelo</td>
</tr>
<tr class="even">
<td align="left"><code>forecast</code></td>
<td align="left">forecast</td>
<td align="left">Predice valores extra-muestrales futuros de la serie</td>
</tr>
<tr class="odd">
<td align="left"><code>ses</code></td>
<td align="left">forecast</td>
<td align="left">Estimación del modelo de alisado exponencial simple</td>
</tr>
<tr class="even">
<td align="left"><code>holt</code></td>
<td align="left">forecast</td>
<td align="left">Estimación del modelo de alisado exponencial de Holt</td>
</tr>
<tr class="odd">
<td align="left"><code>hw</code></td>
<td align="left">forecast</td>
<td align="left">Estimación del modelo de alisado exponencial de Holt-Winters</td>
</tr>
<tr class="even">
<td align="left"><code>ets</code></td>
<td align="left">forecast</td>
<td align="left">Estimación de una amplia familia de métodos de alisado exponencial</td>
</tr>
<tr class="odd">
<td align="left"><code>residuals</code></td>
<td align="left">stats</td>
<td align="left">Obtiene el residuo de un modelo estimado</td>
</tr>
<tr class="even">
<td align="left"><code>fitted</code></td>
<td align="left">stats</td>
<td align="left">Obtiene las predicciones a un periodo vista intra-muestrales</td>
</tr>
</tbody>
</table>
<p><br />
<br />
</p>
</div>
<div id="referencias" class="section level1" number="9">
<h1 number="9"><span class="header-section-number">9</span> Referencias</h1>
<ul>
<li><p>Brown, R. G. (1959). <em>Statistical forecasting for inventory control</em>. Ed. McGraw/Hill.</p></li>
<li><p>Gardner, Jr, E. S. y McKenzie, E. (1985) <em>Forecasting trends in time series</em>, Management Science, 31(10), pp. 1237–1246. <a href="doi:10.1287/mnsc.31.10.1237" class="uri">doi:10.1287/mnsc.31.10.1237</a></p></li>
<li><p>Holt, C. E. (1957). <em>Forecasting seasonals and trends by exponentially weighted averages</em> O.N.R. Memorandum No. 52. Carnegie Institute of Technology, Pittsburgh USA. <a href="doi:10.1016/j.ijforecast.2003.09.015" class="uri">doi:10.1016/j.ijforecast.2003.09.015</a></p></li>
<li><p>Hyndman, R. J. y Khandakar, Y. (2008) <em>Automatic Time Series Forecasting: The forecast Package for R</em>. Journal of Statistical Software, 27(3), pp. 1-22. <a href="doi:10.18637/jss.v027.i03" class="uri">doi:10.18637/jss.v027.i03</a></p></li>
<li><p>Hyndman, R. J., Koehler, A., B., Ord, J. K. y Snyder, R. D. (2008) <em>Forecasting with Exponential Smoothing: the State Space Approach</em>. Ed. Springer.</p></li>
<li><p>Makridakis, S. y Hibon, M. (2000). <em>The M3-Competition: results, conclusions and implications</em>. International Journal of Forecasting, 16(4), pp. 451–476. <a href="doi:10.1016/S0169-2070(00)00057-1" class="uri">doi:10.1016/S0169-2070(00)00057-1</a></p></li>
<li><p>Winters, P. R. (1960). <em>Forecasting sales by exponentially weighted moving averages</em>. Management Science, 6, pp. 324–342. <a href="doi:10.1287/mnsc.6.3.324" class="uri">doi:10.1287/mnsc.6.3.324</a></p></li>
</ul>
<p><br />
<br />
<br />
<br />
</p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiU2VyaWVzIFRlbXBvcmFsZXM6IEFsaXNhZG8gRXhwb25lbmNpYWwiCnN1YnRpdGxlOiAiTcOhc3RlciBkZSBCaW9lc3RhZMOtc3RpY2EgKE1vZGVsaXphY2nDs24gRXN0YWTDrXN0aWNhKSIKYXV0aG9yOiAiSXbDoW4gQXJyaWJhcyAoRGVwdG8uIEFuw6FsaXNpcyBFY29uw7NtaWNvLiBVbml2ZXJzaXRhdCBkZSBWYWzDqG5jaWEpIgpvdXRwdXQ6IAogIGh0bWxfZG9jdW1lbnQ6CiAgICB0aGVtZTogY2VydWxlYW4KICAgIGhpZ2hsaWdodDogcHlnbWVudHMgCiAgICBmaWdfY2FwdGlvbjogZmFsc2UKICAgIGRmX3ByaW50OiBrYWJsZQogICAgdG9jOiB0cnVlCiAgICB0b2NfZGVwdGg6IDIKICAgIHRvY19mbG9hdDogCiAgICAgIGNvbGxhcHNlZDogdHJ1ZQogICAgbnVtYmVyX3NlY3Rpb25zOiB0cnVlCiAgICBzZWxmX2NvbnRhaW5lZDogdHJ1ZQogICAgY29kZV9kb3dubG9hZDogdHJ1ZQotLS0KCmBgYHtyIGNodW5rX3NldHVwLCBlY2hvID0gRkFMU0V9CmtuaXRyOjpvcHRzX2NodW5rJHNldCh3YXJuaW5nID0gRkFMU0UsIAogICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IEZBTFNFLCAKICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAiIiwKICAgICAgICAgICAgICAgICAgICAgIGZpZy5hbGlnbiA9ICJjZW50ZXIiLCAKICAgICAgICAgICAgICAgICAgICAgIGZpZy5zaG93ID0gImhvbGQiLAogICAgICAgICAgICAgICAgICAgICAgZmlnLmhlaWdodCA9IDQsCiAgICAgICAgICAgICAgICAgICAgICBmaWcud2lkdGggPSA4LAogICAgICAgICAgICAgICAgICAgICAgb3V0LndpZHRoID0gIjgwJSIpIApgYGAKCmBgYHtyIG9wdGlvbnNfc2V0dXAsIGVjaG8gPSBGQUxTRX0Kb3B0aW9ucyhzY2lwZW4gPSA5OTkpICMtIHBhcmEgcXVpdGFyIGxhIG5vdGFjaW9uIGNpZW50aWZpY2EKYGBgCgpgYGB7ciBsaWJyZXJpYXMsIGVjaG8gPSBGQUxTRX0KbGlicmFyeShmb3JlY2FzdCkKbGlicmFyeShnZ3Bsb3QyKTsgdGhlbWVfc2V0KHRoZW1lX2J3KCkpCmxpYnJhcnkoZ3JpZEV4dHJhKQpsaWJyYXJ5KGdyaWQpCmBgYAoKIyBJbnRyb2R1Y2Npw7NuCgpFbiBtdWNob3MgY2Fzb3MgZXMgcHJlY2lzbyBhcGxpY2FyIHVuIG3DqXRvZG8gZGUgcHJlZGljY2nDs24gcsOhcGlkbyB5IHNlbmNpbGxvOgoKKiBBIGNhdXNhIGRlbCBlbGV2YWRvIG7Dum1lcm8gZGUgc2VyaWVzIHF1ZSB0aWVuZW4gcXVlIHNlciBhbmFsaXphZGFzLgoqIERlYmlkbyBhIGxhIHJhcGlkZXogY29uIHF1ZSBsYXMgcHJlZGljY2lvbmVzIHNlIGhhbiBkZSBkYXIuCiAgICAgIApBY3R1YWxtZW50ZSBleGlzdGVuIG11Y2hvcyBtw6l0b2RvcyBzZW5jaWxsb3MgZGUgcHJlZGljY2nDs24sIGVudHJlIGxvIHF1ZSBjYWJlIGRlc3RhY2FyIGRvczoKCiogX19Nw6l0b2RvcyBkZSBtZWRpYSBtw7N2aWxfXyAobm8gbG9zIHZlcmVtb3MgZW4gZXN0ZSBjdXJzbyBwZXJvIHB1ZWRlcyBhcHJlbmRlciBzb2JyZSBlbGxvcyBbYXF1aV0oaHR0cDovL3VjLXIuZ2l0aHViLmlvL3RzX21vdmluZ19hdmVyYWdlcykgeSBbYXF1aV0oaHR0cHM6Ly9jcmFuLnItcHJvamVjdC5vcmcvd2ViL3BhY2thZ2VzL3Ntb290aC92aWduZXR0ZXMvc21hLmh0bWwpKS4KKiBfX03DqXRvZG9zIGRlIGFsaXNhZG8gZXhwb25lbmNpYWxfXy4KICAgIApFc3RhcyB0w6ljbmljYXMsIGEgcGVzYXIgZGUgc3Ugc2VuY2lsbGV6LCBzb24gYmFzdGFudGUgYWRlY3VhZGFzIGN1YW5kbyBsYSBwcmV2aXNpw7NuIGVzIGEgY29ydG8gcGxhem86Cgo+IlN0YXRpc3RpY2FsbHkgc29waGlzdGljYXRlZCBvciBjb21wbGV4IG1ldGhvZHMgZG8gbm90IG5lY2Vzc2FyaWx5IHByb2R1Y2UgbW9yZSBhY2N1cmF0ZSBmb3JlY2FzdHMgdGhhbiBzaW1wbGVyIG9uZXMuIiBNYWtyaWRha2lzIHkgSGlib24gKDIwMDApLgogICAgICAKVmVyZW1vcyBlbiBkZXRhbGxlIGxvcyBtw6l0b2RvcyBkZSBhbGlzYWRvIGV4cG9uZW5jaWFsIHBvciBzZXIgbXV5IHZlcnPDoXRpbGVzLCBwdWRpw6luZG9zZSBhcGxpY2FyIGEgY3VhbHF1aWVyIHNlcmllLCBpbmRlcGVuZGllbnRlbWVudGUgZGUgc3VzIGNvbXBvbmVudGVzLCB5IGhhYmVyIGRlbW9zdHJhZG8gdW5hIGdyYW4gY2FwYWNpZGFkIGRlIGFqdXN0ZSB5IGNhbGlkYWQgZGUgcHJlZGljY2nDs24uIEVuIGVsbG9zIHNlIGhhY2UgdXNvIGRlIGRhdG9zIHBhc2Fkb3MgcGFyYSBvYnRlbmVyIHVuYSBudWV2YSBzZXJpZSBtw6FzIF9zdWF2ZV8gbyBhbGlzYWRhLCBhIHBhcnRpciBkZSBsYSBjdWFsIHNlIHJlYWxpemFyw6FuIGxhcyBwcmVkaWNjaW9uZXMuIEV4aXN0ZSB1biBhbXBsaW8gbWVuw7ogZGUgbcOpdG9kb3MgZGUgYWxpc2FkbyBhbHRlcm5hdGl2b3MgeSBsYSBlbGVjY2nDs24gZGVsIG3DoXMgYWRlY3VhZG8gZGVwZW5kZXLDoSBkZSBsYXMgY29tcG9uZW50ZXMgcXVlIHByZXNlbnRhIGxhIHNlcmllIHkgZGVsIHRpcG8gZGUgZXNxdWVtYS4KClwKXAoKIyBDcml0ZXJpb3MgZGUgY2FsaWRhZAoKRW4gZXN0ZSB0ZW1hIHkgZW4gbG9zIHNpZ3VpZW50ZXMgc2UgdmVyw6FuIGRpZmVyZW50ZXMgbcOpdG9kb3MgcGFyYSBwcmVkZWNpciB1bmEgc2VyaWUgdGVtcG9yYWwuIEFzw60sIGVzIHByZWNpc28gZGVmaW5pciBjcml0ZXJpb3MgZGUgYm9uZGFkIGRlIGFqdXN0ZSBxdWUgcGVybWl0YW4gZXN0aW1hciB0YW50byBsYSBjYWxpZGFkIGRlbCBhanVzdGUgY29tbyBkZSBsYXMgcHJlZGljY2lvbmVzIGRlIHVuIG3DqXRvZG8uCgo+ICJUaGUgcmFua2luZ3Mgb2YgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSB2YXJpb3VzIG1ldGhvZHMgdmFyeSBhY2NvcmRpbmcgdG8gdGhlIGFjY3VyYWN5IG1lYXN1cmUgYmVpbmcgdXNlZC4iICBNYWtyaWRha2lzIHkgSGlib24gKDIwMDApLgogICAgIApcCgojIyBOb3RhY2nDs24geSBkZWZpbmljaW9uZXMKCgogCkRhZGEgdW5hIHNlcmllIHRlbXBvcmFsICRce3lfdFx9X3t0PTF9XlQkLCBzZSBkZWZpbmU6CgoqIF9fUHJldmlzacOzbiAkaCQgcGVyaW9kb3MgYWRlbGFudGVfXywgY29tbyBsYSBwcmV2aXNpw7NuIGRlIGxhIHNlcmllIHBhcmEgZWwgcGVyaW9kbyAkdCtoJCBkaXNwb25pZW5kbyBkZSBpbmZvcm1hY2nDs24gaGFzdGEgZWwgcGVyaW9kbyAkdCQsIHkgc2UgZGVub3RhIHBvciAkXGhhdHt5fV97dCtofHR9JC4gUG9yIHNpbXBsaWNpZGFkIGxvIGVzY3JpYmlyZW1vcyB0YW1iacOpbiBjb21vICRcaGF0e3l9X3t0K2h9JC4KClx2c3BhY2V7MC4zY219CgoqIEFzw60sICRcaGF0e3l9X3t0KzF8dH0kIGVzIGxhIF9fcHJldmlzacOzbiB1biBwZXJpb2RvIGFkZWxhbnRlX18gbyBhIHVuIHBlcmlvZG8gdmlzdGEuIEVzIGRlY2lyLCBsYSBwcmV2aXNpw7NuIGRlIGxhIHNlcmllIGVuICR0KzEkIGRlc2RlIGVsIHBlcmlvZG8gJHQkLgoKXHZzcGFjZXswLjNjbX0KCiogRGUgbnVldm8sIHBvciBzaW1wbGljaWRhZCBkZW5vdGFyZW1vcyBhICRcaGF0e3l9X3t0KzF8dH0kIGNvbW8gJFxoYXR7eX1fe3QrMX0kOyB5IGNvbW8gJFxoYXR7eX1fe3R9JCBhIGxhIHByZXZpc2nDs24gZW4gJHQkLCBjb24gZGF0b3MgaGFzdGEgZWwgcGVyaW9kbyAkdC0xJCAoJFxoYXR7eX1fe3R9ID0gXGhhdHt5fV97dHx0LTF9JCkuCgpTZSBkZWZpbmUgY29tbyBfX2Vycm9yIGRlIHByZXZpc2nDs25fXyBhIHVuIHBlcmlvZG8gdmlzdGEgYSAKJCRcaGF0e2V9X3Q9eV90LVxoYXR7eX1fdCwkJApkZSBmb3JtYSBxdWUgbGEgc2VyaWUgJFx7XGhhdHtlfV90XH1fe3Q9MX1eVCQgbm9zIHBlcm1pdGlyw6EgZGVmaW5pciB2YXJpb3MgY3JpdGVyaW9zIGRlIGNhbGlkYWQgZGUgYWp1c3RlLiAKICAKXAoKIyMgTWVkaWRhcyBkZSBwcmVjaXNpw7NuIGRlIGxhIHByZWRpY2Npw7NuCiAKRGFkYSB1bmEgc2VyaWUgJFx7eV90XH1fe3Q9MX1eVCQsIHVuIG3DqXRvZG8gZGUgcHJlZGljY2nDs24geSBzdSB2ZWN0b3IgZGUgZXJyb3JlcyBhc29jaWFkbyAkXHtcaGF0e2V9X3RcfV97dD0xfV5UJCwgcG9kZW1vcyBkZWZpbmlyIG3Dumx0aXBsZXMgbWVkaWRhcyBkZSBjYWxpZGFkIGRlbCBtw6l0b2RvIGRlIHByZWRpY2Npw7NuIHF1ZSBoYWNlbiByZWZlcmVuY2lhIGEgbGEgcHJlc2VuY2lhIGRlIHNlc2dvIGVuIGxhcyBwcmVkaWNjaW9uZXMsIGxhIG1hZ25pdHVkIGRlbCBlcnJvciBjb21ldGlkbyB5IGxhIGNhbGlkYWQgZGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgbGFzIHByZWRpY2Npb25lcy4gTGFzIG3DoXMgaGFiaXR1YWxlcyBzb24gKHNpZ2xhcyBlbiBpbmdsw6lzKToKCiogRXJyb3IgbWVkaW8gKE1FKTogJFxmcmFjezF9e1R9XHN1bV97dD0xfV5UIFxoYXR7ZX1fdCQKClx2c3BhY2V7MC4zY219CgoqIF9fUmHDrXogZGVsIGVycm9yIGN1YWRyw6F0aWNvIG1lZGlvIChSTVNFKV9fOiAkXHNxcnR7XGZyYWN7MX17VH1cc3VtX3t0PTF9XlQgXGhhdHtlfV4yX3R9JAoKXHZzcGFjZXswLjNjbX0KCiogRXJyb3IgYWJzb2x1dG8gbWVkaW8gKE1BRSk6ICRcZnJhY3sxfXtUfVxzdW1fe3Q9MX1eVCB8XGhhdHtlfV90fCQKClx2c3BhY2V7MC4zY219CgoqIEVycm9yIHBvcmNlbnR1YWwgbWVkaW8gKE1QRSk6ICRcZnJhY3sxMDB9e1R9XHN1bV97dD0xfV5UIFxmcmFje1xoYXR7ZX1fdH17eV90fSQKClx2c3BhY2V7MC4zY219CgoqIF9fRXJyb3IgcG9yY2VudHVhbCBhYnNvbHV0byBtZWRpbyAoTUFQRSlfXzogJFxmcmFjezEwMH17VH1cc3VtX3t0PTF9XlQgXGJpZ3xcZnJhY3tcaGF0e2V9X3R9e3lfdH1cYmlnfCQKClx2c3BhY2V7MC4zY219CgoqIEVycm9yIHBvcmNlbnR1YWwgYWJzb2x1dG8gbWVkaW8gc2ltw6l0cmljbyAoc01BUEUpOiAkXGZyYWN7MjAwfXtUfVxzdW1fe3Q9MX1eVCBcQmlnfFxmcmFje1xoYXR7ZX1fdH17eV90ICsgXGhhdHt5fV90fVxCaWd8JAoKXHZzcGFjZXswLjNjbX0KCiogRXJyb3IgZXNjYWxhZG8gYWJzb2x1dG8gbWVkaW8gKE1BU0UpOiAkXGJpZyhcZnJhY3sxfXtUfVxzdW1fe3Q9MX1eVCB8XGhhdHtlfV90fFxiaWcpL3EkLCBkb25kZSAkcSQgZXMgZWwgZXJyb3IgYWJzb2x1dG8gbWVkaW8gcGFyYSB1biBtw6l0b2RvIGluZ2VudW8gZGUgcHJlZGljY2nDs246CiAgKiAkcT1cZnJhY3sxfXtULTF9XHN1bV97dD0yfV5UIHx5X3QteV97dC0xfXwkIHBhcmEgc2VyaWVzIF9zaW5fIGVzdGFjaW9uYWxpZGFkCiAgKiAkcT1cZnJhY3sxfXtULW19XHN1bV97dD1tKzF9XlQgfHlfdC15X3t0LW19fCQgcGFyYSBzZXJpZXMgX2Nvbl8gZXN0YWNpb25hbGlkYWQKClx2c3BhY2V7MC4zY219CgoqIENvcnJlbGFjacOzbiBlbnRyZSAkXGhhdHtlfV90JCB5ICRcaGF0e2V9X3t0LTF9JCAoQUNGMSkuCgpcCgpNRSB5IE1QRSBwZXJtaXRlbiB2YWxvcmFyIGVsIHNlc2dvIGRlIGxhcyBwcmVkaWNjaW9uZXMgKHF1ZSBlc3RhcyBlc3TDqW4gc2lzdGVtw6F0aWNhbWVudGUgcG9yIGVuY2ltYSBvIHBvciBkZWJham8gZGUgbG9zIHZhbG9yZXMgcmVhbGVzKS4KCiogTG8gZXNwZXJhZG8gZXMgdW4gdmFsb3IgY2VyY2FubyBhIGNlcm8gKGNvbiByZWxhY2nDs24gYWwgdmFsb3IgbWVkaW8gZGUgbGEgc2VyaWUpLiBWYWxvcmVzIG11eSBhbGVqYWRvcyBkZSBjZXJvIHNvbiBpbmRpY2Fkb3JlcyBkZSBzZXNnbyBkZSBwcmVkaWNjacOzbi4KClJNU0UgeSBNQUUgaW5kaWNhbiBlbCBlcnJvciBtZWRpbyBjb21ldGlkbywgbWVkaWRvIGVuIGxhcyBtaXNtYXMgdW5pZGFkZXMgcXVlIGxhIHNlcmllIHRlbXBvcmFsLgoKKiBFc3TDoW4gYWNvdGFkYXMgaW5mZXJpb3JtZW50ZSBwb3IgZWwgdmFsb3Igw7NwdGltbyBkZSAwLCBwZXJvIG5vIGhheSBjb3RhIHN1cGVyaW9yLgoKTUFQRSB5IHNNQVBFIGluZGljYW4gZWwgZXJyb3IgcG9yY2VudHVhbCBtZWRpbyBjb21ldGlkby4KCiogRXN0w6FuIGFjb3RhZGFzIGluZmVyaW9ybWVudGUgcG9yIGVsIHZhbG9yIMOzcHRpbW8gZGUgMCUsIHkgbGEgY290YSBzdXBlcmlvciBuYXR1cmFsIGVzIDEwMCUsIGF1bnF1ZSBwb2Ryw61hIHNvYnJlcGFzYXJzZS4KKiBTaSAkeV90JCBwdWVkZSB2YWxlciAwLCBlbnRvbmNlcyBNQVBFIG5vIHNlIHB1ZWRlIGNhbGN1bGFyLiBBZGVtw6FzLCBNQVBFIHBlbmFsaXphIG3DoXMgbG9zIGVycm9yZXMgbmVnYXRpdm9zIGZyZW50ZSBhIGxvcyBlcnJvcmVzIHBvc2l0aXZvcy4gTGEgbWVkaWRhIGRlIHByZWNpc2nDs24gc01BUEUgc2UgZGVmaW5lIGEgZmluIGRlIGNvcnJlZ2lyIGVzdG9zIHByb2JsZW1hcy4KICAgICAgCk1BU0UgZXMgbGEgcmF0aW8gZW50cmUgZWwgZXJyb3IgZGVsIG3DqXRvZG8gdXNhZG8geSBlbCBlcnJvciBkZSB1biBtw6l0b2RvIGluZ2VudW8gZGUgcHJlZGljY2nDs24uIFBlcm1pdGUgc2FiZXIgY3XDoW50byBnYW5hbW9zIGVuIGNhcGFjaWRhZCBwcmVkaWN0aXZhIGFsIHBhc2FyIGRlIHVuIG3DqXRvZG8gaW5nZW51byBhIG90cm8gbcOhcyBjb21wbGljYWRvLgoKKiBVbiB2YWxvciBjZXJjYW5vIGEgMSBpbmRpY2EgcXVlIGVsIG3DqXRvZG8gdXNhZG8gbm8gZXMgbWVqb3IgcXVlIGVsIG3DqXRvZG8gaW5nZW51bwoqIEN1YW50byBtw6FzIGNlcmNhbm8gYSAwLCBtZWpvciBlcyBlbCBtw6l0b2RvIHVzYWRvIHJlc3BlY3RvIGRlbCBtw6l0b2RvIGluZ2VudW8KKiBTdSBjb21wbGVtZW50YXJpbyBhIDEgc2UgcHVlZGUgaW50ZXJwcmV0YXIgY29tbyBsYSB0YXNhIGRlIG1lam9yYQoKQUNGMSBldmFsw7phIGxhIGNhcGFjaWRhZCBkZSBtZWpvcmEgcXVlIGhheSBlbiBsYSBlc3RpbWFjacOzbiBkZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSBsYXMgcHJlZGljY2lvbmVzLiBMbyB2ZXJlbW9zIGNvbiBtw6FzIGRldGFsbGUgZW4gZWwgdGVtYSBkZSBtb2RlbG9zIEFSSU1BLiBQb3IgYWhvcmEgYmFzdGEgc2FiZXIgcXVlOgoKKiBVbiB2YWxvciBtdXkgY2VyY2FubyBhIDAgaW5kaWNhIHF1ZSBoYXkgcG9jYSBjYXBhY2lkYWQgZGUgbWVqb3JhLgoqIFVuIHZhbG9yIGNlcmNhbm8gYSAxIG8gLTEgaW5kaWNhIHF1ZSBoYXkgbXVjaGEgY2FwYWNpZGFkIGRlIG1lam9yYS4KCkxhcyBfbWVkaWFzXyBzZSBwdWVkZW4gc3VzdGl0dWlyIHBvciBfbWVkaWFuYXNfLiBFc3RvIGVzIGVzcGVjaWFsbWVudGUgw7p0aWwgY3VhbmRvIHBhcmEgYWxndW5hcyBvYnNlcnZhY2lvbmVzIGhheSBlcnJvcmVzIGF0w61waWNhbWVudGUgYWx0b3MuCgpcCgpTaSBwYXJhIHJlYWxpemFyIGxhIHByZWRpY2Npw7NuIGRlbCBwZXJpb2RvICR0JCBzZSB1c2EgdW5hIG1ldG9kb2xvZ8OtYSBxdWUgdXRpbGl6YSBkYXRvcyBoYXN0YSBkaWNobyBwZXJpb2RvLCBzZSBoYWJsYXLDoSBkZSAqKnByZWRpY2Npw7NuIHkgZXJyb3IgaW50cmEtbXVlc3RyYWwqKi4gRW4gY2FzbyBjb250cmFyaW8sIGxhIHByZWRpY2Npw7NuIGRlbCBwZXJpb2RvICR0JCB1c2EgdW5hIG1ldG9kb2xvZ8OtYSBxdWUgc29sbyBuZWNlc2l0YSBkZSBkYXRvcyBoYXN0YSBlbCBwZXJpb2RvICR0LTEkLCBzZSBoYWJsYXLDoSBkZSAqKnByZWRpY2Npw7NuIHkgZXJyb3IgZXh0cmEtbXVlc3RyYWwqKi4KClNpIGxvcyBpbmRpY2Fkb3JlcyBkZSBjYWxpZGFkIHNlIGJhc2FuIGVuIHByZWRpY2Npb25lcyBpbnRyYS1tdWVzdHJhbGVzIGEgdW4gcGVyaW9kbyB2aXN0YSwgcHJlc2VudGFuIGRvcyBwcm9ibGVtYXMuIFByaW1lcm8sIGV2YWzDumFuIGVsIGVycm9yIGRlIHByZWRpY2Npw7NuIGEgdW4gcGVyaW9kbyB2aXN0YSwgY3VhbmRvIGVuIG11Y2hhcyBzaXR1YWNpb25lcyByZWFsZXMgbGFzIHByZWRpY2Npb25lcyBzZSByZWFsaXphbiBzb2JyZSB1biBob3Jpem9udGUgdGVtcG9yYWwgbcOhcyBhbXBsaW8uIFNlZ3VuZG8sIHNvbiBlcnJvcmVzIGludHJhLW11ZXN0cmFsZXMsIHJlc3VsdGFudGVzIGRlIHByZWRlY2lyIGxvcyBtaXNtb3MgZGF0b3MgcXVlIHNlIGhhIHVzYWRvIGVsIG3DqXRvZG8gcGFyYSBjYWxjdWxhciBsYSBwcmVkaWNjacOzbiB5LCBwb3IgdGFudG8sIHNvYnJlLWVzdGltYW4gbGEgY2FwYWNpZGFkIHByZWRpY3RpdmEgZGVsIG1vZGVsby4KClZlcmVtb3MgZHVyYW50ZSBlbiBlc3RlIHRlbWEgbcOpdG9kb3MgZGUgZXZhbHVhY2nDs24gZGUgbGEgY2FsaWRhZCBkZSBsYXMgcHJlZGljY2lvbmVzIHF1ZSBzdXBlcmFuIGVzdGFzIGxpbWl0YWNpb25lcy4KClwKXAoKIyBNw6l0b2RvcyBzZW5jaWxsb3MgZGUgcHJlZGljY2nDs24KCkFsZ3Vub3MgbcOpdG9kb3MgZGUgcHJlZGljY2nDs24gc29uIGV4dHJlbWFkYW1lbnRlIHNlbmNpbGxvcyB5IHNvcnByZW5kZW50ZW1lbnRlIGVmaWNhY2VzLCBzb24gbG9zIGRlbm9taW5hZG9zIG3DqXRvZG9zIGluZ2VudW9zLiBFc3RvcyBtw6l0b2RvczoKCiogcG9zaWJpbGl0YW4gcmVhbGl6YXIgcHJlZGljY2lvbmVzIHByw6FjdGljYW1lbnRlIHNpbiByZWFsaXphciBuaW5nw7puIGPDoWxjdWxvLiAKKiBjb21vIHNvbiBtdXkgc2VuY2lsbG9zLCBkYW4gbGFzIHByZXZpc2lvbmVzIGNvbiBtYXlvciBlcnJvciAobWVub3MgcHJlY2lzYXMpLiBFbCBlcnJvciBkZSB1biBtw6l0b2RvIGluZ2VudW8gc2lydmUgZGUgcHVudG8gZGUgcmVmZXJlbmNpYSAoX2JlbmNobWFya18pIHBhcmEgdmFsb3JhciBsYSBuZWNlc2lkYWQgZGUgYXBsaWNhciBvdHJvcyBtw6l0b2RvcyBtw6FzIGNvbXBsaWNhZG9zIGNvbiBlbCBvYmpldGl2byBkZSBtZWpvcmFyIGxhIGNhbGlkYWQgZGUgbGFzIHByZWRpY2Npb25lcy4gCgpWZWFtb3MgYWxndW5vcyBtw6l0b2RvcyBpbmdlbnVvcyB5IHN1cyBmdW5jaW9uZXMgZW4gZWwgcGFxdWV0ZSBgZm9yZWNhc3RgLgoKXAoKIyMgTcOpdG9kb3Mgc2VuY2lsbG9zIGRlIHByZWRpY2Npw7NuCgojIyMgU2VyaWVzIF9zaW5fIHRlbmRlbmNpYSB5IF9zaW5fIGVzdGFjaW9uYWxpZGFkIHstfQoKKipNw6l0b2RvIGRlIGxhIE1lZGlhKio6ICRcaGF0e3l9X3tUK2h9PSh5XzErXGxkb3RzLHlfVCkvVCQuCgoqIExhIHByZWRpY2Npw7NuIHBhcmEgY3VhbHF1aWVyIHBlcmlvZG8gZnV0dXJvIGVzIGxhIF9fbWVkaWFfXyBkZSBsYXMgb2JzZXJ2YWNpb25lcyBkaXNwb25pYmxlcyBwcmV2aWFzLgoqIEZ1bmNpw7NuIGRlIGBSYDogYG1lYW5mKHksIGgpYAogICAgCioqTcOpdG9kbyBpbmdlbnVvIEkqKjogJFxoYXR7eX1fe1QraH09eV9UJC4KCiogTGEgcHJlZGljY2nDs24gcGFyYSBjdWFscXVpZXIgcGVyaW9kbyBmdXR1cm8gZXMgbGEgX1/Dumx0aW1hX18gb2JzZXJ2YWNpw7NuIGRpc3BvbmlibGUuCiogRnVuY2nDs24gZGUgYFJgOiBgbmFpdmUoeSwgaClgIG8gYHJ3Zih5LCBoKWAgKF9yd18gZGUgcmFuZG9tIHdhbGspCgoKIyMjIFNlcmllcyBfY29uXyB0ZW5kZW5jaWEgeSBfc2luXyBlc3RhY2lvbmFsaWRhZCB7LX0KCioqTcOpdG9kbyBpbmdlbnVvIElJKio6ICRcaGF0e3l9X3tUK2h9PXlfVCArIGgoeV9ULXlfe1QtMX0pJC4KCiogTGEgcHJlZGljY2nDs24gJGgkIHBlcmlvZG9zIGFkZWxhbnRlIGVzIGxhIF9fw7psdGltYSBvYnNlcnZhY2nDs25fXyBkaXNwb25pYmxlIG3DoXMgJGgkIHZlY2VzIGVsIF9fw7psdGltbyBpbmNyZW1lbnRvX18gb2JzZXJ2YWRvLiAKKiBObyB0aWVuZSBmdW5jacOzbiBlbiBgUmAsIHBlcm8gc2UgcG9kcsOtYSBlbXVsYXIgbWVkaWFudGUgbGEgZnVuY2nDs24gYGhvbHRgICh2w6lhc2UgZXDDrWdyYWZlIGRlIDQuNSBBbGlzYWRvIGV4cG9uZW5jaWFsIGRlIEhvbHQpLgogICAgICAKKipNw6l0b2RvIGRlIGxhIGRlcml2YSoqOiAkXGhhdHt5fV97VCtofT15X1QraFxmcmFje3lfVCAtIHlfMX17VC0xfSQuCgoqIExhIHByZWRpY2Npw7NuICRoJCBwZXJpb2RvcyBhZGVsYW50ZSBlcyBsYSBfX8O6bHRpbWEgb2JzZXJ2YWNpw7NuX18gZGlzcG9uaWJsZSBtw6FzICRoJCB2ZWNlcyBlbCBfX2luY3JlbWVudG8gbWVkaW9fXyBvYnNlcnZhZG8uCiogRnVuY2nDs24gZGUgYFJgOiBgcndmKHksIGgsIGRyaWZ0ID0gVFJVRSlgICAKCgojIyMgU2VyaWVzIF9zaW5fIHRlbmRlbmNpYSB5IF9jb25fIGVzdGFjaW9uYWxpZGFkIHstfQoKKipNw6l0b2RvIGluZ2VudW8gY29uIGVzdGFjaW9uYWxpZGFkKio6ICRcaGF0e3l9X3tUK2h9PXlfe1QtbShrKzEpfSQuCgoqICRrJCBlcyBsYSBwYXJ0ZSBlbnRlcmEgZGUgJChoLTEpL20kLCBlcyBkZWNpciwgZWwgbsO6bWVybyBkZSBhw7FvcyBjb21wbGV0b3MgZW4gZWwgcGVyaW9kbyBkZSBwcmVkaWNjacOzbiBwcmV2aW8gYWwgcGVyaW9kbyAkVCtoJC4KKiBMYSBwcmVkaWNjacOzbiBwYXJhIHVuIHBlcmlvZG8gZXMgbGEgX1/Dumx0aW1hIG9ic2VydmFjacOzbiBkaXNwb25pYmxlIGRlIGxhIG1pc21hIGVzdGFjacOzbiBxdWUgbGEgZmVjaGEgcXVlIHNlIGRlc2VhIHByZWRlY2lyX18uCiogRnVuY2nDs24gZGUgYFJgOiBgc25haXZlKHksIGgpYAogICAgCl9fTm8gaGF5IG3DqXRvZG9zIGluZ2VudW9zIGN1YW5kbyBsYSBzZXJpZSB0aWVuZSB0ZW5kZW5jaWEgeSBlc3RhY2lvbmFsaWRhZF9fLCBhdW5xdWUgbGEgYXBsaWNhY2nDs24gZGVsIG3DqXRvZG8gaW5nZW51byBjb24gZXN0YWNpb25hbGlkYWQgc3VlbGUgc2VyIG11eSBlZmVjdGl2YS4KClwKCiMjIEVqZW1wbG8gZGUgYXBsaWNhY2nDs24KCiMjIyBTZXJpZSBMaWJyb3Mgey19CiAKYGBge3J9CmxpYnJvcyA8LSByZWFkLmNzdjIoIi4vc2VyaWVzL2xpYnJvcy5jc3YiLCBoZWFkZXIgPSBUUlVFKQpsaWJyb3MgPC0gdHMobGlicm9zWyAsMl0sIHN0YXJ0ID0gMTk5MywgZnJlcXVlbmN5ICA9IDEpCmBgYAoKRW4gbGEgZmlndXJhIDEgc2UgbXVlc3RyYSBlbCByZXN1bHRhZG8gZ3LDoWZpY28gZGUgbGEgYXBsaWNhY2nDs24gZGUgYWxndW5vcyBkZSBlc3RvcyBtw6l0b2RvcyBzZW5jaWxsb3MgYSBsYSBzZXJpZSBMaWJyb3MgKG7Dum1lcm8gZGUgdMOtdHVsb3MgcHVibGljYWRvcyBhbnVhbG1lbnRlIGVuIEVzcGHDsWEgZGVzZGUgMTk5MyBoYXN0YSAyMDE4KSwgY29uIGluZGVwZW5kZW5jaWEgZGUgc3UgYWRlY3VhY2nDs24gZGFkYXMgbGFzIGNvbXBvbmVudGVzIGRlIGVzdGEgc2VyaWUuIFNlIGhhIGZpamFkbyB1biBob3Jpem9udGUgZGUgcHJldmlzacOzbiBkZSBjaW5jbyBhw7FvcyAoYGggPSA1YCkuIEVsIGFyZ3VtZW50byBgUEkgPSBGQUxTRWAgaGFjZSBxdWUgbm8gc2UgaW1wcmltYW4gbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIGRlIGxhcyBwcmVkaWNjaW9uZXMuCgpMb3MgbcOpdG9kb3MgZGUgbGEgTWVkaWEgZSBJbmdlbnVvIEkgcmVhbGl6YW4gdW5hIHByZWRpY2Npw7NuIGNvbnN0YW50ZSwgZWwgcHJpbWVybyBsYSBtZWRpYSBkZSB0w610dWxvcyBlbiBlbCBwZXJpb2RvIGRlIGFuw6FsaXNpcyAoYHIgYXMuaW50ZWdlcihtZWFuKGxpYnJvcykpYCkgeSBlbCBzZWd1bmRvIGVsIMO6bHRpbW8gZGF0byBvYnNlcnZhZG8gKGByIHRhaWwoYXMuaW50ZWdlcihsaWJyb3MpLCBuPTEpYCkuIEVsIG3DqXRvZG8gZGUgZGVyaXZhIG9mcmVjZSB1bmEgcHJlZGljY2nDs24gY3JlY2llbnRlIHBvcnF1ZSBsYSBzZXJpZSBMaWJyb3MgdGllbmUgdW5hIHBlbmRpZW50ZSBtZWRpYSBwb3NpdGl2YSBlbiBlbCBwZXJpb2RvIGRlIGFuw6FsaXNpcy4KClJlY3VlcmRhIHF1ZSBkZWJlcyBjYXJnYXIgbGFzIGxpYnJlcsOtYXMgYGZvcmVjYXN0YCB5IGBnZ3Bsb3QyYC4KCmBgYHtyfQoobWVkaWFMaWJyb3MgPC0gbWVhbmYobGlicm9zLCBoID0gNSkpCihuYWl2ZUxpYnJvcyA8LSBuYWl2ZShsaWJyb3MsIGggPSA1KSkKKGRlcml2YUxpYnJvcyA8LSByd2YobGlicm9zLCAgaCA9IDUsIGRyaWZ0ID0gVFJVRSkpCiAKCmF1dG9wbG90KGxpYnJvcywgc2VyaWVzID0gIkxpYnJvcyIsCiAgICAgICAgICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgICAgICAgICB5bGFiID0gIlTDrXR1bG9zIiwKICAgICAgICAgICAgICAgIG1haW4gPSAiRmlndXJhIDEuIExpYnJvcyB5IHByZWRpY2Npw7NuIHBvciBtw6l0b2RvcyBzZW5jaWxsb3MiKSArCiAgYXV0b2xheWVyKG1lZGlhTGlicm9zLCBzZXJpZXM9Ik1lZGlhIiwgUEkgPSBGQUxTRSkgKwogIGF1dG9sYXllcihuYWl2ZUxpYnJvcywgc2VyaWVzPSJJbmdlbnVvIiwgUEkgPSBGQUxTRSkgKwogIGF1dG9sYXllcihkZXJpdmFMaWJyb3MsIHNlcmllcz0iRGVyaXZhIiwgUEkgPSBGQUxTRSkgKwogIHNjYWxlX2NvbG91cl9kaXNjcmV0ZShsaW1pdHM9YygiTGlicm9zIiwgIk1lZGlhIiwgIkluZ2VudW8iLCAiRGVyaXZhIikpICsKICBndWlkZXMoY29sb3VyID0gZ3VpZGVfbGVnZW5kKHRpdGxlID0gIk3DqXRvZG9zIikpICsgCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uPWMoMC4wMiwwLjk4KSwgbGVnZW5kLmp1c3RpZmljYXRpb249YygwLDEpKQpgYGAKCkNvbiBsYSBmdW5jacOzbiBgYWNjdXJhY3lgIHNlIHB1ZWRlIG9idGVuZXIgZWwgZXJyb3IgZGUgcHJlZGljY2nDs24gaW50cmEtbXVlc3RyYWwgYSB1biBwZXJpb2RvIHZpc3RhIGRlIGNhZGEgbcOpdG9kbzoKCmBgYHtyLCBldmFsID0gRkFMU0V9CmFjY3VyYWN5KG1lZGlhTGlicm9zKQphY2N1cmFjeShuYWl2ZUxpYnJvcykKYWNjdXJhY3koZGVyaXZhTGlicm9zKQpgYGAKCmBgYHtyLCBlY2hvPUZBTFNFfQp0bXAgPC0gcmJpbmQoCiAgYWNjdXJhY3kobWVkaWFMaWJyb3MpLAogIGFjY3VyYWN5KG5haXZlTGlicm9zKSwKICBhY2N1cmFjeShkZXJpdmFMaWJyb3MpCikKdG1wIDwtIHJvdW5kKHRtcCwyKQpyb3duYW1lcyh0bXApIDwtIGMoIk1lZGlhIiwiSW5nZW51byBJIiwiRGVyaXZhIikKdG1wCmBgYAoKUG9kZW1vcyBkZXN0YWNhciBxdWU6CgoqIEVsIG3DqXRvZG8gZGUgX01lZGlhXyBwcmVzZW50YSB1bmEgYmFqYSBjYXBhY2lkYWQgcHJlZGljdGl2YSBkZWJpZG8gYSBxdWUgbGEgc2VyaWUgTGlicm9zIHRpZW5lIHRlbmRlbmNpYSAoTUFQRSA9ICAxNCUpLiBBZGVtw6FzLCBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGRlIGxhcyBwcmVkaWNjaW9uZXMgbm8gZXMgZmlhYmxlIChBQ0YxID0gMC43NykuCiogRWwgbcOpdG9kbyBkZSBfRGVyaXZhXyB0aWVuZSBsYSBtZWpvciBjYWxpZGFkIGRlIGFqdXN0ZSwgY29uIHVuIGVycm9yIHBvcmNlbnR1YWwgZGVsIDYuOSUgKE1BUEUpLCB5IHVuIGVycm9yIG1lZGlvIGFwcm94aW1hZG8gZGUgNiwwMDAgdMOtdHVsb3MgKFJNU0UpLiBObyBwcmVzZW50YSBzZXNnbyAoTUUgPSAwKSB5IGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgbGFzIHByZWRpY2Npb25lcyBlcyBmaWFibGUgKEFDRjEgPSAtMC4wNCkuCiogRWwgbcOpdG9kbyBfSW5nZW51byBJXyB0aWVuZSBidWVuYSBjYWxpZGFkIGRlIGFqdXN0ZSwgcGVybyBsYXMgcHJldmlzaW9uZXMgZXN0w6FuIG11eSBzZXNnYWRhcyAoTUUgPSA4NTcpLgoqIFBhcmEgc2VyaWVzIHNpbiBlc3RhY2lvbmFsaWRhZCBlbCBtw6l0b2RvIHNlbmNpbGxvIGRlIGNvbXBhcmFjacOzbiB1c2FkbyBlbiBlbCBjw6FsY3VsbyBkZWwgTUFTRSBlcyBlbCBfSW5nZW51byBJXy4gRXMgcG9yIGVsbG8gcXVlIGVzdGUgaW5kaWNhZG9yIHZhbGUgMSBwYXJhIGVzdGUgbcOpdG9kby4KKiBFbCBlcnJvciBtZWRpbyAoTUUpIHNpZW1wcmUgc2Vyw6EgbnVsbyBwYXJhIGVsIG3DqXRvZG8gZGUgbGEgX01lZGlhXyB5IGRlIGxhIF9EZXJpdmFfLCBsbyBxdWUgaW5kaWNhIHF1ZSBub3MgZXF1aXZvY2Ftb3MgdGFudG8gcG9yIGV4Y2VzbyBjb21vIHBvciBkZWZlY3RvLiBFc3RhIGVzIHVuYSBidWVuYSBwcm9waWVkYWQsIHF1ZSBlbCBtw6l0b2RvIF9JbmdlbnVvIElfIG5vIHZlcmlmaWNhLgoKIyMjIFNlcmllIE5hY2ltaWVudG9zIHstfQoKUG9kZW1vcyB1c2FyIGVsIG3DqXRvZG8gaW5nZW51byBjb24gZXN0YWNpb25hbGlkYWQgY29uIGxhIHNlcmllIE5hY2ltaWVudG9zIHBhcmEgb2J0ZW5lciB1bmEgcHJldmlzacOzbiBhIGRvcyBhw7FvcyB2aXN0YS4gRWwgZXJyb3IgYWJzb2x1dG8gcG9yY2VudHVhbCBtZWRpbyBlcyBkZWwgMy42JS4gRXMgZGVjaXIsIGFwbGljYW5kbyBhbGdvIHRhbiBzaW1wbGUgY29tbyBwcmVkZWNpciBlbCBuw7ptZXJvIGRlIG5hY2ltaWVudG9zIHBhcmEgdW4gbWVzIGNvbW8gbG9zIG5hY2ltaWVudG9zIGRlbCBtaXNtbyBtZXMgZGVsIGHDsW8gcHJldmlvLCB0ZW5lbW9zIHlhIHVuIGVycm9yIGRlIHByZWRpY2Npw7NuIG11eSBiYWpvLiBMYSBmaWd1cmEgMiBtdWVzdHJhIGxhIHNlcmllIHkgbGEgcHJlZGljY2nDs24gcXVlLCBkZWJpZG8gYWwgbcOpdG9kbyB1c2Fkbywgbm8gaW5jb3Jwb3JhIGxhIHRlbmRlbmNpYSBkZWNyZWNpZW50ZSBkZSBsb3Mgw7psdGltb3MgYcOxb3MuCgpgYGB7cn0KbmFjaW1pZW50b3MgPC0gcmVhZC5jc3YyKCIuL3Nlcmllcy9uYWNpbWllbnRvcy5jc3YiLCBoZWFkZXIgPSBUUlVFKQpuYWNpbWllbnRvcyA8LSB0cyhuYWNpbWllbnRvc1ssIDJdLAogICAgICAgICAgICAgICAgICBzdGFydCA9IGMoMTk3NSwgMSksCiAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSA9IDEyKQoKKHNuYWl2ZS5uYWNpbWllbnRvcyA8LSBzbmFpdmUobmFjaW1pZW50b3MsIGggPSAyNCwgbGV2ZWwgPSA5NSkpCmFjY3VyYWN5KHNuYWl2ZS5uYWNpbWllbnRvcykKCmF1dG9wbG90KHNuYWl2ZS5uYWNpbWllbnRvcywKICAgICAgICAgeGxhYiA9ICIiLAogICAgICAgICB5bGFiID0gIk5hY2ltaWVudG9zIiwKICAgICAgICAgbWFpbiA9ICJGaWd1cmEgMi4gTmFjaW1pZW50b3MgeSBwcmVkaWNjacOzbiBwb3IgZWwgbcOpdG9kbyBJbmdlbnVvIGNvbiBlc3RhY2lvbmFsaWRhZCIpCmBgYAoKClwKXAoKIyBFdmFsdWFjacOzbiBkZSBsYXMgcHJlZGljY2lvbmVzCgpMYXMgbWVkaWRhcyBxdWUgaGVtb3MgdXNhZG8gaGFzdGEgYWhvcmEgcGFyYSB2YWxvcmFyIGxhIGNhbGlkYWQgZGUgbGFzIHByZWRpY2Npb25lcyBzb24gcmVhbG1lbnRlIG1lZGlkYXMgZGUgYm9uZGFkIGRlIGFqdXN0ZSwgZXMgZGVjaXIsIG1lZGlkYXMgZGUgbGEgY2FsaWRhZCBkZSBfX3ByZXZpc2lvbmVzIGludHJhLW11ZXN0cmFsZXMgYSB1biBwZXJpb2RvIHZpc3RhX18uIFZhbG9yYW4gZW4gcXVlIG1lZGlkYSBsb3MgZGF0b3Mgc2UgYWp1c3RhbiBhIHVuIHBhdHLDs24gbyBtb2RlbG8sIHBlcm8gbm8gZXZhbMO6YW4gbGEgY2FsaWRhZCBkZSBsYSBwcmV2aXNpb25lcyBhbnRlIG51ZXZvcyBkYXRvcy4KCkVuIGVzdGUgZXDDrWdyYWZlIHZhbW9zIGEgdmVyIGRvcyBtZXRvZG9sb2fDrWFzIHF1ZSBwb2RlbW9zIHVzYXIgcGFyYSB2YWxvcmFyIGxhIGNhbGlkYWQgZGUgbGFzIF9fcHJldmlzaW9uZXMgZXh0cmEtbXVlc3RyYWxlc19fLCBxdWUgZXMgcmVhbG1lbnRlIGxvcyBxdWUgbm9zIGludGVyZXNhLiBFc3RhcyBkb3MgbWV0b2RvbG9nw61hcyBlc3TDoW4gcmVsYWNpb25hZGFzIGNvbiBsb3MgbcOpdG9kb3MgZGUgX1RyYWluaW5nIHNldC9UZXN0IHNldF8geSBfQ3Jvc3MtdmFsaWRhdGlvbl8gdXN1YWxlcyBlbiBlbCBhbsOhbGlzaXMgZGUgbGFzIHByZWRpY2Npb25lcyBjb24gZGF0b3MgdHJhbnN2ZXJzYWxlcywgcGVybyBhZGFwdGFkYXMgYSBkYXRvcyB0ZW1wb3JhbGVzLgoKIyMgVmFsaWRhY2nDs24gcG9yIGxhIG1ldG9kb2xvZ8OtYSBkZSBfVHJhaW5pbmcgc2V0L1Rlc3Qgc2V0XyBwYXJhIFNlcmllcyBUZW1wb3JhbGVzCgpWYW1vcyBhIG1lam9yYXIgbGEgZXN0aW1hY2nDs24gZGUgbGEgY2FsaWRhZCBkZSBsYXMgcHJlZGljY2lvbmVzIG9idGVuaWVuZG8gbGFzIG1lZGlkYXMgZGUgZXJyb3IgcGFyYSBfX3ByZXZpc2lvbmVzIGV4dHJhLW11ZXN0cmFsZXMgYSB2YXJpb3MgcGVyaW9kb3MgdmlzdGFfXyB1c2FuZG8gbGEgZmlsb3NvZsOtYSBkZWwgbcOpdG9kbyBfdHJhaW5pbmcgc2V0L3Rlc3Qgc2V0Xy4gRGl2aWRpbW9zIGxhIHNlcmllIHRlbXBvcmFsICRce3lfdFx9X3t0PTF9XlQkIGVuIGRvcyBzdWJzZXJpZXMsIGxvcyBwcmltZXJvcyBkYXRvcyAkXHt5X3RcfV97dD0xfV57VF8wfSQsICRUXzAgPCBUJCBzZSB1c2Fyw6FuIHBhcmEgZXN0aW1hciBlbCBtb2RlbG8sIHkgbG9zIMO6bHRpbW9zIGRhdG9zICRce3lfdFx9X3t0PXtUXzArMX19XntUfSQgcGFyYSB2YWxpZGFyIGVsIG1vZGVsby4KCkVzdGEgbWV0b2RvbG9nw61hLCBtdXkgZWZlY3RpdmEgcGFyYSBkYXRvcyBkZSBjb3J0ZSB0cmFuc3ZlcnNhbCwgZ2VuZXJhIGRvcyBwcm9ibGVtYXMgY3VhbmRvIHNlIGFwbGljYSBhIHNlcmllcyB0ZW1wb3JhbGVzOiBfaV8pIGVsIGVycm9yIG9idGVuaWRvIGVzIHVuYSBtZXpjbGEgZGUgZXJyb3JlcyBkZSBwcmVkaWNjacOzbiBhIGNvcnRvLCBtZWRpbyB5IGxhcmdvIHBsYXpvIGRpZsOtY2lsIGRlIHZhbG9yYXI7IF9paV8pIGxvcyByZXN1bHRhZG9zIGRlcGVuZGVuIHRyZW1lbmRhbWVudGUgZGVsIHB1bnRvIGRlIGNvcnRlIHRlbXBvcmFsIHNlbGVjY2lvbmFkby4KCiMjIyBTZXJpZSBMaWJyb3Mgey19CgpWYW1vcyBhIHJlc2VydmFyLCBwb3IgZWplbXBsbywgbGFzIMO6bHRpbWFzIDYgb2JzZXJ2YWNpb25lcyBkZSBsYSBzZXJpZSBMaWJyb3MgeSBhanVzdGFyIGVsIG1vZGVsbyBjb24gbGFzIHJlc3RhbnRlcy4gRGVzcHXDqXMgdXNhcmVtb3MgZXN0ZSBtb2RlbG8gcGFyYSBjYWxjdWxhciBsYXMgcHJlZGljY2lvbmVzIGEgNiBwZXJpb2RvcyB2aXN0YSB5IGNvbXBhcmFybGFzIGNvbiBsb3MgdmFsb3JlcyByZWFsZXMgZGUgbGEgc2VyaWUuIAoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBEZWZpbmltb3MgbGFzIG9ic2VydmFjaW9uZXMgaW50cmEtIHkgZXh0cmEtbXVlc3RyYWxlcwpsaWJyb3NJbnRyYSA8LSBzdWJzZXQobGlicm9zLCBlbmQgPSBsZW5ndGgobGlicm9zKSAtIDYpCmxpYnJvc0V4dHJhIDwtIHN1YnNldChsaWJyb3MsIHN0YXJ0ID0gbGVuZ3RoKGxpYnJvcykgLSA1KQoKIyBFc3RpbWFtb3MgZWwgbW9kZWxvIGNvbiB0b2RvcyBsb3MgZGF0b3MgbWVub3MgbG9zIDYgdWx0aW1vcyB5CiMgcHJlZGVjaW1vcyBsb3MgNiBhw7FvcyBxdWUgaGVtb3MgcXVpdGFkbyBkZSBsYSBzZXJpZSAKbGlicm9zRXh0cmFQcmUgPC0gcndmKGxpYnJvc0ludHJhLCAgaCA9IDYsIGRyaWZ0ID0gVFJVRSkKCiMgVmVtb3MgbGEgY2FsaWRhZCBkZWwgYWp1c3RlLiBQcmltZXJvIGxhIHByZWRpY2Npw7NuIHkgbHVlZ28gbG9zIGRhdG9zIHJlYWxlcwphY2N1cmFjeShsaWJyb3NFeHRyYVByZSwgbGlicm9zRXh0cmEpCmBgYAoKYGBge3IsIGVjaG8gPSBGQUxTRX0KIyBEZWZpbmltb3MgbGFzIG9ic2VydmFjaW9uZXMgaW50cmEtIHkgZXh0cmEtbXVlc3RyYWxlcwpsaWJyb3NJbnRyYSA8LSBzdWJzZXQobGlicm9zLCBlbmQgPSBsZW5ndGgobGlicm9zKSAtIDYpCmxpYnJvc0V4dHJhIDwtIHN1YnNldChsaWJyb3MsIHN0YXJ0ID0gbGVuZ3RoKGxpYnJvcykgLSA1KQoKIyBFc3RpbWFtb3MgZWwgbW9kZWxvIGNvbiB0b2RvcyBsb3MgZGF0b3MgbWVub3MgbG9zIDYgdWx0aW1vcyB5CiMgcHJlZGVjaW1vcyBsb3MgNyBhw7FvcyBxdWUgaGVtb3MgcXVpdGFkbyBkZSBsYSBzZXJpZSAKbGlicm9zRXh0cmFQcmUgPC0gcndmKGxpYnJvc0ludHJhLCAgaCA9IDYsIGRyaWZ0ID0gVFJVRSkKCiMgVmVtb3MgbGEgY2FsaWRhZCBkZWwgYWp1c3RlLiBQcmltZXJvIGxhIHByZWRpY2Npw7NuIHkgbHVlZ28gbG9zIGRhdG9zIHJlYWxlcwpyb3VuZChhY2N1cmFjeShsaWJyb3NFeHRyYVByZSwgbGlicm9zRXh0cmEpLCAyKQoKZXJyb3IubXVlc3RyYWwuMSA8LSByb3VuZChhY2N1cmFjeShsaWJyb3NFeHRyYVByZSwgbGlicm9zRXh0cmEpWzEsNV0sIDEpCmVycm9yLmV4dHJhbXVlc3RyYWwubiA8LSByb3VuZChhY2N1cmFjeShsaWJyb3NFeHRyYVByZSwgbGlicm9zRXh0cmEpWzIsNV0sMSkKYGBgCgpBdGVuZGllbmRvIGFsIE1BUEUgc2UgdGllbmUgcXVlIGVsIGVycm9yIGRlIF9fcHJldmlzacOzbiBhIHVuIHBlcmlvZG8gdmlzdGFfXyBlbiBlbCBfX3BlcmlvZG8gaW50cmEtbXVlc3RyYWxfXyBkZSBfXzE5OTMgYSAyMDEyX18gZXMgZGVsIGByIGVycm9yLm11ZXN0cmFsLjFgJTsgbWllbnRyYXMgcXVlIGVsIGVycm9yIGRlIF9fcHJldmlzacOzbiBhIGxhcmdvIHBsYXpvX18gZW4gZWwgX19wZXJpb2RvIGV4dHJhLW11ZXN0cmFsX18gZGUgX18yMDEzIGEgMjAxOF9fIGVzIGRlbCBgciBlcnJvci5leHRyYW11ZXN0cmFsLm5gJS4gQWRlbWFzLCBwYXJhIGVsIHBlcmlvZG8gZXh0cmEtbXVlc3RyYWwgZWwgZXJyb3IgbWVkaW8gKE1FKSBlcyBuZWdhdGl2byB5IG11eSBlbGV2YWRvLCB1biBpbmRpY2F0aXZvIGRlIHF1ZSBsYXMgcHJldmlzaW9uZXMgZXN0w6FuIHNlZ2FkYXMgKHNvYnJlLWVzdGltYW4gbGEgcmVhbGlkYWQpLiBFbiByZXN1bWVuLCBsYSBjYWxpZGFkIGRlbCBtb2RlbG8gc2UgZGV0ZXJpb3JhIG11eSByw6FwaWRhbWVudGUgZW4gY3VhbnRvIG5vcyBzYWxpbW9zIGRlIGxhcyBjb25kaWNpb25lcyDDs3B0aW1hcy4gCgpVbiBncsOhZmljbyBwdWVkZSBheXVkYXIgYSBlbnRlbmRlciBlc3RlIHByb2Nlc28gZGUgdmFsaWRhY2nDs24uIEVuIGxhIGZpZ3VyYSAzOgoKKiBMYSBsw61uZWEgZGUgcHVudG9zIHZlcnRpY2FsIHNlcGFyYSBlbCBwZXJpb2RvIG11ZXN0cmFsICgxOTkzLTIwMTIpIHVzYWRvIHBhcmEgZXN0aW1hciBlbCBtb2RlbG8sIGRlbCBwZXJpb2RvIGV4dHJhLW11ZXN0cmFsICgyMDEzLTIwMTgpIHVzYWRvIHPDs2xvIHBhcmEgaGFjZXIgbGFzIHByZXZpc2lvbmVzLgoqIExhIHNlcmllIExpYnJvcyBhcGFyZWNlIGNvbW8gdW5hIGzDrW5lYSBzw7NsaWRhIGVuIG5lZ3JvLCBkZXNkZSAxOTkzIGhhc3RhIDIwMTguCiogTGEgcHJldmlzacOzbiBfaW50cmFfLW11ZXN0cmFsIChhIHVuIHBlcmlvZG8gdmlzdGEpIGRlIGxhIHNlcmllIExpYnJvcyBhcGFyZWNlIGNvbW8gdW5hIGzDrW5lYSBhenVsLgoqIExhIGzDrW5lYSBlbiByb2pvIGVzIGxhIHByZXZpc2nDs24gX2V4dHJhXy1tdWVzdHJhbCBhIGxhcmdvIHBsYXpvLiBPYnNlcnZhIHF1ZSB0b2RhcyBsYXMgcHJldmlzaW9uZXMgZXN0w6FuIHBvciBlbmNpbWEgZGVsIHZhbG9yIHJlYWwgZGUgbGEgc2VyaWUuCiogQWwgbGFkbyBkZSBjYWRhIHByZXZpc2nDs24gKGludHJhLSB5IGV4dHJhLW11ZXN0cmFsKSBzZSBoYSBpbmRpY2FkbyBlbCBlcnJvciBlc3RpbWFkbyAoTUFQRSkuCgpDbGFyYW1lbnRlIGVzdG9zIHJlc3VsdGFkb3MgZGVwZW5kZW4gZGVsIHB1bnRvIGRlIGNvcnRlIHNlbGVjY2lvbmFkby4KCmBgYHtyLGVjaG89RkFMU0V9CmF1dG9wbG90KGxpYnJvcywgc2VyaWVzID0gIkxpYnJvcyIsCiAgICAgICAgIG1haW49IkZpZ3VyYSAzLiBMaWJyb3MsIHByZWRpY2Npw7NuIGludHJhLSB5IGV4dHJhLW11ZXN0cmFsIiwKICAgICAgICAgeGxhYj0iIiwgCiAgICAgICAgIHlsYWI9IlTDrXR1bG9zIgogICAgICAgICApICsKICBhdXRvbGF5ZXIoZml0dGVkKGxpYnJvc0V4dHJhUHJlKSwgc2VyaWVzID0gIkxpYnJvcyAoYWp1c3RhZGEpIikgKyAKICBhdXRvbGF5ZXIobGlicm9zRXh0cmFQcmUkbWVhbiwgc2VyaWVzID0gIlByZWRpY2Npw7NuIikgKyAKICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSAyMDEyLjUsIGx0eSA9IDIsIGNvbCA9ICJibGFjayIpICsKICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCJMaWJyb3MiPSJibGFjayIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTGlicm9zIChhanVzdGFkYSkiPSJibHVlIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiUHJlZGljY2nDs24iID0gInJlZCIpKSArCiAgZ3VpZGVzKGNvbG91ciA9IGd1aWRlX2xlZ2VuZCh0aXRsZSA9ICJTZXJpZXMiKSkgKwogIGFubm90YXRlKCJ0ZXh0IiwgeD0xOTk5LCB5PTY1MDAwLCBsYWJlbD0iNi41JSIsIGNvbG91ciA9ICJibHVlIikgKwogIGFubm90YXRlKCJ0ZXh0IiwgeD0yMDE2LCB5PTcyMDAwLCBsYWJlbD0iMjYuNyUiLCBjb2xvdXIgPSAicmVkIikgKwogIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj1jKDAuMDIsMC45OCksIGxlZ2VuZC5qdXN0aWZpY2F0aW9uPWMoMCwxKSkgCmBgYAoKIyMjIFNlcmllIE5hY2ltaWVudG9zIHstfQoKQ2FsY3VsYW1vcyBkZSBudWV2byBsb3MgZGlmZXJlbnRlcyBjcml0ZXJpb3MgZGUgYm9uZGFkIGRlIGFqdXN0ZSBwYXJhIHZhbG9yYXIgbGEgY2FsaWRhZCBkZSBsYXMgcHJldmlzaW9uZXMgZXh0cmEtbXVlc3RyYWxlcyBhIGxhcmdvIHBsYXpvLiBFbiBlc3RlIGNhc28gdmFtb3MgYSByZXNlcnZhciBsb3Mgw7psdGltb3MgMzYgbWVzZXMgY29tbyBwZXJpb2RvIGV4dHJhLW11ZXN0cmFsLgogIApgYGB7ciwgZXZhbCA9IEZBTFNFfQpuYWNpbWllbnRvc0ludHJhIDwtIHN1YnNldChuYWNpbWllbnRvcywgZW5kID0gbGVuZ3RoKG5hY2ltaWVudG9zKSAtIDM2KQpuYWNpbWllbnRvc0V4dHJhIDwtIHN1YnNldChuYWNpbWllbnRvcywgc3RhcnQgPSBsZW5ndGgobmFjaW1pZW50b3MpIC0gMzUpCgpuYWNpbWllbnRvc0V4dHJhUHJlIDwtIHNuYWl2ZShuYWNpbWllbnRvc0ludHJhLCBoID0gMzYpCgphY2N1cmFjeShuYWNpbWllbnRvc0V4dHJhUHJlLCBuYWNpbWllbnRvc0V4dHJhKQpgYGAKCmBgYHtyLCBlY2hvID0gRkFMU0V9Cm5hY2ltaWVudG9zSW50cmEgPC0gc3Vic2V0KG5hY2ltaWVudG9zLCBlbmQgPSBsZW5ndGgobmFjaW1pZW50b3MpIC0gMzYpCm5hY2ltaWVudG9zRXh0cmEgPC0gc3Vic2V0KG5hY2ltaWVudG9zLCBzdGFydCA9IGxlbmd0aChuYWNpbWllbnRvcykgLSAzNSkKCm5hY2ltaWVudG9zRXh0cmFQcmUgPC0gc25haXZlKG5hY2ltaWVudG9zSW50cmEsIGggPSAzNikKCnJvdW5kKGFjY3VyYWN5KG5hY2ltaWVudG9zRXh0cmFQcmUsIG5hY2ltaWVudG9zRXh0cmEpLCAyKQpgYGAKCmBgYHtyLCBlY2hvID0gRkFMU0V9CmF1dG9wbG90KG5hY2ltaWVudG9zLCBzZXJpZXMgPSAiTmFjaW1pZW50b3MiLAogICAgICAgICBtYWluPSJGaWd1cmEgNC4gTmFjaW1pZW50b3MsIHByZWRpY2Npw7NuIGludHJhLSB5IGV4dHJhLW11ZXN0cmFsIiwKICAgICAgICAgeGxhYj0iIiwgCiAgICAgICAgIHlsYWI9Ik5hY2ltaWVudG9zIgogICAgICAgICApICsKICBhdXRvbGF5ZXIoZml0dGVkKG5hY2ltaWVudG9zRXh0cmFQcmUpLCBzZXJpZXMgPSAiTmFjaW1pZW50b3MgKGFqdXN0YWRhKSIpICsgCiAgYXV0b2xheWVyKG5hY2ltaWVudG9zRXh0cmFQcmUkbWVhbiwgc2VyaWVzID0gIlByZWRpY2Npw7NuIikgKyAKICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCJOYWNpbWllbnRvcyI9ImJsYWNrIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJOYWNpbWllbnRvcyAoYWp1c3RhZGEpIj0iYmx1ZSIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlByZWRpY2Npw7NuIiA9ICJyZWQiKSkgKwogIGd1aWRlcyhjb2xvdXIgPSBndWlkZV9sZWdlbmQodGl0bGUgPSAiU2VyaWVzIikpICsKICBhbm5vdGF0ZSgidGV4dCIsIHg9MjAxMiwgeT00NTAwMCwgbGFiZWw9IjMuNiUiLCBjb2xvdXIgPSAiYmx1ZSIpICsKICBhbm5vdGF0ZSgidGV4dCIsIHg9MjAxOCwgeT00MDAwMCwgbGFiZWw9IjcuNyUiLCBjb2xvdXIgPSAicmVkIikgKyAKICB0aGVtZShsZWdlbmQucG9zaXRpb249YygwLjk4LDAuOTgpLCBsZWdlbmQuanVzdGlmaWNhdGlvbj1jKDEsMSkpIApgYGAKCkxhcyBwcmV2aXNpb25lcyBleHRyYS1tdWVzdHJhbGVzIG11ZXN0cmFuIHVuYSBtZW5vciBwZW5kaWVudGUgcXVlIGxvcyBjYXNvcyByZWFsZXMgZGUgbmFjaW1pZW50b3MuIEFzw60sIGNvbmZvcm1lIHNlIGF2YW56YSBlbiBlbCBob3Jpem9udGUgdGVtcG9yYWwgbGFzIHByZXZpc2lvbmVzIHNlIHZhbiBhbGVqYW5kbyBkZSBsYSByZWFsaWRhZCB5IGVsIGVycm9yIGV4dHJhLW11ZXN0cmFsIGVzIGRlbCA3LjclLCByZWR1Y2lkbyBwZXJvIHF1ZSBkdXBsaWNhIGVsIGVycm9yIGRlIGVzdGltYWNpw7NuIGludHJhLW11ZXN0cmFsICgzLjYlKS4KClwKCiMjIFZhbGlkYWNpw7NuIGNydXphZGEgcGFyYSBTZXJpZXMgVGVtcG9yYWxlcwoKSGVtb3MgdmlzdG8gZG9zIGFsdGVybmF0aXZhcyBwYXJhIGV2YWx1YXIgbGEgY2FsaWRhZCBkZSB1biBtw6l0b2RvIGRlIHByZWRpY2Npw7NuIGRlIHNlcmllcyB0ZW1wb3JhbGVzLCB1bm8gYmFzYWRvIGVuIHByZWRpY2Npb25lcyBpbnRyYS1tdWVzdHJhbGVzIGEgdW4gcGVyaW9kbyB2aXN0YSB5IG90cm8gYmFzYWRvIGVuIHByZWRpY2Npb25lcyBleHRyYS1tdWVzdHJhbGVzIGEgbGFyZ28gcGxhem8sIGFtYmFzIGNvbiBzdXMgaW5jb252ZW5pZW50ZXMuCgpWZWFtb3MgYWhvcmEgdW5hIHTDqWNuaWNhLCBiYXNhZGEgZW4gZWwgY29uY2VwdG8gZGUgdmFsaWRhY2nDs24gY3J1emFkYSAoX2Nyb3NzIHZhbGlkYXRpb25fKSBxdWUgcGVybWl0ZSBvYnRlbmVyIGRlIGZvcm1hIGluZGl2aWR1YWxpemFkYSBsb3MgZXJyb3JlcyBkZSBwcmV2aXNpw7NuIGV4dHJhLW11ZXN0cmFsIGEgdW4gcGVyaW9kbyB2aXN0YSwgYSBkb3MgcGVyaW9kb3MgdmlzdGEsIGV0Yy4KClN1cG9uZ2Ftb3MgcXVlIHBhcmEgZXN0aW1hciBlbCBtb2RlbG8gc2UgbmVjZXNpdGEgdW4gbcOtbmltbyBkZSAkayQgb2JzZXJ2YWNpb25lcyB5IHF1ZSBzZSBkZXNlYSBwcmVkZWNpciBoYXN0YSB1biBob3Jpem9udGUgdGVtcG9yYWwgJGgkLgoKKiBTZWxlY2Npb25hbW9zIGxhcyBvYnNlcnZhY2lvbmVzICQxLDIsLi4uLGskIHBhcmEgZXN0aW1hciBlbCBtb2RlbG8geSBwcmVkZWNpbW9zIGxhcyBvYnNlcnZhY2lvbmVzIGRlc2RlICRrKzEkIGhhc3RhICRrK2gkLiBUZW5lbW9zLCBwb3IgdGFudG8sICRoJCBwcmVkaWNjaW9uZXMuCiogQ2FsY3VsYW1vcyBlbCBlcnJvciBkZSBwcmVkaWNjacOzbiBwYXJhIGxhcyBwcmVkaWNjaW9uZXMgZGVzZGUgJGsrMSQgaGFzdGEgJGsraCQuCiogUmVwZXRpbW9zIGVzdGUgcHJvY2VzbyBkZXNwbGF6YW5kbyBlbCBuw7ptZXJvIGRlIG9ic2VydmFjaW9uZXMgc2VsZWNjaW9uYWRhcyBwYXJhIGxhIGVzdGltYWNpw7NuIHVuIHBlcmlvZG8gYWRlbGFudGUuIEVzIGRlY2lyLCBhaG9yYSB1c2Ftb3MgbGFzIG9ic2VydmFjaW9uZXMgJDIsMywuLi4saysxJCBwYXJhIGVzdGltYXIgZWwgbW9kZWxvLCBwcmVkZWNpbW9zIGxhcyBvYnNlcnZhY2lvbmVzIGRlc2RlICRrKzIkIGhhc3RhICRrKzEraCQgeSBjYWxjdWxhbW9zIGVsIGVycm9yIGRlIHByZWRpY2Npw7NuLgoqIEl0ZXJhbW9zIGVsIHByb2Nlc28sIGRlc3BsYXphbmRvIGNhZGEgdmV6IGxhcyBvYnNlcnZhY2lvbmVzIGRlIGxhIGVzdGltYWNpw7NuIHVuIHBlcmlvZG8gYWRlbGFudGUuCiogRW4gZ2VuZXJhbCBwYXJhICRpPTAsMSwuLi4sVC1rLWgkLCBkb25kZSAkVCQgZXMgZWwgbsO6bWVybyB0b3RhbCBkZSBvYnNlcnZhY2lvbmVzOgogIAogIDEuIFNlbGVjY2lvbmFtb3MgbGFzIG9ic2VydmFjaW9uZXMgJGkrMSxpKzIsLi4uLGkrayQgcGFyYSBlc3RpbWFyIGVsIG1vZGVsby4KICAyLiBQcmVkZWNpbW9zIGxhcyBvYnNlcnZhY2lvbmVzIGRlc2RlICRpK2srMSQgaGFzdGEgJGkraytoJC4KICAzLiBDYWxjdWxhbW9zIGVsIGVycm9yIGRlIHByZWRpY2Npw7NuIHBhcmEgbGFzIG9ic2VydmFjaW9uZXMgZGVzZGUgJGkraysxJCBoYXN0YSAkaStrK2gkLgogIDQuIFBhcmEgY2FkYSBob3Jpem9udGUgdGVtcG9yYWwgZGUgcHJlZGljY2nDs24gc2UgY2FsY3VsYSBsYSBtZWRpZGEgZGUgZXJyb3IgZGVzZWFkYS4KClwKXAoKIVtdKC4vaW1hZ2VuZXMvUm9sbGluZ1dpbmRvd3MucG5nKQoKRXN0ZSBwcm9jZWRpbWllbnRvIHNlIGRlbm9taW5hIF9fb3JpZ2VuIGRlIHByZWRpY2Npw7NuIG3Ds3ZpbF9fIChfcm9sbGluZyBmb3JlY2FzdCBvcmlnaW5fKSBvIF9yb2xsaW5nIHdpbmRvd3NfLgoKQ3VhbmRvIHNlIGFwbGljYSBlc3RhIG1ldG9kb2xvZ8OtYSBoYXkgcXVlIHRlbmVyIGVuIGN1ZW50YSBxdWUgbG9zIHJlc3VsdGFkb3MgcHVlZGVuIGRlcGVuZGVyIGRlbCBuw7ptZXJvICRrJCBkZSBkYXRvcyB1c2Fkb3MgcGFyYSBsYSBlc3RpbWFjacOzbiBkZWwgbW9kZWxvLgoKIyMjIEVqZW1wbG8gZGUgYXBsaWNhY2nDs24gY29uIE5hY2ltaWVudG9zIHstfQoKVmFtb3MgYSBhcGxpY2FyIGxhIG1ldG9kb2xvZ8OtYSBwcmV2aWEgYSBsYSBzZXJpZSBhbnVhbCBkZSBOYWNpbWllbnRvcy4gQXN1bWltb3MgcXVlIHNlIHByZWNpc2FuIHZlaW50ZSBhw7FvcyBwYXJhIGhhY2VyIHVuYSBidWVuYSBlc3RpbWFjacOzbiwgJGs9MjAkLCB5IHF1ZSBlbCBob3Jpem9udGUgdGVtcG9yYWwgZXMgZGUgY2luY28gYcOxb3MsICRoID0gNSQgbWVzZXMuIExhIHNpZ3VpZW50ZSBydXRpbmEgcGVybWl0ZSBvYnRlbmVyIGVsIE1BUEUgcGFyYSBwcmV2aXNpb25lcyBjb24gdW4gaG9yaXpvbnRlIHRlbXBvcmFsIGRlc2RlIHVubyBhIGNpbmNvIGHDsW9zLgogIApgYGB7cn0gIApuYWNBbnVhbCA8LSBhZ2dyZWdhdGUobmFjaW1pZW50b3MsIEZVTiA9IHN1bSkKayA8LSAyMCAgICAgICAgICAgICAgICAgICAjTWluaW1vIG51bWVybyBkZSBkYXRvcyBwYXJhIGVzdGltYXIKaCA8LSA1ICAgICAgICAgICAgICAgICAgICAjSG9yaXpvbnRlIGRlIGxhcyBwcmVkaWNpY2lvbmVzClRUIDwtIGxlbmd0aChuYWNBbnVhbCkgICAgI0xvbmdpdHVkIHNlcmllCnMgPC0gVFQgLSBrIC0gaCAgICAgICAgICAgI1RvdGFsIGRlIGVzdGltYWNpb25lcwoKbWFwZVJ3ZiA8LSBtYXRyaXgoTkEsIHMgKyAxLCBoKQpmb3IgKGkgaW4gMDpzKSB7CiAgdHJhaW4uc2V0IDwtIHN1YnNldChuYWNBbnVhbCwgc3RhcnQgPSBpICsgMSwgZW5kID0gaSArIGspCiAgdGVzdC5zZXQgPC0gIHN1YnNldChuYWNBbnVhbCwgc3RhcnQgPSBpICsgayArIDEsIGVuZCA9IGkgKyBrICsgaCkKICAKICBmY2FzdCA8LSByd2YodHJhaW4uc2V0LCBoID0gaCwgZHJpZnQgPSBUUlVFKQogIG1hcGVSd2ZbaSArIDEsXSA8LSAxMDAqYWJzKHRlc3Quc2V0IC0gZmNhc3QkbWVhbikvdGVzdC5zZXQKfQoKbWFwZVJ3ZiA8LSBjb2xNZWFucyhtYXBlUndmKQpyb3VuZChtYXBlUndmLCAyKQpgYGAKCkVsIGVycm9yIGRlIHByZXZpc2nDs24gZXh0cmEtbXVlc3RyYWwgY3JlY2UgbGluZWFsbWVudGUgY29uIGVsIGhvcml6b250ZSBkZSBwcmV2aXNpw7NuLiBQYXJhIGVsIHByaW1lciBhw7FvIGVsIGVycm9yIGRlIHByZWRpY2Npw7NuIHNlIG1hbnRpZW5lIGVuIHVuIG1vZGVyYWRvIDQuMiUuIFNpbiBlbWJhcmdvLCBwYXJhIGVsIHNlZ3VuZG8gYcOxbyBkZSBwcmVkaWNjacOzbiBlbCBNQVBFIHNhbHRhIGFsIDguMiUgeSBwYXJhIGxvcyByZXN0YW50ZXMgYcOxb3Mgc2lndWUgY3JlY2llbmRvIHLDoXBpZGFtZW50ZS4gUHJlZGVjaXIgdXNhbmRvIGxhIHRlbmRlbmNpYSBtZWRpYSBzb2xvIGVzIHVuIGJ1ZW4gbcOpdG9kbyBwYXJhIHByZWRlY2lyIGEgdW4gYcOxbyB2aXN0YS4KClwKXAoKIyBNw6l0b2RvcyBkZSBBbGlzYWRvIEV4cG9uZW5jaWFsCgojIyBJbnRyb2R1Y2Npw7NuCgpMb3MgbcOpdG9kb3MgZGUgYWxpc2FkbyBleHBvbmVuY2lhbCBhcGFyZWNlbiBlbiBsb3MgYcOxb3MgNTAgZGUgbGEgbWFubyBkZSBCcm93biwgSG9sdCB5IFdpbnRlcnMgeSBoYW4gc2lkbyBsYSByYcOteiBkZSB1bm8gZGUgbG9zIG3DqXRvZG9zIGRlIHByZWRpY2Npw7NuIG3DoXMgc2VuY2lsbG9zIHkgZWZpY2FjZXMuIExhIGlkZWEgYsOhc2ljYSBlcyBwcmVkZWNpciB1c2FuZG8gdW5hIG1lZGlhIHBvbmRlcmFkYSBkZSBsb3MgZGF0b3MgcGFzYWRvcywgZG9uZGUgbG9zIG3DoXMgcmVjaWVudGVzIHRpZW5lbiB1biBwZXNvIG1heW9yIHkgZXN0ZSBkZWNhZSBleHBvbmVuY2lhbG1lbnRlIGNvbmZvcm1lIHVzYW1vcyBvYnNlcnZhY2lvbmVzIG3DoXMgYW50aWd1YXMuCgpFbCBhbGlzYWRvIGV4cG9uZW5jaWFsIGVzIHVuYSBmYW1pbGlhIGRlIG3DqXRvZG9zIGRlIGFqdXN0ZSB5IHByZXZpc2nDs24gcXVlIG9mcmVjZSBtdXkgYnVlbm9zIHJlc3VsdGFkb3MgcGFyYSBwcmVkaWNjaW9uZXMgYSBjb3J0byBwbGF6byBvIHBhcmEgcHJlZGVjaXIgc2VyaWVzIGNvbiBwb2NvcyBkYXRvcyBvIF9zZW5jaWxsYXNfIChzaW4gbXVjaG8gX3J1aWRvXykuCgpTdXBvbmVuIHVuIGdyYWRvIGRlIG1vZGVsaXphY2nDs24gbWF5b3IgcXVlIGxvcyBtw6l0b2RvcyBzZW5jaWxsb3MgdmlzdG9zIHByZXZpYW1lbnRlLCBwZXJvIHNpbiBhbGNhbnphciBsYSBjb21wbGVqaWRhZCBkZSBvdHJhcyBtZXRvZG9sb2fDrWFzIChtb2RlbG9zIEFSSU1BKS4gIAoKRW4gb3JpZ2VuLCBzb24gbcOpdG9kb3MgZGVzY3JpcHRpdm9zIGNvbiBlbCDDum5pY28gb2JqZXRpdm8gZGUgcHJvZHVjaXIgX19wcmVkaWNjaW9uZXMgcHVudHVhbGVzX18uIFNpbiBlbWJhcmdvLCBzdSBlbmZvcXVlIGNvbW8gbW9kZWxvcyBkZSBfZXNwYWNpbyBkZSBlc3RhZG9zXyBwb3NpYmlsaXRhIHVuIG1hcmNvIHRlw7NyaWNvIHBhcmEgb2J0ZW5lciBfX2ludGVydmFsb3MgZGUgcHJlZGljY2nDs25fXy4KClwKCiMjIENvbXBvbmVudGVzIGRlIHVuYSBzZXJpZSBlbiBlbCBjb250ZXh0byBkZWwgYWxpc2FkbyBleHBvbmVuY2lhbAoKUGFyYSBvYnRlbmVyIHVuYSBwcmVkaWNjacOzbiBlbiBlbCBwZXJpb2RvICR0KzEkIGNvbiBkYXRvcyBoYXN0YSBlbCBwZXJpb2RvICR0JCBuZWNlc2l0YW1vcyB0cmVzIGNvbXBvbmVudGVzOgoKKiBMYSBlc3RpbWFjacOzbiBkZWwgbml2ZWwgZGUgbGEgc2VyaWUgZW4gZWwgcGVyaW9kbyAkdCQ6ICRsX3QkCiogTGEgZXN0aW1hY2nDs24gZGUgbGEgcGVuZGllbnRlIGRlIGxhIHNlcmllIGVuIGVsIHBlcmlvZG8gJHQkOiAkYl90JAoqIExhIGVzdGltYWNpw7NuIGRlIGxhIGVzdGFjaW9uYWxpZGFkIGVuIGVsIG1lcyBjb3JyZXNwb25kaWVudGUgYWwgcGVyaW9kbyAkdCsxJCBjb24gZGF0b3MgaGFzdGEgJHQkOiAkc197dCArIDEgLSBtfSQgKHJlY3VlcmRhLCAkbSQgZXMgZWwgb3JkZW4gZXN0YWNpb25hbAoKQSBwYXJ0aXIgZGUgZXN0YXMgY29tcG9uZW50ZXMsIG9idGVuaWRhcyBlbiBlbCBwZXJpb2RvICR0JCB5IHBhcmEgdW4gZXNxdWVtYSBhZGl0aXZvLCBzZSB0ZW5kcsOtYSBxdWUgbGEgcHJlZGljY2nDs24gZW4gZWwgcGVyaW9kbyAkdCsxJCBlczoKJCRcd2lkZWhhdHt5fV97dCsxfSA9IGxfdCtiX3Qrc197dCsxLW19LiQkCkVuIGdlbmVyYWwsIGxhcyBjb21wb25lbnRlcyBwdWVkZW4gX19leGlzdGlyIG8gbm9fXyB5IHNlIHB1ZWRlbiBjb21iaW5hciBlbnRyZSBlbGxhcyBfX2FkaXRpdmEgbyBtdWx0aXBsaWNhdGl2YW1lbnRlX18uIFZlYW1vcyBhbGd1bm9zIGNhc29zOgoKKiBFeGlzdGVuIHRvZGFzIHkgc29uIG11bHRpcGxpY2F0aXZhczoKJCRcd2lkZWhhdHt5fV97dCsxfT1sX3QgXGNkb3QgYl90IFxjZG90IHNfe3QgKyAxIC0gbX0kJAoqIEV4aXN0ZW4gdG9kYXMsIG5pdmVsIHkgcGVuZGllbnRlIGFkaXRpdmFzLCB5IGVzdGFjaW9uYWxpZGFkIG11bHRpcGxpY2F0aXZhOgokJFx3aWRlaGF0e3l9X3t0KzF9PShsX3QrYl90KXNfe3QgKyAxIC0gbX0kJAoqIE5vIGhheSBwZW5kaWVudGUgeSBsYSBlc3RhY2lvbmFsaWRhZCBlcyBhZGl0aXZhOgokJFx3aWRlaGF0e3l9X3t0KzF9PWxfdCtzX3t0ICsgMSAtIG19JCQKCsK/Q29tbyBvYnRlbmVtb3MgbG9zIHZhbG9yZXMgZGUgJGxfdCQsICRiX3QkIHkgJHNfe3QgKyAxIC0gbX0kPyBNZWRpYW50ZSBfX2V4cHJlc2lvbmVzIHJlY3Vyc2l2YXNfXywgZG9uZGUgY2FkYSBjb21wb25lbnRlIHNlIGNhbGN1bGEgYSBwYXJ0aXIgZGUgbG9zIHZhbG9yZXMgaGFzdGEgJHQkIGRlIGxhIHNlcmllIHkgZGUgbGFzIGNvbXBvbmVudGVzOgokJApcYmVnaW57YWxpZ25lZH0KbF90JiA9IGZfbCh5X3QseV97dC0xfVxsZG90cywgbF97dC0xfSxsX3t0LTJ9XGxkb3RzLGJfe3QtMX0sYl97dC0yfVxsZG90cyxzX3t0LTF9LHNfe3QtMn1cbGRvdHMpIFxcCmJfdCYgPSBmX2IoeV90LHlfe3QtMX1cbGRvdHMsIGxfe3R9LGxfe3QtMX1cbGRvdHMsYl97dC0xfSxiX3t0LTJ9XGxkb3RzLHNfe3QtMX0sc197dC0yfVxsZG90cykgXFwKc190JiA9IGZfcyh5X3QseV97dC0xfVxsZG90cywgbF97dH0sbF97dC0xfVxsZG90cyxiX3t0fSxiX3t0LTF9XGxkb3RzLHNfe3QtMX0sc197dC0yfVxsZG90cykKXGVuZHthbGlnbmVkfQokJApQb3IgZWplbXBsbywgZWwgX23DqXRvZG8gaW5nZW51byBJXyBzZSBwdWVkZSBpbnRlcnByZXRhciBkZW50cm8gZGUgZXN0ZSBjb250ZXh0byBjb21vIHVuIG3DqXRvZG8gZGUgYWxpc2FkbyBkb25kZSAkbF90ID0geV90JCB5IG5vIGhheSBuaSBwZW5kaWVudGUgbmkgZXN0YWNpb25hbGlkYWQuIFBvciB0YW50bywgJFx3aWRlaGF0e3l9X3tUKzF9ID0gbF97VH0gPSB5X3tUfSQuCgpEZSBsYSBtaXNtYSBmb3JtYSwgZWwgX23DqXRvZG8gaW5nZW51byBJSV8gc2UgcHVlZGUgaW50ZXJwcmV0YXIgY29tbyB1biBtw6l0b2RvIGRlIGFsaXNhZG8gZG9uZGUgJGxfdCA9IHlfdCQsICRiX3QgPSB5X3QgLSB5X3t0LTF9JCB5IG5vIGhheSBlc3RhY2lvbmFsaWRhZC4gRW50b25jZXMsICRcd2lkZWhhdHt5fV97VCsxfT1sX1QgKyBiX1QgPSB5X1QgKyAoeV9UIC0geV97VC0xfSkkLgogICAgCkVuIGxhcyBleHByZXNpb25lcyBwcmV2aWFzIGhlbW9zIHN1cHVlc3RvIHF1ZSBzZSBxdWVyw61hIG9idGVuZXIgdW5hIHByZWRpY2Npw7NuIGEgdW4gcGVyaW9kbyB2aXN0YSAoJFx3aWRlaGF0e3l9X3t0KzF9JCkuIFNpIGVsIG9iamV0aXZvIGVzIGVzdGltYXIgdW5hIHByZXZpc2nDs24gJGgkIHBlcmlvZG9zIGhhY2lhIGRlbGFudGUgZGVzZGUgZWwgcGVyaW9kbyAkdCQsICRcd2lkZWhhdHt5fV97dCtofSQsIGhheSBxdWUgcmVhbGl6YXIgYWxndW5hcyBtb2RpZmljYWNpb25lcy4gUG9yIGVqZW1wbG8sIHBhcmEgZWwgY2FzbyBhZGl0aXZvIHNlIHRlbmRyw61hIHF1ZSAKJCRcd2lkZWhhdHt5fV97dCtofSA9IGxfdCtoYl90K3Nfe3QraC1tKGsrMSl9JCQKZG9uZGUgJGsgPSBcbGZsb29yIChoLTEpL21ccmZsb29yJC4KCkVsIGNvbmNlcHRvIGRlIGNvbXBvbmVudGVzIGFxdcOtIHZpc3RvIG5vIGNvaW5jaWRlIGNvbiBlbCBkZWZpbmlkbyBlbiBlbCBUZW1hIDEuIFNpbiBlbWJhcmdvLCBwb2RlbW9zIGFzaW1pbGFyIGxhIHRlbmRlbmNpYSBkZSB1bmEgc2VyaWUgY29tbyBsYSBzdW1hIChtdWx0aXBsaWNhY2nDs24pIGRlbCBuaXZlbCB5IGxhIHBlbmRpZW50ZSAkVF97dCsxfSA9IGxfdCArIGJfdCQgKCRUX3t0KzF9ID0gbF90IFxjZG90IGJfdCQpIHkgZGUgZXN0YSBmb3JtYSBhbWJhcyBkZWZpbmljaW9uZXMgZGUgY29tcG9uZW50ZXMgZGUgdW5hIHNlcmllIHNlIGhhY2VuIGNvbXBhdGlibGVzLgoKXApcCgojIyBDYXNvcyBwb3NpYmxlcwoKVG9kYXMgbGFzIHNlcmllcyB0aWVuZSBuaXZlbCwgcGVybyBkZXBlbmRpZW5kbyBkZWwgdGlwbyBkZSBwZW5kaWVudGUgeSBlc3RhY2lvbmFsaWRhZCBoYXkgMTUgY2Fzb3MgcG9zaWJsZXMsIG1vc3RyYWRvcyBlbiBsYSB0YWJsYSBzaWd1aWVudGUuCgp8ICAgIFRlbmRlbmNpYSAgICAgICAgICB8ICAgICAgICAgICB8IEVzdGFjaW9uYWxpZGFkIHwgICAgICAgICAgICAgICAgICB8Cnw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tOnw6LS0tLS0tLS0tLS0tLS06fDotLS0tLS0tLS0tLS0tLS0tOnwKfCAgICAgICAgICAgICAgICAgICAgICAgfCBOaW5ndW5hIChOKSB8IEFkaXRpdmEgKEEpIHwgTXVsdGlwbGljYXRpdmEgKE0pICAgICAgICB8CnwgTmluZ3VuYSAoTikgICAgICAgICAgIHxfX04sIE5fXyAgIHwgICAgICAgTiwgQSAgICAgfCAgICAgICAgTiwgTSAgICAgIHwKfCBBZGl0aXZhIChBKSAgICAgICAgICAgfF9fQSwgTl9fICAgfCAgIF9fQSwgQV9fICAgICB8ICAgIF9fQSwgTV9fICAgICAgfAp8IEFkaXRpdmEgQW1vcnRpZ3VhZGEgKEFkKSAgfF9fQWQsIE5fXyAgfCAgICAgIEFkLCBBICAgICB8ICAgICAgIEFkLCBNICAgICAgfAp8IE11bHRpcGxpY2F0aXZhIChNKSAgICB8ICAgIE0sIE4gICB8ICAgICAgIE0sIEEgICAgIHwgICAgICAgIE0sIE0gICAgICB8CnwgTXVsdGlwbGljYXRpdmEgQW1vcnRpZ3VhZGEgKE1kKSB8ICAgIE1kLCBOICB8ICAgICAgTWQsIEEgICAgIHwgICAgICAgTWQsIE0gICAgICB8CgoKQ2FkYSBjYXNvIGRpZmllcmUgZW4gbGFzIGNvbXBvbmVudGVzIHF1ZSBzZSBvYnNlcnZhbiB5IHN1IGVzcXVlbWEsIGRhbmRvIGx1Z2FyIGEgdW4gY29uanVudG8gZGlmZXJlbnRlIGRlIGVjdWFjaW9uZXMgcmVjdXJzaXZhcyBkZSBhY3R1YWxpemFjacOzbi4KClNpIHNlIGHDsWFkZSBxdWUgZWwgZXJyb3IgcHVlZGUgc2VyIGFkaXRpdm8gbyBtdWx0aXBsaWNhdGl2bywgZGEgMzAgcG9zaWJpbGlkYWRlcy4gKipFbCB0aXBvIGRlIGVycm9yIChhZGl0aXZvIG8gbXVsdGlwbGljYXRpdm8pIG5vIGFmZWN0YSBuaSBhIGxhIGVzdGltYWNpw7NuIG5pIGEgbGEgcHJldmlzacOzbiBwdW50dWFsLCBzw7NsbyBlcyByZWxldmFudGUgZW4gZWwgY8OhbGN1bG8gZGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgbGFzIHByZWRpY2Npb25lcy4qKgoKTG9zIG1vZGVsb3MgbcOhcyB1c3VhbGVzIHNvbjoKCiogKE4sIE4pOiAgIEFsaXNhZG8gZXhwb25lbmNpYWwgc2ltcGxlCiogKEEsIE4pOiAgIEFsaXNhZG8gZGUgSG9sdAoqIChBZCwgTik6ICBBbGlzYWRvIGNvbiB0ZW5kZW5jaWEgYW1vcnRpZ3VhZGEgKGQgZGUgX2RhbXBlZF8pCiogKEEsIEEpOiAgIEFsaXNhZG8gZGUgSG9sdC1XaW50ZXJzIGFkaXRpdm8KKiAoQSwgTSk6ICAgQWxpc2FkbyBkZSBIb2x0LVdpbnRlcnMgbXVsdGlwbGljYXRpdm8KCkFjdWRlIGFsIGFydMOtY3VsbyBkZSBbUm9iIEouIEh5bmRtYW4geSBZZWFzbWluIEtoYW5kYWthciAoMjAwOCldKGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MjcvaTAzL3BhcGVyKSBwYXJhIHNhYmVyIG3DoXMgZGUgY2FkYSBtb2RlbG8sIG8gYWwgbGlicm8gX0ZvcmVjYXN0aW5nIHdpdGggRXhwb25lbnRpYWwgU21vb3RoaW5nOiB0aGUgU3RhdGUgU3BhY2UgQXBwcm9hY2hfICgyMDA4KSBkZSBIeW5kbWFuIHkgb3Ryb3MgYXV0b3Jlcy4KClwKCiMjIEFsaXNhZG8gZXhwb25lbmNpYWwgc2ltcGxlIChOLCBOKQoKIyMjIERlZmluaWNpw7NuIHstfQoKRWwgYWxpc2FkbyBleHBvbmVuY2lhbCBzaW1wbGUgZXMgYWRlY3VhZG8gcGFyYSB1bmEgc2VyaWUgZXN0YWNpb25hcmlhIHkgc2luIGVzdGFjaW9uYWxpZGFkLiBFcyBkZWNpciwgdW5hIHNlcmllIHF1ZSBzZSBtdWV2ZSBhbHJlZGVkb3IgZGUgdW4gbml2ZWwgY29uc3RhbnRlLgoKTGEgZWN1YWNpw7NuIGRlIGxhIF9fcHJlZGljY2nDs24gaW50cmEtbXVlc3RyYWxfXyBlcyAKJCRcaGF0e3l9X3t0KzF9ID0gXGFscGhhIHlfdCArIFxhbHBoYSAoMS1cYWxwaGEpIHlfe3QtMX0gKyBcYWxwaGEgKDEtXGFscGhhKV4yIHlfe3QtMn0gKyBcYWxwaGEgKDEtXGFscGhhKV4zIHlfe3QtM30gKyBcbGRvdHMgPSAgXGFscGhhIHlfdCArICgxLVxhbHBoYSlcaGF0e3l9X3t0fSwkJApkb25kZSAkMCBcbGVxIFxhbHBoYSBcbGVxIDEkIGVzIGVsIHBhcsOhbWV0cm8gZGUgc3Vhdml6YWRvLiBMYSBwcmltZXJhIF9fcHJlZGljY2nDs24gZXh0cmEtbXVlc3RyYWxfXyBxdWVkYSAKJCRcaGF0e3l9X3tUKzF9PVxhbHBoYSB5X1QgKyAoMS1cYWxwaGEpXGhhdHt5fV97VH0kJAp5IHBhcmEgbGFzIHJlc3RhbnRlcwokJFxoYXR7eX1fe1QraH0gPSBcaGF0e3l9X3tUKzF9LiQkCgojIyMgRm9ybXVsYXMgaW50ZXJhY3RpdmFzIGRlIHN1cyBjb21wb25lbnRlcyB7LX0KCkVuIGVsIGFsaXNhZG8gZXhwb25lbmNpYWwgc2ltcGxlIHNvbG8gaGF5IHVuYSBjb21wb25lbnRlLCBlbCBuaXZlbCAkbF90JC4KCiogTGEgX19lY3VhY2nDs24gcmVjdXJzaXZhX18gZGUgc3Vhdml6YWRvIGVzICRsX3Q9XGFscGhhIHlfdCArICgxLVxhbHBoYSlsX3t0LTF9JAoqIExhIGVjdWFjacOzbiBkZSBfX3ByZWRpY2Npw7NuIGludHJhLW11ZXN0cmFsX18gZXMgJFxoYXR7eX1fe3QrMX0gPSBsX3QkCiogTGEgZWN1YWNpw7NuIGRlIF9fcHJlZGljY2nDs24gZXh0cmEtbXVlc3RyYWxfXyBlcyAkXGhhdHt5fV97VCtofSA9IFxoYXR7eX1fe1QrMX0gPSBsX1QkCgpEb3MgZXN0aW1hY2lvbmVzIHJhem9uYWJsZXMgZGUgJGxfdCQsIGVsIG5pdmVsIGRlIGxhIHNlcmllIGVuIGVsIHBlcmlvZG8gJHQkLCBzb24gZWwgdmFsb3Igb2JzZXJ2YWRvIHBhcmEgbGEgc2VyaWUgZW4gZXNlIHBlcmlvZG8gJHlfdCQgeSBlbCBuaXZlbCBkZWwgcGVyaW9kbyBwcmV2aW8gJGxfe3QtMX0kLiBMYSBlc3RpbWFjacOzbiBmaW5hbCBkZSAkbF90JCBlcyB1bmEgbWVkaWEgcG9uZGVyYWRhIGRlIGFtYmFzIHkgZXN0YSBlc3RpbWFjacOzbiBmaW5hbCBlcyBsYSBwcmV2aXNpw7NuIGRlIGxhIHNlcmllIHBhcmEgZWwgcGVyaW9kbyBzaWd1aWVudGUuIAoKIyMjIEVzdGltYWNpw7NuIGRlIGxvcyBwYXLDoW1ldHJvcyBkZWwgbW9kZWxvIHstfQogICAgCkRhZG8gZWwgcHJvY2VzbyBpdGVyYXRpdm8gcGFyYSBlbCBjw6FsY3VsbyBkZSAkbF90JCBzZSBuZWNlc2l0YSB1biBfX3ZhbG9yIGluaWNpYWxfXyBkZSBhcnJhbnF1ZSAkbF8wJC4gQ2FkYSBwcm9ncmFtYSBlc3RhZMOtc3RpY28gdXNhIHN1IHByb3BpbyBtw6l0b2RvIHBhcmEgb2J0ZW5lciAkbF8wJC4KICAgIApSZXNwZWN0byBkZSAkXGFscGhhJCwgdXN1YWxtZW50ZSBzZSBlc3RpbWEgZWwgdmFsb3IgX19vcHRpbW9fXyBzZWfDum4gdW4gY3JpdGVyaW8gZGUgcHJlY2lzacOzbiBkZSBsYSBwcmVkaWNjacOzbi4gRWwgcGFyw6FtZXRybyAkXGFscGhhJCBfX3NlIHB1ZWRlIGludGVycHJldGFyX18gY29tbzoKCiogU2kgJFxhbHBoYSA9IDEkIHNlIHRpZW5lIGVsIF9tw6l0b2RvIGluZ2VudW8gSV8gKCRcaGF0e3l9X3t0KzF9PXlfdCQpLCDDs3B0aW1vIGN1YW5kbyBlbCBuaXZlbCBkZSBsYSBzZXJpZSB2YXLDrWEgY29uc3RhbnRlbWVudGUgZW4gZWwgdGllbXBvLgoqIFNpICRcYWxwaGEgPSAwJCBzZSB0aWVuZSAkXGhhdHt5fV97dH0gPWxfMCQsIMOzcHRpbW8gY3VhbmRvIGVsIG5pdmVsIHBlcm1hbmVjZSBjb25zdGFudGUgZW4gZWwgdGllbXBvLgoKIyMjIEVqZW1wbG8gey19CgpWYW1vcyBhIHVzYXIgZWwgbcOpdG9kbyBkZSBhbGlzYWRvIGV4cG9uZW5jaWFsIHNpbXBsZSBwYXJhIHByZWRlY2lyIGxhIHNlcmllIExpYnJvcy4gVXNhcmVtb3MgcGFyYSBlbGxvIGxhIGZ1bmNpw7NuIGBzZXNgIChfc2ltcGxlIGV4cG9uZW50aWFsIHNtb290aGluZ18pIGNvbiB1bmEgcHJldmlzacOzbiBhIDUgYcOxb3MgdmlzdGEgKGBoID0gNWApLiBFc3RhIGZ1bmNpw7NuIGVzdGltYSBsb3MgdmFsb3JlcyBkZSAkbF8wJCB5ICRcYWxwaGEkIHF1ZSBtYXhpbWl6YW4gbGEgZnVuY2nDs24gZGUgdmVyb3NpbWlsaXR1ZCwgcGVybyBzZSBwdWVkZW4gZWxlZ2lyIG90cm9zIGNyaXRlcmlvcyBjb24gZWwgcGFyw6FtZXRybyBgb3B0LmNyaXRgLgoKYGBge3J9CmxpYnJvc2YgPC0gc2VzKGxpYnJvcywgaCA9IDUsIGxldmVsID0gOTUpCnN1bW1hcnkobGlicm9zZikKYGBgCgpWZWFtb3MgbGEgc2FsaWRhIGVuIGRldGFsbGU6CgoqIEVsIHZhbG9yIGRlICRcYWxwaGEkIHF1ZSBvcHRpbWl6YSBlbCBjcml0ZXJpbyB1c2FkbyBwYXJhIG1lZGlyIGxhIGNhbGlkYWQgZGVsIGFqdXN0ZSBlcyAkXGFscGhhID0kIGByIHJvdW5kKGxpYnJvc2YkbW9kZWwkcGFyWzFdLDIpYCwgdW4gdmFsb3IgbXV5IGNlcmNhbm8gYSAxLiBFc3RvIGVzIHVuIGluZGljYXRpdm8gZGUgcXVlOiBpKSBsYSBzZXJpZSBMaWJyb3MgY2FtYmlhIGRlIG5pdmVsIGRlIGZvcm1hIGNvbnN0YW50ZSwgdW4gcmFzZ28gZW4gbG9zIHByb2Nlc29zIHB1cmFtZW50ZSBlc3RvY8Ohc3RpY29zIGNvbW8gZWwgcGFzZW8gYWxlYXRvcmlvOyBpaSkgeSBlbCBtw6l0b2RvIGRlIGFsaXNhZG8gZXhwb25lbmNpYWwgc2ltcGxlIHNlIGFwcm94aW1hIGFsIG3DqXRvZG8gSW5nZW51byBJLiAKKiBFbCB2YWxvciBkZSBhcnJhbnF1ZSAkbF8wJCDDs3B0aW1vIGVzIGByIHJvdW5kKGxpYnJvc2YkbW9kZWwkcGFyWzJdLDIpYC4gCiogX3NpZ21hXyBlcyBsYSBkZXN2aWFjacOzbiB0w61waWNhIGRlbCBlcnJvciAoYWRpdGl2bykgZGUgcHJlZGljY2nDs24uIFNlIGRpZmVyZW5jaWEgZGUgUk1TRSBlbiBlbCBkZW5vbWluYWRvci4gUGFyYSBjYWxjdWxhciBzaWdtYSBlbiBsdWdhciBkZSBkaXZpZGlyIHBvciAkVCQgc2UgZGl2aWRlIHBvciAkVCQgbWVub3MgZWwgbsO6bWVybyBkZSBwYXLDoW1ldHJvcyBlc3RpbWFkb3MgKGVuIGVzdGUgY2FzbyAzLCAkbF8wJCwgJFxhbHBoYSQgeSBfc2lnbWFfKS4KKiBMYSBjYWxpZGFkIGRlIGFqdXN0ZSBlcyByYXpvbmFibGUsIGNvbW8gZXZpZGVuY2lhIGVsIGVycm9yIHBvcmNlbnR1YWwgbWVkaW8gZGVsIDclLgoqIExhcyBwcmVkaWNjaW9uZXMgc29uIGxhcyBtaXNtYXMgcGFyYSBsb3MgNSBhw7FvcywgY29tbyBjYWJlIGVzcGVyYXIgKHJlY3VlcmRhIHF1ZSAkXGhhdHt5fV97VCtofSA9IFxoYXR7eX1fe1QrMX0kKS4KCmBgYHtyfQp0YWlsKGxpYnJvc2YkbW9kZWwkc3RhdGVzLCBuID0gNCkKYGBgCgpFbiBlbCBvYmpldG8gYGxpYnJvc2ZgIGxhIG1hdHJpeiBgbGlicm9zZiRtb2RlbCRzdGF0ZXNgIGd1YXJkYSB0b2RvcyBsb3MgdmFsb3JlcyBkZWwgbml2ZWwgb2J0ZW5pZG9zIGNvbiBsYSBlY3VhY2nDs24gcmVjdXJzaXZhLCBpbmNsdWlkb3MgZWwgdmFsb3IgZGUgYXJyYW5xdWUsIGFzw60gcXVlIGVzIHVuYSBtYXRyaXogY29uICRUKzEkIGZpbGFzLiBQdWVkZXMgdmVyIGVsIHZhbG9yIGRlICRsX3syMDE4fSQgZW4gc3Ugw7psdGltYSBmaWxhLCBxdWUgdmFsZSBgciBmb3JtYXRDKGxpYnJvc2YkbW9kZWwkc3RhdGVzWzI3LF0sIGZvcm1hdCA9ICJmIiwgZGlnaXRzID0gMilgLiBBc8OtLCBsYSBwcmVkaWNjacOzbiBwYXJhICQyMDE5JCBlcyAkXHdpZGVoYXR7eX1fezIwMTl9PWxfezIwMTh9PSQgYHIgZm9ybWF0QyhsaWJyb3NmJG1vZGVsJHN0YXRlc1syNyxdLCBmb3JtYXQgPSAiZiIsIGRpZ2l0cyA9IDIpYC4gSWd1YWxtZW50ZSAkXHdpZGVoYXR7eX1fezIwMjB9PWxfezIwMTh9PSQgYHIgZm9ybWF0QyhsaWJyb3NmJG1vZGVsJHN0YXRlc1syNyxdLCBmb3JtYXQgPSAiZiIsIGRpZ2l0cyA9IDIpYC4gRXMgZGVjaXIsIHRvZGFzIGxhcyBwcmV2aXNpb25lcyBzb24gaWd1YWxlcyBhICRsX3syMDE4fSQuCgpMYSBmaWd1cmEgNiBtdWVzdHJhIGxhIHNlcmllIExpYnJvcyB5IGxhcyBwcmV2aXNpb25lcyBleHRyYS1tdWVzdHJhbGVzLCBxdWUgc29uIGNvbnN0YW50ZXMsIHkgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YS4gQ29uZm9ybWUgYXVtZW50YW1vcyBlbCBob3Jpem9udGUgZGUgcHJlZGljY2nDs24sIGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZXMgbcOhcyBhbXBsaW8gY29tbyByZWZsZWpvIGRlIGxhIG1heW9yIGluY2VydGlkdW1icmUgZW4gbGEgcHJlZGljY2nDs24uCiAKYGBge3J9CmF1dG9wbG90KGxpYnJvc2YsCiAgICAgICAgIHhsYWIgPSAiIiwKICAgICAgICAgeWxhYiA9ICJUw610dWxvcyIsCiAgICAgICAgIG1haW4gPSAiRmlndXJhIDYuIExpYnJvcyB5IHByZWRpY2Npw7NuIGNvbiBhbGlzYWRvIHNpbXBsZSIpCmBgYAoKXAoKIyMgQWxpc2FkbyBleHBvbmVuY2lhbCBkZSBIb2x0IChBLCBOKQoKRWwgYWxpc2FkbyBleHBvbmVuY2lhbCBkZSBIb2x0IGVzIGFkZWN1YWRvIHBhcmEgdW5hIHNlcmllIG5vIGVzdGFjaW9uYXJpYSB5IHNpbiBlc3RhY2lvbmFsaWRhZC4KCiMjIyBGb3JtdWxhcyBpbnRlcmFjdGl2YXMgZGUgc3VzIGNvbXBvbmVudGVzIHstfQoKTGFzIF9fZWN1YWNpb25lcyByZWN1cnNpdmFzX18gc29uCiQkClxiZWdpbnthbGlnbmVkfQpsX3QgJiA9XGFscGhhIHlfdCArICgxLVxhbHBoYSkobF97dC0xfStiX3t0LTF9KSBcXApiX3QgJiA9XGJldGEgKGxfdCAtIGxfe3QtMX0pICsgKDEtXGJldGEpYl97dC0xfSAKXGVuZHthbGlnbmVkfQokJApMYSBlY3VhY2nDs24gZGUgbGEgX19wcmVkaWNjacOzbiBpbnRyYS1tdWVzdHJhbF9fIGEgdW4gcGVyaW9kbyB2aXN0YSBlcwokJFxoYXR7eX1fe3QrMX0gPSBsX3QgKyBiX3QsJCQKXG5vaW5kZW50IGRlIGZvcm1hIHF1ZSBsYSBlY3VhY2nDs24gZGUgX19wcmVkaWNjacOzbiBleHRyYS1tdWVzdHJhbF9fIGVzIAokJFxoYXR7eX1fe1QraH09bF9UICsgaCBiX1QuJCQgCiAKRG9zIGVzdGltYWNpb25lcyByYXpvbmFibGVzIGRlbCBuaXZlbCBkZSBsYSBzZXJpZSBlbiBlbCBwZXJpb2RvICR0JCBzb24gZWwgdmFsb3Igb2JzZXJ2YWRvIHBhcmEgbGEgc2VyaWUgZW4gZXNlIHBlcmlvZG8gJHlfdCQsIHkgdW5hIGVzdGltYWNpw7NuIGRlbCBuaXZlbCBkZWwgcGVyaW9kbyAkdCQgcmVhbGl6YWRhIGRlc2RlIGVsIHBlcmlvZG8gJHQtMSQ6ICRsX3t0LTF9ICsgYl97dC0xfSQuIFBvciBvdHJvIGxhZG8sIGRvcyBlc3RpbWFjaW9uZXMgcmF6b25hYmxlcyBkZSBsYSBwZW5kaWVudGUgZGUgbGEgc2VyaWUgZW4gZWwgcGVyaW9kbyAkdCQgc29uIGVsIMO6bHRpbW8gY2FtYmlvIGRlIG5pdmVsIG9ic2VydmFkbyAkbF90LWxfe3QtMX0kLCB5IGVsIHZhbG9yIGRlIGxhIHBlbmRpZW50ZSBlbiBlbCBwZXJpb2RvIHByZXZpbywgJGJfe3QtMX0kLiBFbiBhbWJvcyBjYXNvcywgbml2ZWwgeSBwZW5kaWVudGUsIGxhIGVzdGltYWNpw7NuIGZpbmFsIGVzIHVuYSBtZWRpYSBwb25kZXJhZGEsIHBhcmFtZXRyaXphZGEgcG9yICQwIFxsZXEgXGFscGhhLCBcOiBcYmV0YSBcbGVxIDEkLgoKIyMjIEVzdGltYWNpw7NuIGRlIGxvcyBwYXLDoW1ldHJvcyBkZWwgbW9kZWxvIHstfQoKUGFyYSBhcGxpY2FyIGVzdGUgbcOpdG9kbyBlcyBuZWNlc2FyaW8gZXN0aW1hciB1bm9zIHZhbG9yZXMgaW5pY2lhbGVzICRsXzAkIHkgJGJfMCQgZGUgbGFzIGVjdWFjaW9uZXMgcmVjdXJzaXZhcyBlIGlkZW50aWZpY2FyIGxvcyB2YWxvcmVzIG3DoXMgYWRlY3VhZG9zIGRlIGxvcyBwYXLDoW1ldHJvcyAkXGFscGhhJCB5ICRcYmV0YSQuIExvcyBfX3ZhbG9yZXMgw7NwdGltb3NfXyBkZSBlc3RvcyBjdWF0cm8gcGFyw6FtZXRyb3Mgc2Ugb2J0aWVuZW4gb3B0aW1pemFuZG8gdW5hIG1lZGlkYSBkZSBwcmVjaXNpw7NuIGRlIGxhcyBwcmVkaWNjaW9uZXMuCgpMYSBpbnRlcnByZXRhY2nDs24gZGVsIHBhcsOhbWV0cm8gJFxhbHBoYSQgZXMgc2ltaWxhciBhbCBjYXNvIGRlbCBhbGlzYWRvIGV4cG9uZW5jaWFsIHNpbXBsZS4KCl9fSW50ZXJwcmV0YWNpw7NuIGRlbCBwYXLDoW1ldHJvICRcYmV0YSRfXzoKCiogU2kgJFxiZXRhID0gMSQsICRiX3QgID0gbF90IC0gbF97dC0xfSQsIGxhIHBlbmRpZW50ZSBzZSBhY3R1YWxpemEgY29uc3RhbnRlbWVudGUgcG9ycXVlIHZhcsOtYSBwZXJpb2RvIGEgcGVyaW9kbyBQdWVkZSBzZXIgdW4gaW5kaWNhZG9yIGRlIG1hbCBhanVzdGUgKHRlbmRlbmNpYSBubyBsaW5lYWwgbyBwZW5kaWVudGUgbm8gYWRpdGl2YSkuCiogU2kgJFxiZXRhID0gMCQsICRiX3QgPSBiX3t0LTF9PSBcbGRvdHMgPSBiXzAkLCBsYSBwZW5kaWVudGUgc2UgbWFudGllbmUgY29uc3RhbnRlIGVuIGVsIHRpZW1wby4KCkVsIF9tw6l0b2RvIGluZ2VudW8gSUlfIGVzIHVuIGNhc28gY29uY3JldG8gZGUgQWxpc2FkbyBkZSBIb2x0LiBTaSBoYWNlbW9zICRcYWxwaGE9XGJldGEgPSAxJCwgcXVlZGEgJGxfdD15X3QkIHkgJGJfdD15X3QteV97dC0xfSQsIHBvciB0YW50bwokJFxoYXR7eX1fe1QraH09bF9UICsgaCBcY2RvdCBiX1QgPSB5X1QgKyBoKHlfVCAtIHlfe1QtMX0pLiQkCgojIyMgRWplbXBsbyB7LX0KClZhbW9zIGEgdXNhciBlbCBtw6l0b2RvIGRlIGFsaXNhZG8gZGUgSG9sdCBwYXJhIHByZWRlY2lyIGRlIG51ZXZvIGxhIHNlcmllIExpYnJvcy4gVXNhcmVtb3MgcGFyYSBlbGxvIGxhIGZ1bmNpw7NuIGBob2x0YCBjb24gdW5hIHByZXZpc2nDs24gYSA1IGHDsW9zIHZpc3RhIChgaCA9IDVgKS4KCmBgYHtyfQpsaWJyb3NmIDwtIGhvbHQobGlicm9zLCBoID0gNSwgbGV2ZWwgPSA5NSkKc3VtbWFyeShsaWJyb3NmKQpgYGAKCkxvcyB2YWxvcmVzIMOzcHRpbW9zIGRlIGxvcyBjdWF0cm8gcGFyw6FtZXRyb3Mgc29uICRcYWxwaGE9JCBgciByb3VuZChsaWJyb3NmJG1vZGVsJHBhclsxXSwyKWAsICRcYmV0YT0kIGByIHJvdW5kKGxpYnJvc2YkbW9kZWwkcGFyWzJdLDIpYCwgJGxfMCA9JCBgciByb3VuZChsaWJyb3NmJG1vZGVsJHBhclszXSwyKWAgeSAkYl8wID0kIGByIHJvdW5kKGxpYnJvc2YkbW9kZWwkcGFyWzRdLDIpYC4gT2JzZXJ2YSBxdWUgJFxhbHBoYSQgZXMgcHLDoWN0aWNhbWVudGUgMSB5IHF1ZSAkXGJldGEkIGVzIGNlcm8uIFNpIGFwbGljYW1vcyBlc3RvcyB2YWxvcmVzIGRlIGxvcyBwYXLDoW1ldHJvcyBhIGxhcyBlY3VhY2lvbmVzIHJlY3Vyc2l2YXMgeSBsYSBwcmVkaWNjacOzbiBleHRyYS1tdWVzdHJhbCwgb2J0ZW5lbW9zICR5X3tUK2h9PXlfVCArIGhiXzAkOiBsYSBwcmVkaWNjacOzbiBlcyBlbCDDumx0aW1vIHZhbG9yIG9ic2VydmFkbyBtw6FzIGxhIHByaW1lcmEgcGVuZGllbnRlIGVzdGltYWRhLgoKTGEgY2FsaWRhZCBkZSBsYXMgcHJlZGljY2lvbmVzIGVzIHJhem9uYWJsZSwgY29uIHVuIGVycm9yIHBvcmNlbnR1YWwgbWVkaW8gZGVsIDYuNyUsIHkgc2UgaGEgbWVqb3JhZG8gcmVzcGVjdG8gZGVsIGFsaXNhZG8gZXhwb25lbmNpYWwgc2ltcGxlLgoKYGBge3J9CnRhaWwobGlicm9zZiRtb2RlbCRzdGF0ZXMsIG4gPSA0KQpgYGAKCkRlIG51ZXZvLCBlbiBlbCBvYmpldG8gYGxpYnJvc2ZgIGxhIG1hdHJpeiBgbGlicm9zZiRtb2RlbCRzdGF0ZXNgIGd1YXJkYSB0b2RvcyBsb3MgdmFsb3JlcyBvYnRlbmlkb3MgY29uIGxhcyBlY3VhY2lvbmVzIHJlY3Vyc2l2YXMsIGVuIGVzdGUgY2FzbyBlbCBuaXZlbCB5IGxhIHBlbmRpZW50ZSwgaW5jbHVpZG9zIGxvcyB2YWxvcmVzIGRlIGFycmFucXVlLiBQdWVkZXMgdmVyIGxvcyB2YWxvcmVzIGRlICRsX3syMDE4fSQgeSAkYl97MjAxOH0kIGVuIHN1IMO6bHRpbWEgZmlsYSwgcXVlIHZhbGVuIHJlc3BlY3RpdmFtZW50ZSBgciBmb3JtYXRDKGxpYnJvc2YkbW9kZWwkc3RhdGVzWzI3LF0sIGZvcm1hdCA9ICJmIiwgZGlnaXRzID0gMilgLiBBc8OtLCBsYSBwcmVkaWNjacOzbiBwYXJhICQyMDE5JCBlcyAkXHdpZGVoYXR7eX1fezIwMTl9PWxfezIwMTh9ICsgYl97MjAxOH09JCBgciBmb3JtYXRDKGxpYnJvc2YkbW9kZWwkc3RhdGVzWzI3LCAxXSwgZm9ybWF0ID0gImYiLCBkaWdpdHMgPSAyKWAgJCskIGByIGZvcm1hdEMobGlicm9zZiRtb2RlbCRzdGF0ZXNbMjcsIDJdLCBmb3JtYXQgPSAiZiIsIGRpZ2l0cyA9IDIpYCAkPSQgYHIgZm9ybWF0QyhzdW0obGlicm9zZiRtb2RlbCRzdGF0ZXNbMjcsXSksIGZvcm1hdCA9ICJmIiwgZGlnaXRzID0gMilgLiBJZ3VhbG1lbnRlICRcd2lkZWhhdHt5fV97MjAyMH09bF97MjAxOH0gKyAyXGNkb3QgYl97MjAxOH09JCBgciBmb3JtYXRDKGxpYnJvc2YkbW9kZWwkc3RhdGVzWzI3LDFdICsgMiogbGlicm9zZiRtb2RlbCRzdGF0ZXNbMjcsMl0sIGZvcm1hdCA9ICJmIiwgZGlnaXRzID0gMilgLiBFcyBkZWNpciwgZWwgaW5jcmVtZW50byBlbnRyZSBwcmV2aXNpb25lcyBlcyBjb250YW50ZSBlIGlndWFsIGEgJGJfezIwMTh9JCBxdWUsIHBvciBzZXIgJFxiZXRhJCBwcsOhY3RpY2FtZW50ZSBudWxvLCBjb2luY2lkZSBjb24gJGJfMCQuCgpMYSBmaWd1cmEgNyBtdWVzdHJhIGxhIHNlcmllIExpYnJvcyB5IGxhcyBwcmV2aXNpb25lcyBleHRyYS1tdWVzdHJhbGVzIHF1ZSBtdWVzdHJhbiB1bmEgbGlnZXJhIHRlbmRlbmNpYSBjcmVjaWVudGUuCiAKYGBge3J9CmF1dG9wbG90KGxpYnJvc2YsCiAgICAgICAgIHhsYWIgPSAiIiwKICAgICAgICAgeWxhYiA9ICJUw610dWxvcyIsCiAgICAgICAgIG1haW4gPSAiRmlndXJhIDcuIExpYnJvcyB5IHByZWRpY2Npw7NuIGNvbiBhbGlzYWRvIGRlIEhvbHQiKQpgYGAKClwKCiMjIEFsaXNhZG8gZXhwb25lbmNpYWwgY29uIHBlbmRpZW50ZSBhbW9ydGlndWFkYSAoQWQsIE4pCgpMYXMgcHJldmlzaW9uZXMgY29uIGVsIG3DqXRvZG8gZGUgSG9sdCBwcmVzZW50YW4gc2llbXByZSB1bmEgcGVuZGllbnRlIGNvbnN0YW50ZS4gRW4gcHJldmlzaW9uZXMgYSBjb3J0byBwbGF6byBlc3RvIG5vIGVzIHVuIHByb2JsZW1hLCBwZXJvIHBhcmEgcHJldmlzaW9uZXMgYSBsYXJnbyBwbGF6byBsYSBleHBlcmllbmNpYSBpbmRpY2EgcXVlIHN1ZWxlIGFwYXJlY2VyIHVuIHNlc2dvIGRlIHByZXZpc2nDs24uIEVsIGFsaXNhZG8gZXhwb25lbmNpYWwgY29uIHBlbmRpZW50ZSBhbW9ydGlndWFkYSB0cmF0YSBkZSBjb3JyZWdpciBlc3RhIGxpbWl0YWNpw7NuLiBFbCBtZWNhbmlzbW8sIHByb3B1ZXN0byBwb3IgR2FyZG5lciB5IE1jS2VuemllIGVuIDE5ODUsIGVzIGludHJvZHVjaXIgdW4gbnVldm8gcGFyw6FtZXRybyAkMCBcbGVxIFxwaGkgXGxlcSAxJCBxdWUgX2Ftb3J0aWd1YV8gbGEgdGVuZGVuY2lhIGhhc3RhIGhhY2VybGEgcGxhbmEgZW4gZWwgbGFyZ28gcGxhem8uCgoKIyMjIEZvcm11bGFzIGludGVyYWN0aXZhcyBkZSBzdXMgY29tcG9uZW50ZXMgey19CgpMYXMgX19lY3VhY2lvbmVzIHJlY3Vyc2l2YXNfXyBzb24KJCQKXGJlZ2lue2FsaWduZWR9CmxfdCAmID1cYWxwaGEgeV90ICsgKDEtXGFscGhhKShsX3t0LTF9K1xwaGkgYl97dC0xfSkgXFwKYl90ICYgPVxiZXRhIChsX3QgLSBsX3t0LTF9KSArICgxLVxiZXRhKVxwaGkgYl97dC0xfSAKXGVuZHthbGlnbmVkfQokJApMYSBlY3VhY2nDs24gZGUgbGEgX19wcmVkaWNjacOzbiBpbnRyYS1tdWVzdHJhbF9fIGEgdW4gcGVyaW9kbyB2aXN0YSBlcwokJFxoYXR7eX1fe3QrMX0gPSBsX3QgKyBccGhpIGJfdCwkJApcbm9pbmRlbnQgZGUgZm9ybWEgcXVlIGxhIGVjdWFjacOzbiBkZSBfX3ByZWRpY2Npw7NuIGV4dHJhLW11ZXN0cmFsX18gZXMgCiQkXGhhdHt5fV97VCtofT1sX1QgKyAoXHBoaSArIFxwaGleMiArIFxsZG90cyArIFxwaGleaCkgYl9ULiQkIAogClNpICRccGhpID0gMSQgc2UgdGllbmUgZWwgYWxpc2FkbyBkZSBIb2x0IHkgc2kgJFxwaGkgPSAwJCBzZSB0aWVuZSBlbCBhbGlzYWRvIHNpbXBsZS4gUGFyYSB2YWxvcmVzIGVudHJlICQwJCB5ICQxJCBlbiBlbCBjb3J0byBwbGF6byBsYXMgcHJlZGljY2lvbmVzIHRpZW5lbiBwZW5kaWVudGUgeSBlbiBlbCBsYXJnbyBwbGF6byBzZSBoYWNlbiBjb25zdGFudGVzIGUgaWd1YWxlcyBhICRsX1QgKyBccGhpIGJfVC8oMSAtIFxwaGkpJC4KCiMjIyBFamVtcGxvIHstfQoKVmFtb3MgYSB1c2FyIGVsIG3DqXRvZG8gZGUgYWxpc2FkbyBjb24gYW1vcnRpZ3VhbWllbnRvIHBhcmEgcHJlZGVjaXIsIHVuYSB2ZXogbcOhcywgbGEgc2VyaWUgTGlicm9zIGHDsWFkaWVuZG8gYSBsYSBmdW5jacOzbiBgaG9sdGAgZWwgYXJndW1lbnRvIGBkYW1wZWQgPSBUUlVFYC4gUG9yIHJhem9uZXMgcHLDoWN0aWNhcyBlbCByYW5nbyBkZSBiw7pzcXVlZGEgZGUgJFxwaGkkIHF1ZWRhIGVuIGVsIGludGVydmFsbyAkWzAuOCwgMC45OF0kLiBFbiBlc3RlIGNhc28sIHBhcmEgdmVyIGVsIGVmZWN0byBkZWwgX2Ftb3J0aWd1YW1pZW50b18gdmFtb3MgYSBmaWphciBlbCB2YWxvciBkZSAkXHBoaSQgYSAkMC45JCB5IHZhbW9zIGEgcGVkaXIgdW4gaG9yaXpvbnRlIHRlbXBvcmFsIG3DoXMgbGFyZ28uCgpgYGB7cn0KbGlicm9zZmQgPC0gaG9sdChsaWJyb3MsIGRhbXBlZCA9IFRSVUUsIGggPSAxNSwgcGhpID0gMC45KQpzdW1tYXJ5KGxpYnJvc2ZkKQpgYGAKCkxhIGZpZ3VyYSA4IG11ZXN0cmEgbGEgc2VyaWUgTGlicm9zLCBzdSBlc3RpbWFjacOzbiAoaW50cmEtbXVlc3RyYWwpIHkgbGFzIHByZWRpY2Npb25lcyBhIDE1IGHDsW9zIHZpc3RhLiBPYnNlcnZhIHF1ZSBsYSBwZW5kaWVudGUgZGUgbGFzIHByZXZpc2lvbmVzIHNlIF9hbW9ydGlndWFfIGVuIGVsIHRpZW1wbywgZGUgZm9ybWEgcXVlIGFsIHByaW5jaXBpbyBsYXMgcHJldmlzaW9uZXMgY3JlY2VuIG3DoXMgcsOhcGlkYW1lbnRlIHF1ZSBlbiBsb3Mgw7psdGltb3MgYcOxb3MuCiAKYGBge3J9CmF1dG9wbG90KGxpYnJvc2ZkLAogICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgIHlsYWIgPSAiVMOtdHVsb3MiLAogICAgICAgICBtYWluID0gIkZpZ3VyYSA4LiBMaWJyb3MgeSBwcmVkaWNjacOzbiBjb24gYWxpc2FkbyBleHBvbmVuY2lhbCBjb24gYW1vcnRpZ3VhbWllbnRvIiwKICAgICAgICAgUEkgPSBGQUxTRSkKYGBgCgpcCgojIyBBbGlzYWRvIGRlIEhvbHQtV2ludGVycyBhZGl0aXZvIChBLCBBKSB5IG11bHRpcGxpY2F0aXZvIChBLCBNKQoKRWwgbcOpdG9kbyBkZSBhbGlzYWRvIGV4cG9uZW5jaWFsIGRlIEhvbHQtV2ludGVycyBlcyBhZGVjdWFkbyBwYXJhIHVuYSBzZXJpZSBjb24gdGVuZGVuY2lhIHkgY29uIGVzdGFjaW9uYWxpZGFkLiBFeGlzdGVuIGRvcyB2ZXJzaW9uZXMgc2Vnw7puIHF1ZSBlbCBlc3F1ZW1hIHNlYSBhZGl0aXZvIG8gbXVsdGlwbGljYXRpdm8uCgojIyMgQWxpc2FkbyBkZSBIb2x0LVdpbnRlcnMgYWRpdGl2byAoQSwgQSkgey19CgpMYXMgX19lY3VhY2lvbmVzIHJlY3Vyc2l2YXNfXyBkZSBhY3R1YWxpemFjacOzbiBzb246CiQkClxiZWdpbnthbGlnbmVkfQpsX3QgJiA9XGFscGhhICh5X3QgLSBzX3t0LW19ICkgKyAoMS1cYWxwaGEpKGxfe3QtMX0rYl97dC0xfSkgXFwKYl90ICYgPVxiZXRhIChsX3QgLSBsX3t0LTF9KSArICgxLVxiZXRhKWJfe3QtMX0gXFwKc190ICYgPVxnYW1tYSAoeV90IC0gbF97dC0xfSAtIGJfe3QtMX0pICsgKDEgLSBcZ2FtbWEpc197dC1tfQpcZW5ke2FsaWduZWR9CiQkCmNvbiAkMCBcbGVxIFxhbHBoYSwgXGJldGEsIFxnYW1tYSBcbGVxIDEkLgoKTGEgZWN1YWNpw7NuIGRlIGxhIF9fcHJlZGljY2nDs24gaW50cmEtbXVlc3RyYWxfXyBhIHVuIHBlcmlvZG8gdmlzdGEgZXMgCiQkXGhhdHt5fV97dCsxfSAgPSBsX3QgKyBiX3QgKyBzX3t0KzEtbX0sJCQKXG5vaW5kZW50IGRlIGZvcm1hIHF1ZSBsYSBlY3VhY2nDs24gZGUgX19wcmVkaWNjacOzbiBleHRyYS1tdWVzdHJhbCBlc19fOgokJFxoYXR7eX1fe1QraH09bF9UICsgaCBiX1QgKyBzX3tUK2ggLSBtKGsrMSl9LCQkIApcbm9pbmRlbnQgY29uICRrID0gXGxmbG9vcihoLTEpL21ccmZsb29yJC4KCiMjIyBBbGlzYWRvIGRlIEhvbHQtV2ludGVycyBtdWx0aXBsaWNhdGl2byAoQSwgTSkgey19CgpMYXMgX19lY3VhY2lvbmVzIHJlY3Vyc2l2YXNfXyBkZSBhY3R1YWxpemFjacOzbiBzb246CiQkClxiZWdpbnthbGlnbmVkfQpsX3QgJiA9XGFscGhhIFxmcmFje3lfdH17c197dC1tfX0gKyAoMS1cYWxwaGEpKGxfe3QtMX0rYl97dC0xfSkgXFwKYl90ICYgPVxiZXRhIChsX3QgLSBsX3t0LTF9KSArICgxLVxiZXRhKWJfe3QtMX0gXFwKc190ICYgPVxnYW1tYSBcZnJhY3t5X3R9e2xfe3QtMX0gKyBiX3t0LTF9fSArICgxIC0gXGdhbW1hKXNfe3QtbX0KXGVuZHthbGlnbmVkfQokJAoKTGEgZWN1YWNpw7NuIGRlIGxhIF9fcHJlZGljY2nDs24gaW50cmEtbXVlc3RyYWxfXyBhIHVuIHBlcmlvZG8gdmlzdGEgZXMgCiQkXGhhdHt5fV97dCsxfSAgPSAobF90ICsgYl90KXNfe3QrMS1tfSwkJApkZSBmb3JtYSBxdWUgbGEgZWN1YWNpw7NuIGRlIF9fcHJlZGljY2nDs24gZXh0cmEtbXVlc3RyYWwgZXNfXzoKJCRcaGF0e3l9X3tUK2h9PShsX1QgKyBoIGJfVClzX3tUK2ggLSBtKGsrMSl9LiQkIAoKIyMjIEVqZW1wbG8gey19CgpWYW1vcyBhIHVzYXIgZWwgbcOpdG9kbyBkZSBIb2x0LVdpbnRlcnMgcGFyYSBwcmVkZWNpciBsYSBzZXJpZSBOYWNpbWllbnRvcywgcXVlIHByZXNlbnRhYmEgdW4gZXNxdWVtYSBtdWx0aXBsaWNhdGl2by4gUGFyYSBlbGxvIHVzYXJlbW9zIGxhIGZ1bmNpw7NuIGBod2AgY29uIGVsIGFyZ3VtZW50byBgc2Vhc29uYWwgPSAibXVsdGlwbGljYXRpdmUiYCAocXVlIHNlcsOtYSBgc2Vhc29uYWwgPSAiYWRkaXRpdmUiYCBlbiBjYXNvIGRlIGVzcXVlbWEgYWRpdGl2bykuIFZhbW9zIGEgY29uc2lkZXJhciBsYSBzZXJpZSBOYWNpbWllbnRvcyBkZXNkZSBlbmVybyBkZSAyMDAwIHkgcGVkaXIgdW5hIHByZXZpc2nDs24gYSBkb3MgYcOxb3MgdmlzdGEuCgpgYGB7cn0KbmFjaW1pZW50b3NiIDwtIHdpbmRvdyhuYWNpbWllbnRvcywgc3RhcnQgPSAyMDAwKQpuYWNpbWllbnRvc2JmIDwtIGh3KG5hY2ltaWVudG9zYiwgc2Vhc29uYWwgPSAibXVsdCIsIGggPSAyNCkKc3VtbWFyeShuYWNpbWllbnRvc2JmKQpgYGAKCkxvcyB2YWxvcmVzIMOzcHRpbW9zIGRlIGxvcyBwYXLDoW1ldHJvcyBzb24gJFxhbHBoYT0kIGByIHJvdW5kKG5hY2ltaWVudG9zYmYkbW9kZWwkcGFyWzFdLDIpYCwgJFxiZXRhPSQgYHIgcm91bmQobmFjaW1pZW50b3NiZiRtb2RlbCRwYXJbMl0sMilgIHkgJFxnYW1tYT0kIGByIHJvdW5kKG5hY2ltaWVudG9zYmYkbW9kZWwkcGFyWzNdLDIpYC4gTG9zIHZhbG9yZXMgdGFuIGJham9zIHBhcmEgJFxiZXRhJCB5ICRcZ2FtbWEkIGluZGljYW4gcXVlIGFtYmFzLCBsYSBwZW5kaWVudGUgeSBsYSBlc3RhY2lvbmFsaWRhZCwgbW9kaWZpY2FuIHN1IHZhbG9yIG11eSBsZW50YW1lbnRlLiBFcyBkZWNpciwgaGF5IHBlbmRpZW50ZSB5IGhheSBlZmVjdG8gZXN0YWNpb25hbCwgcGVybyBwZXJtYW5lY2VuIGNvbnN0YW50ZXMgZW4gZWwgdGllbXBvLgoKTGEgY2FsaWRhZCBkZSBsYXMgcHJlZGljY2lvbmVzIGVzIG5vdGFibGUsIGNvbiB1biBlcnJvciBwb3JjZW50dWFsIG1lZGlvIGRlbCAxLjglLiBSZWN1ZXJkYSBxdWUgY29uIGVsIG3DqXRvZG8gaW5nZW51byBjb24gZXN0YWNpb25hbGlkYWQgZWwgZXJyb3IgZXJhIGRlbCAzLjYlLgoKTG9zIMO6bHRpbW9zIHZhbG9yZXMgZGUgbGFzIGNvbXBvbmVudGVzIHNvbiAKYGBge3IsIGV2YWwgPSBGQUxTRX0KVFQgPC0gbnJvdyhuYWNpbWllbnRvc2JmJG1vZGVsJHN0YXRlcykKbmFjaW1pZW50b3NiZiRtb2RlbCRzdGF0ZXNbVFQsXQpgYGAKCmBgYHtyLCBlY2hvID0gRkFMU0V9ClRUIDwtIG5yb3cobmFjaW1pZW50b3NiZiRtb2RlbCRzdGF0ZXMpCnJvdW5kKG5hY2ltaWVudG9zYmYkbW9kZWwkc3RhdGVzW1RULF0sIDMpCmBgYAoKQ29tbyBlbCDDumx0aW1vIGRhdG8gZGUgbGEgc2VyaWUgZXMgZGljaWVtYnJlIGRlIDIwMTgsIGxvcyB2YWxvcmVzIGRlbCBuaXZlbCAkbCQgeSBsYSBwZW5kaWVudGUgJGIkIG1vc3RyYWRvcyBjb3JyZXNwb25kZW4gYSBlc2UgcGVyaW9kby4gU2luIGVtYmFyZ28sIGxhIGNvbXBvbmVudGUgZXN0YWNpb25hbCB0aWVuZSB1biBvcmRlbiBtdXkgcGVjdWxpYXI6IHMxIGVzIGVsIHZhbG9yIGVzdGFjaW9uYWwgcGFyYSBkaWNpZW1icmUgKG1lcyBkZWwgw7psdGltbyBkYXRvKSwgczIgZWwgZGUgbm92aWVtYnJlLCBzMyBkZSBvY3R1YnJlLCBoYXN0YSBzMTEgcXVlIHNlcsOtYSBmZWJyZXJvIHkgczEyIHF1ZSBlcyBlbmVyby4gUG9kZW1vcyByZXByb2R1Y2lyIGxhcyBwcmVkaWNjaW9uZXMgcGFyYSBsb3MgcHJpbWVyb3MgMTIgbWVzZXMgZGUgZW5lcm8gYSBkaWNpZW1icmUgY29uIChvam8sIGVsIGV0aXF1ZXRhZG8gZGUgbGEgc2FsaWRhIG5vIGVzIGNvcnJlY3RvKToKCmBgYHtyfQoobmFjaW1pZW50b3NiZiRtb2RlbCRzdGF0ZXNbVFQsIDFdICsgKDE6MTIpKm5hY2ltaWVudG9zYmYkbW9kZWwkc3RhdGVzW1RULCAyXSkgKiAKICBuYWNpbWllbnRvc2JmJG1vZGVsJHN0YXRlc1tUVCwgMTQ6M10KYGBgCgpMYSBmaWd1cmEgOSBtdWVzdHJhIGxhIHNlcmllIE5hY2ltaWVudG9zIHkgbGFzIHByZXZpc2lvbmVzIGV4dHJhLW11ZXN0cmFsZXMuCiAKYGBge3J9CmF1dG9wbG90KG5hY2ltaWVudG9zYmYsCiAgICAgICAgIHhsYWIgPSAiIiwKICAgICAgICAgeWxhYiA9ICJOYWNpbWllbnRvcyIsCiAgICAgICAgIG1haW4gPSAiRmlndXJhIDkuIE5hY2ltaWVudG9zIHkgcHJlZGljY2nDs24gY29uIGFsaXNhZG8gZGUgSG9sdC1XaW50ZXJzIG11bHRpcGxpY2F0aXZvIiwKICAgICAgICAgUEkgPSBGQUxTRSkKYGBgCgojIyBFamVtcGxvIGNvbiB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhCgpVbmEgYWx0ZXJuYXRpdmEgYSBwcmVkZWNpciBsYSBzZXJpZSBOYWNpbWllbnRvcywgcXVlIHRpZW5lIGVzcXVlbWEgbXVsdGlwbGljYXRpdm8sIGVzIHByZWRlY2lyIGxhIHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EgZGUgbGEgc2VyaWUsIHF1ZSB0ZW5kcsOhIHVuIGVzcXVlbWEgYWRpdGl2by4gRGVzcHXDqXMsIHNlIGFwbGljYSBsYSB0cmFuc2Zvcm1hY2nDs24gaW52ZXJzYSB5IHNlIG9idGllbmVuIGxhcyBwcmVkaWNjaW9uZXMgZGUgbGEgc2VyaWUgb3JpZ2luYWwuCgpFc3RlIHByb2Nlc28gc2UgcHVlZGUgcmVhbGl6YXIgZGUgZm9ybWEgc2VuY2lsbGEgeSB0cmFuc3BhcmVudGUgY29uIGN1YWxxdWllcmEgZGUgbGFzIGZ1bmNpb25lcyBkZSBhbGlzYWRvIGV4cG9uZW5jaWFsIHF1ZSBoZW1vcyB2aXN0byBhIHBhcnRpciBkZSBsb3MgYXJndW1lbnRvcyBgbGFtYmRhYCB5IGBiaWFzYWRqYC4KCiogYGxhbWJkYSA9IDBgIGluZGljYSBhIGxhIGZ1bmNpw7NuIGRlIGFsaXNhZG8gcXVlIHNlIGhhIGRlIHJlYWxpemFyIGxhIHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EgZGUgbGEgc2VyaWUuIEVzIHVuIHBhcsOhbWV0cm8gZGUgbGEgdHJhbnNmb3JtYWNpw7NuIEJveC1Db3ggcXVlIHZlcmVtb3MgZW4gZGV0YWxsZSBlbiBlbCB0ZW1hIDMuIAoqIGBiaWFzYWRqID0gVFJVRWAgZXMgbmVjZXNhcmlvIHNpIHRyYXMgdW5hIHRyYW5zZm9ybWFjacOzbiBkZSBsYSBzZXJpZSBvcmlnaW5hbCBxdWVyZW1vcyBxdWUgbGFzIHByZWRpY2Npb25lcyBzZWFuIGluc2VzZ2FkYXMuIFNlYSAkeV90JCBsYSBzZXJpZSBvcmlnaW5hbCB5ICR6X3Q9bG9nKHlfdCkkIHN1IHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EuIFNpIG9idGVuZW1vcyB1bmEgcHJlZGljY2nDs24gJFxoYXR7eX1fdCQgZGUgbGEgc2VyaWUgb3JpZ2luYWwsIGVzdGEgc2Vyw6EgaW5zZXNnYWRhICRFW1xoYXR7eX1fdF09eV90JC4gQWhvcmEgYmllbiwgc2kgb2J0ZW5lbW9zIHVuYSBwcmVkaWNjacOzbiAkXGhhdHt6fV90JCBkZSBsYSBzZXJpZSB0cmFuc2Zvcm1hZGEsIHBvZGVtb3MgcGVuc2FyIHF1ZSAkZV57XGhhdHt6fV90fSQgZXMgdW5hIHByZWRpY2Npw7NuIGluc2VzZ2FkYSBkZSBsYSBzZXJpZSBvcmlnaW5hbCwgcGVybyByZXN1bHRhIHF1ZSAkRVtlXntcaGF0e3p9X3R9XSBcbmVxIHlfdCQuIEVzIGRlY2lyLCBsYSBleHBvbmVuY2lhbCBkZSBsYSBwcmVkaWNjacOzbiBkZSBsYSBzZXJpZSB0cmFuc2Zvcm1hZGEgbG9nYXLDrXRtaWNhbWVudGUgbm8gZXMgaW5zZXNnYWRhLiBTaSBlbCBhcmd1bWVudG8gYGJpYXNhZGpgIGVzIGZpamFkbyBhIEZBTFNFLCBsYXMgcHJlZGljY2lvbmVzIHNlIGNhbGN1bGFyYW4gZGUgZm9ybWEgZGlyZWN0YSBkZXNoYWNpZW5kbyBsYSB0cmFuc2Zvcm1hY2nDs24geSBzZXLDoW4gc2VzZ2FkYXM7IHNpIGVzIGZpamFkbyBhIFRSVUUsIGxhcyBwcmVkaWNjaW9uZXMgc2UgY2FsY3VsYXJhbiBwb3IgbWVkaW8gZGUgdW5hIGbDs3JtdWxhIGFsdGVybmF0aXZhIHkgc2Vyw6FuIGluc2VzZ2FkYXMuIEVuIGFtYm9zIGNhc29zIGxhcyBlc3RpbWFjaW9uZXMgc29uIGNvbnNpc3RlbnRlcywgYXPDrSBxdWUgcGFyYSBzZXJpZXMgbGFyZ2FzIG5vIGRlYmVyw61hIG9ic2VydmFyc2UgbXVjaGEgZGlmZXJlbmNpYSBlbnRyZSBsYXMgZG9zIGFsdGVybmF0aXZhcy4KClZhbW9zIGEgcHJhY3RpY2FyIGVsIHVzbyBkZSBlc3RvcyBhcmd1bWVudG9zIGNvbiBsYSBzZXJpZSBOYWNpbWllbnRvcy4gQ29tbyBzZSB2YSBhIHByZWRlY2lyIGVsIGxvZ2FyaXRtbyBkZSBsYSBzZXJpZSwgc2UgZGViZSBpbmRpY2FyIGEgbGEgZnVuY2nDs24gYGh3YCBxdWUgdXNlIGVsIG1vZGVsbyBIb2x0LVdpbnRlcnMgYWRpdGl2by4KCmBgYHtyfQpuYWNpbWllbnRvc2JmbCA8LSBodyhuYWNpbWllbnRvc2IsIAogICAgICAgICAgICAgICAgICAgICBzZWFzb25hbCA9ICJhZGRpdCIsIAogICAgICAgICAgICAgICAgICAgICBoID0gMjQsIAogICAgICAgICAgICAgICAgICAgICBsYW1iZGEgPSAwLCAKICAgICAgICAgICAgICAgICAgICAgYmlhc2FkaiA9IFRSVUUpCnN1bW1hcnkobmFjaW1pZW50b3NiZmwpCmBgYAoKT2JzZXJ2YSBxdWUgZW4gZXN0ZSBjYXNvIGxhIGNhbGlkYWQgZGUgbGFzIHByZWRpY2Npb25lcyAoTUFQRSA9IDEuOSUpIGVzIGluZmVyaW9yIGEgbGEgb2J0ZW5pZGEgY29uIGxhIHNlcmllIHNpbiB0cmFuc2Zvcm1hci4KCkxhIGZpZ3VyYSAxMCBtdWVzdHJhIGxhIHNlcmllIE5hY2ltaWVudG9zIHkgbGFzIHByZXZpc2lvbmVzIGV4dHJhLW11ZXN0cmFsZXMgb2J0ZW5pZGFzIGNvbiB5IHNpbiBsYSB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhLgogCmBgYHtyLCBlY2hvID0gRkFMU0V9CmF1dG9wbG90KG5hY2ltaWVudG9zYiwKICAgICAgICAgeGxhYiA9ICIiLAogICAgICAgICB5bGFiID0gIk5hY2ltaWVudG9zIiwKICAgICAgICAgbWFpbiA9ICJGaWd1cmEgMTAuIE5hY2ltaWVudG9zIHkgZG9zIHByZWRpY2Npb25lcyBjb24gYWxpc2FkbyBkZSBIb2x0LVdpbnRlcnMiKSArIAogIGF1dG9sYXllcihuYWNpbWllbnRvc2JmLCBzZXJpZXMgPSAiTmFjaW1pZW50b3MiLCBQSSA9IEZBTFNFKSArIAogIGF1dG9sYXllcihuYWNpbWllbnRvc2JmbCwgc2VyaWVzID0gIk5hY2ltaWVudG9zIChsb2cpIiwgUEkgPSBGQUxTRSkgKyAKICBndWlkZXMoY29sb3VyID0gZ3VpZGVfbGVnZW5kKHRpdGxlID0gIlByZWRpY2Npw7NuIikpICsgCiAgdGhlbWUobGVnZW5kLnBvc2l0aW9uPWMoMC45OCwwLjk4KSwgbGVnZW5kLmp1c3RpZmljYXRpb249YygxLDEpKSAKYGBgCgpMYSBzaWd1aWVudGUgdGFibGEgbXVlc3RyYSBsYXMgcHJlZGljY2lvbmVzIGRlIE5hY2ltaWVudG9zIG9idGVuaWRhcyBzaW4gdHJhbnNmb3JtYXIgbGEgc2VyaWUsIGNvbiB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhIHkgcHJlZGljY2lvbmVzIGluc2VzZ2FkYXMgKGBiaWFzYWRqID0gVFJVRWApLCB5IGNvbiB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhIHkgcHJlZGljY2lvbmVzIHNlc2dhZGFzIChgYmlhc2FkaiA9IEZBTFNFYCkuCgpgYGB7ciwgZWNobyA9IEZBTFNFfQpuYWNpbWllbnRvc2JmbDIgPC0gaHcobmFjaW1pZW50b3NiLCBzZWFzb25hbCA9ICJhZGRpdCIsIGg9MjQsIGxhbWJkYSA9IDAsIGJpYXNhZGogPSBGQUxTRSkKZGF0b3MgPC0gY2JpbmQoCiAgYFNpbiB0cmFuc2Zvcm1hcmAgPSBuYWNpbWllbnRvc2JmJG1lYW4sCiAgYGxvZyhOYWMpIGluc2VzZ2FkYXNgID0gbmFjaW1pZW50b3NiZmwkbWVhbiwKICBgbG9nKE5hYykgc2VzZ2FkYXNgID0gbmFjaW1pZW50b3NiZmwyJG1lYW4KICApCmhlYWQoZGF0b3MsIDEyKQpgYGAKCk9ic2VydmEgcXVlIGxhcyBwcmVkaWNjaW9uZXMgc2VzZ2FkYXMgc29uIG1lbm9yZXMgcXVlIGxhcyBpbnNlc2dhZGFzLiBFc3RvIHNpZW1wcmUgZXMgYXPDrS4gTGEgZGlmZXJlbmNpYSBkZXBlbmRlIGZ1bmRhbWVudGFsbWVudGUgZGUgbGEgdmFyaWFuemEgZGVsIGVycm9yLCBfc2lnbWFfIGFsIGN1YWRyYWRvIGVuIGxhIHNhbGlkYSBkZSBsb3MgbcOpdG9kb3MgZGUgYWxpc2FkbyBleHBvbmVuY2lhbC4gQ3VhbnRvIG1heW9yIGVzIGxhIHZhcmlhbnphIGRlbCBlcnJvciwgbWF5b3JlcyBzb24gbGFzIGRpZmVyZW5jaWFzLgoKUG9yIG90cm8gbGFkbywgbGFzIHByZWRpY2Npb25lcyBvYnRlbmlkYXMgc2luIHkgY29uIGxhIHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2Egbm8gZ3VhcmRhbiBuaW5ndW5hIHJlbGFjacOzbi4KCioqTmkgbGEgdHJhbnNmb3JtYWNpw7NuIGxvZ2Fyw610bWljYSBuaSBlbCB1c28gZGUgcHJlZGljY2lvbmVzIGluc2VzZ2FkYXMgYXNlZ3VyYW4gbWVqb3JlcyBwcmVkaWNjaW9uZXMgcmVzcGVjdG8gZGUgb3RyYXMgb3BjaW9uZXMqKiwgY29tbyBwdWVkZW4gc2VyIHRyYWJhamFyIGNvbiBwcmVkaWNjaW9uZXMgc2VzZ2FkYXMgbyBubyByZWFsaXphciBsYSB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhLgoKXAoKIyMgQ2Fzb3MgZ2VuZXJhbGVzIGRlIGFsaXNhZG8gZXhwb25lbmNpYWwKCkVuIGxvcyBlcMOtZ3JhZmVzIHByZXZpb3MgaGVtb3MgdmlzdG8gY2luY28gZGUgbG9zIGNhc29zIGV4cHVlc3RvcyBlbiBsYSB0YXhvbm9tw61hIGRlbCBlcMOtZ3JhZmUgNC4zLCB5IGxhcyBmdW5jaW9uZXMgZGUgYFJgIGFzb2NpYWRhcy4gVmVhbW9zIGFob3JhIGNvbW8gZXN0aW1hciBjdWFscXVpZXJhIGRlIGxvcyBxdWluY2UgbW9kZWxvcyBxdWUgc3VyZ2VuIHNlZ8O6biBsYXMgZGlmZXJlbnRlcyBwb3NpYmlsaWRhZGVzIGRlIGxhIHRlbmRlbmNpYSAoTiwgQSwgQWQsIE0geSBNZCkgeSBkZSBsYSBlc3RhY2lvbmFsaWRhZCAoTiwgQSB5IE0pLiAKClJlY29yZGVtb3MgcXVlIGFsIGHDsWFkaXIgZWwgZXJyb3IsIGFkaXRpdm8gbyBtdWx0aXBsaWNhdGl2bywgZXN0b3MgcXVpbmNlIG1vZGVsb3Mgc2UgY29udmllcnRlbiBlbiB0cmVpbnRhLiBTaW4gZW1iYXJnbywgZWwgdGlwbyBkZSBlcnJvciBubyBpbmZsdXllIGVuIGVsIGPDoWxjdWxvIGRlIGxhcyBwcmV2aXNpb25lcywgc29sbyBpbmZsdXllIGVuIGVsIGPDoWxjdWxvIGRlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGRlIGVzdGFzLgoKIyMjIExhIGZ1bmNpw7NuIGBldHNgIHstfQoKUG9kZW1vcyBlc3RpbWFyIGN1YWxxdWllcmEgZGUgbG9zIHRyZWludGEgbW9kZWxvcyB1c2FuZG8gbGEgZnVuY2nDs24gYGV0c2AgZGVsIHBhcXVldGUgYGZvcmVjYXN0YC4gQSBkaWZlcmVuY2lhIGRlIGxhcyBmdW5jaW9uZXMgcHJldmlhcyBgc2VzYCwgYGhvbHRgIHkgYGh3YCwgbGEgZnVuY2nDs24gYGV0c2Agc29sbyBlc3RpbWEgbG9zIG1vZGVsb3MsIHBlcm8gbm8gcHJvZHVjZSBwcmVkaWNjaW9uZXMuIFBhcmEgZWxsbyBoYWJyw6EgcXVlIHVzYXIgbGEgZnVuY2nDs24gYGZvcmVjYXN0YCBzb2JyZSB1biBtb2RlbG8gZXN0aW1hZG8gY29uIGBldHNgLiBNaXJhIGxhIGF5dWRhIHBhcmEgdmVyIHVuYSBleHBsaWNhY2nDs24gZGV0YWxsYWRhIGRlIGxvcyBhcmd1bWVudG9zIGRlIGVzdGFzIGZ1bmNpb25lcy4KCiogRWwgdGlwbyBkZSBtb2RlbG8gZW4gYGV0c2Agc2UgZXNwZWNpZmljYSBjb24gZWwgYXJndW1lbnRvIGBtb2RlbGAsIHVuIGPDs2RpZ28gZGUgdHJlcyBsZXRyYXMgaW5kaWNhbmRvIGVsIHRpcG8gZGUgRXJyb3IsIFRlbmRlbmNpYSB5IGVTdGFjaW9uYWxpZGFkIChFVFMpLiBQb3IgZWplbXBsbywgYG1vZGVsID0gIkFOTiJgIGluZGljYSB1biBtb2RlbG8gY29uIGVycm9yIGFkaXRpdm8sIHNpbiB0ZW5kZW5jaWEgbmkgZXN0YWNpb25hbGlkYWQsIGVzIGRlY2lyLCBlbCBhbGlzYWRvIGV4cG9uZW5jaWFsIHNpbXBsZTsgYG1vZGVsID0gIkFBTiJgIGluZGljYSB1biBtb2RlbG8gY29uIGVycm9yIGFkaXRpdm8sIHBlbmRpZW50ZSBhZGl0aXZhLCBwZXJvIHNpbiBlc3RhY2lvbmFsaWRhZCwgZWwgYWxpc2FkbyBleHBvbmVuY2lhbCBkZSBIb2x0LiBFbCBhbGlzYWRvIGV4cG9uZW5jaWFsIGRlIEhvbHQtV2ludGVycyBtdWx0aXBsaWNhdGl2byBzZXLDrWEgYG1vZGVsID0gIkFBTSJgLgoqIFNpIHNlIGRlc2VhIGluY2x1aXIgYW1vcnRpZ3VhbWllbnRvLCBoYXkgcXVlIGluY2x1aXIgZWwgYXJndW1lbnRvIGBkYW1wZWQgPSBUUlVFYC4gCiogUG9yIGRlZmVjdG8gYGV0c2Agbm8gY29uc2lkZXJhIG1vZGVsb3MgY29uIHRlbmRlbmNpYSBtdWx0aXBsaWNhdGl2YSAow7psdGltYXMgZG9zIGzDrW5lYXMgZGUgbGEgdGF4b25vbcOtYSBkZWwgZXDDrWdyYWZlIDUuMykuIERlYmVzIGZpamFyIGVsIHBhcsOhbWV0cm8gYGFsbG93Lm11bHRpcGxpY2F0aXZlLnRyZW5kPVRSVUVgIHBhcmEgY29udGVtcGxhciBlc3RhIG9wY2nDs24uCiogQWRlbcOhcywgc2Ugc2lndWUgZGlzcG9uaWVuZG8gZGUgbG9zIGFyZ3VtZW50b3MgYGxhbWJkYWAgeSBgYmlhc2FkamAuCgpfX0NyaXRlcmlvcyBkZSBvcHRpbWl6YWNpw7NuX18KCkZpamFkbyB1biBtb2RlbG8sIGBldHNgIGVzdGltYSBwb3IgZGVmZWN0byBzdXMgcGFyw6FtZXRyb3MgbWF4aW1pemFuZG8gbGEgZnVuY2nDs24gZGUgdmVyb3NpbWlsaXR1ZC4gRXN0YSBiw7pzcXVlZGEgZXN0YSByZXN0cmluZ2lkYSBhICQwIDwgXGJldGEgPCBcYWxwaGEgPCAxJCwgJDAgPCBcZ2FtbWEgPCAxIC0gXGFscGhhJCB5ICQwLjggPCBccGhpIDwgMC45OCQuIEVzIGRlY2lyLCBsb3MgdHJlcyBwcmltZXJvcyBwYXLDoW1ldHJvcyBudW5jYSBwdWVkZW4gc2VyIDAgbyAxLCB5IGVuIGxhIHByw6FjdGljYSBzdXMgdmFsb3JlcyBsw61taXRlIHNvbiAwLjAwMDEgeSAwLjk5OTkuCgpQdWVkZXMgY2FtYmlhciBlbCBjcml0ZXJpbyBkZSBvcHRpbWl6YWNpw7NuIGNvbiBlbCBhcmd1bWVudG8gYG9wdC5jcml0YC4gUG9yIGRlZmVjdG8gdmFsZSAibGlrIiwgcGVybyBzaSBsbyBmaWphcyBhIGBvcHQuY3JpdCA9ICJtc2UiYCBzZSBlc3RpbWFuIGxvcyBwYXLDoW1ldHJvcyBxdWUgbWluaW1pemFuIGVsIGVycm9yIGN1YWRyw6F0aWNvIG1lZGlvLiBPdHJhIG9wY2nDs24gaW50ZXJlc2FudGUgZXMgYG9wdC5jcml0ID0gImFtc2UiYCBxdWUgbWluaW1pemEgbGEgbWVkaWEgZGUgbG9zIGVycm9yZXMgY3VhZHLDoXRpY29zIG1lZGlvcyBvYnRlbmlkbyBzb2JyZSBsYXMgcHJldmlzaW9uZXMgYSBgbm1zZWAgcGVyaW9kb3MgdmlzdGEuIEVuIGVzdGUgY2FzbyB1c2EgZWwgYXJndW1lbnRvIGBubXNlYCBwYXJhIGZpamFyIGVsIHZhbG9yIG51bcOpcmljbyBkZWwgaG9yaXpvbnRlIHRlbXBvcmFsLgoKX19TZWxlY2Npw7NuIGRlIG1vZGVsb3NfXwoKTG8gbcOhcyBoYWJpdHVhbCBlcyBubyBzYWJlciBjdWFsIGVzIGVsIG1lam9yIG1vZGVsbywgZW50ZW5kaWVuZG8gY29tbyB0YWwsIGVsIHF1ZSBtZWpvciBzZSBhanVzdGEgYSBsYSBzZXJpZSB0ZW1wb3JhbC4gRGUgaGVjaG8sIHNpIGxvIHF1ZSBidXNjYW1vcyBlcyBwcmVkZWNpciBiaWVuLCBtw6FzIHF1ZSBlbnRlbmRlciBsYSBuYXR1cmFsZXphIGRlbCBwcm9jZXNvIGdlbmVyYWRvciBkZSBkYXRvcywgZWwgbWVqb3IgbW9kZWxvIHNlcsOhIGVsIHF1ZSBtZWpvciBwcmVkaWdhLgoKU2kgZW4gdW5hIGRlIGxhcyB0cmVzIGxldHJhcyBkZWwgY8OzZGlnbyBkZWwgbW9kZWxvIHNlIGluZGljYSAiWiIsIGxhIGZ1bmNpw7NuIGBldHNgIHNlbGVjY2lvbmEgZGUgZW50cmUgbG9zIG1vZGVsb3MgcG9zaWJsZXMgZWwgcXVlIG1lam9yIHNlIGFqdXN0YS4gUG9yIGVqZW1wbG8sIGBtb2RlbCA9ICJBQVoiYCBpbmRpY2EgdW4gbW9kZWxvIGNvbiBlcnJvciB5IHBlbmRpZW50ZSBhZGl0aXZvcyB5IGRlamFyw61hIGEgYGV0c2AgbGEgYsO6c3F1ZWRhIGRlIGxhIG1lam9yIG9wY2nDs24gcGFyYSBsYSBlc3RhY2lvbmFsaWRhZCAobnVsYSwgYWRpdGl2YSBvIG11bHRpcGxpY2F0aXZhKS4gU2kgc2UgZXNwZWNpZmljYSBgbW9kZWwgPSAiWlpaYCBqdW50byBjb24gYGRhbXBlZCA9IE5VTExgIChvcGNpb25lcyBwb3IgZGVmZWN0bykgc2UgZGVqYXLDrWEgYSBsYSBmdW5jacOzbiB0b3RhbCBsaWJlcnRhZCBwYXJhIGJ1c2NhciBlbnRyZSB0b2RvcyBsb3MgbW9kZWxvcyAoZXhjZXB0byBhcXVlbGxvcyBjb24gcGVuZGllbnRlIG11bHRpcGxpY2F0aXZhKS4gU2kgc2UgZGVzZWEgcmVzdHJpbmdpciBsYSBiw7pzcXVlZGEgYSBtb2RlbG9zIHNpbiBhbW9ydGlndWFtaWVudG8gYmFzdGEgaW5kaWNhciBgZGFtcGVkID0gRkFMU0VgIHkgc2kgc2UgZGVzZWEgcmVzdHJpbmdpciBsYSBiw7pzcXVlZGEgc29sbyBhIG1vZGVsb3MgYWRpdGl2b3Mgc2UgcHVlZGUgdXNhciBlbCBhcmd1bWVudG8gYGFkZGl0aXZlLm9ubHkgPSBUUlVFYC4KClF1ZWRhIHBlbmRpZW50ZSBzYWJlciBxdWUgY3JpdGVyaW8gc2UgdXNhIHBhcmEgc2VsZWNjaW9uYXIgZWwgbW9kZWxvIGN1YW5kbyBzZSBvZnJlY2UgZXN0YSBvcGNpw7NuLiBFc3RvIHNlIGhhY2UgYSBwYXJ0aXIgZGUgdW4gY3JpdGVyaW8gZGUgaW5mb3JtYWNpw7NuIGVudHJlIEFrYWlrZSAoYWljKSwgQWthaWtlIGNvcnJlZ2lkbyBwYXJhIHBlcXVlw7FhcyBtdWVzdHJhcyAoYWljYykgeSBlbCBCYXllc2lhbm8gKGJpYykuIFN1cyBmw7NybXVsYXMgc29uOgokJGFpYyA9IC0ybG9nKEwpICsgMmskJAokJGFpY2MgPSBhaWMgKyBcZnJhY3trKGsrMSl9e1Qtay0xfSQkCiQkYmljPWFpYyArIGsobG9nKFQpIC0gMikkJApcbm9pbmRlbnQgZG9uZGUgJEwkIGVzIGxhIHZlcm9zaW1pbGl0dWQsICRUJCBlbCBuw7ptZXJvIGRlIGRhdG9zIHkgJGskIGVsIGRlIHBhcsOhbWV0cm9zIChpbmNsdWlkb3MgbG9zIHB1bnRvcyBpbmljaWFsZXMgZGUgYXJyYW5xdWUgeSBsYSB2YXJpYW56YSByZXNpZHVhbCkuCgpQb3IgZGVmZWN0byBzZSB1c2EgQWthaWtlIGNvcnJlZ2lkbyBwYXJhIHBlcXVlw7FhcyBtdWVzdHJhcywgcGVybyBlbCBhcmd1bWVudG8gYGljYCBwZXJtaXRlIGNhbWJpYXIgZGUgY3JpdGVyaW8uIAoKIyMjIFVuYSByZWZsZXhpw7NuIHNvYnJlIGxvcyBtw6l0b2RvcyBhdXRvbcOhdGljb3MgZGUgc2VsZWNjacOzbiBkZSBtb2RlbG9zIHstfQoKQ29uIGVsIGNvbWFuZG8gYGZvcmVjYXN0KGV0cyhuYWNpbWllbnRvcyksIGggPSAyNClgIG9idGVuZW1vcyB1bmEgcHJlZGljY2nDs24gbWVuc3VhbCBhIGRvcyBhw7FvcyB2aXN0YSBkZWwgbsO6bWVybyBkZSBuYWNpbWllbnRvcyBlbiBFc3Bhw7FhLiBBc8OtIGRlIHNpbXBsZSwgc29sbyAzMSBjYXJhY3RlcmVzLiBUb2RvIGVzdG8gZ3JhY2lhcyBhIHF1ZSB1biBhbGdvcml0bW8gaW50ZXJubyBoYSBlc3RpbWFkbyBsb3MgcGFyw6FtZXRyb3MgZGUgbcO6bHRpcGxlcyBtb2RlbG9zLCBlbGVnaWRvIGVsIG1lam9yIG1vZGVsbyBkZSB0b2RvcyB5IGxvIGhhIHVzYWRvIHBhcmEgb2J0ZW5lciBsYXMgcHJlZGljY2lvbmVzLiBQb2RlbW9zIGFmaXJtYXIgcXVlIHRlbmVtb3MgbGFzIG1lam9yZXMgcHJlZGljY2lvbmVzLiBVbiBtb21lbnRvLCDCv3BvZGVtb3M/CgpQYXLDqW1vbm9zIGEgcmVmbGV4aW9uYXIgc29icmUgbG8gcXVlIGhlbW9zIGhlY2hvIC0tbcOhcyBiaWVuIGxvIHF1ZSBlbCBhbGdvcml0bW8gaGEgaGVjaG8tLSB5IGEgY29udHJhc3RhcmxvIGNvbiBsbyBxdWUgbm9zb3Ryb3MgcXVlcsOtYW1vcy4gUG9yIHVuIGxhZG8sIGVsIGFsZ29yaXRtbyBlc3RpbWEgbG9zIHBhcsOhbWV0cm9zIGRlIHVuIG1lbsO6IGZpam8gZGUgbW9kZWxvcyB5IHBhcmEgZWxsbyB1c2EgdW4gY3JpdGVyaW8gZGUgb3B0aW1pemFjacOzbiwgcXVlIHBvciBkZWZlY3RvIGVzIG1heGltaXphciBsYSBmdW5jacOzbiBkZSB2ZXJvc2ltaWxpdHVkOyBjdWFuZG8geWEgdGllbmUgZXN0aW1hZG9zIHRvZG9zIGxvcyBtb2RlbG9zLCBlbGlqZSBlbCBtZWpvciB1c2FuZG8gZWwgY3JpdGVyaW8gZGUgaW5mb3JtYWNpw7NuIGRlIEFrYWlrZSBjb3JyZWdpZG8gcGFyYSBtdWVzdHJhcyBwZXF1ZcOxYXM7IHkgZmluYWxtZW50ZSwgbm9zb3Ryb3MgbWVkaW1vcyBsYSBjYXBhY2lkYWQgcHJlZGljdGl2YSBkZWwgbW9kZWxvIHNlbGVjY2lvbmFkbyB1c2FuZG8gZWwgZXJyb3IgYWJzb2x1dG8gcG9yY2VudHVhbCBtZWRpby4gVmF5YSwgcmVzdWx0YSBxdWUgZW4gbG9zIHByb2Nlc29zIGRlIGlkZW50aWZpY2FjacOzbiB5IGVzdGltYWNpw7NuIGRlbCBtZWpvciBtb2RlbG8gc2UgdXNhbiBkb3MgY3JpdGVyaW9zIGRpZmVyZW50ZXMsIHF1ZSBhZGVtw6FzIG5vIGNvaW5jaWRlbiBjb24gbnVlc3RybyBjcml0ZXJpbyBkZSBjYWxpZGFkIGRlIGxhcyBwcmVkaWNjaW9uZXMuCgpTaSBjb25zaWRlcmFtb3MgcXVlIGxhIGNhbGlkYWQgZGUgdW4gbW9kZWxvIHZpZW5lIGRhZGEgcG9yIGVsIGVycm9yIGFic29sdXRvIHBvcmNlbnR1YWwgbWVkaW8gZW4gbGFzIHByZWRpY2Npb25lcyBpbnRyYS1tdWVzdHJhbGVzIGEgdW4gcGVyaW9kbyB2aXN0YSAobG8gcXVlIGhlbW9zIGRlY2lkaWRvIGxsYW1hciBNQVBFKSwgwr9ubyBkZWJlcsOtYW1vcyBlc3RpbWFyIGxvcyBwYXLDoW1ldHJvcyBkZWwgbW9kZWxvIHVzYW5kbyBjb21vIGNyaXRlcmlvIGxhIG1pbmltaXphY2nDs24gZGVsIE1BUEU/LCDCv25vIGRlYmVyw61hbW9zIGVsZWdpciBlbnRyZSB2YXJpb3MgbW9kZWxvcyBhcXVlbCBxdWUgcHJlc2VudGEgdW4gTUFQRSBtZW5vcj8gRGUgZXN0YSBmb3JtYSwgZW4gdG9kb3MgbG9zIHBhc29zIGRlbCBwcm9jZXNvIHNlIHVzYSBlbCBtaXNtbyBjcml0ZXJpbywgcXVlIGVzLCBhZGVtw6FzLCBlbCBjcml0ZXJpbyBxdWUgaGVtb3MgY29uc2lkZXJhZG8gYWRlY3VhZG8gcGFyYSB2YWxvcmFyIGxhIGNhbGlkYWQgZGUgbGFzIHByZWRpY2Npb25lcy4KClBlcm8gbm8gZXMgZXN0byBsbyBxdWUgaGFjZW1vcy4gCgpOYWRhIG5vcyBnYXJhbnRpemEgcXVlIGVsIG1vZGVsbyBlc3RpbWFkbyB5IHNlbGVjY2lvbmFkbyBwb3IgZWwgYWxnb3JpdG1vIGVzdGltZSBsYXMgbWVqb3JlcyBwcmVkaWNjaW9uZXMgcG9zaWJsZXMuIFkgcG9yIF9tZWpvcmVzXyBxdWllcm8gZGVjaXIgcXVlIGRlIGVudHJlIHRvZG9zIGxvcyBwb3NpYmxlcyBtb2RlbG9zIGRlbCBtZW7DuiB5IHRvZG9zIGxvcyBwb3NpYmxlcyB2YWxvcmVzIGRlIHN1cyBwYXLDoW1ldHJvcywgZWwgc2VsZWNjaW9uYWRvIHNlYSBxdWUgZWwgbWluaW1pemEgbnVlc3RybyBjcml0ZXJpbyBkZSBjYWxpZGFkIGRlIGxhcyBwcmVkaWNjaW9uZXMuCgpBaG9yYSB5YSBwb2RlbW9zIGRhciByZXNwdWVzdGEgYSBsYSBwcmVndW50YSBkZWwgcHJpbWVyIHDDoXJyYWZvOiBubywgbm8gcG9kZW1vcyBhZmlybWFyIHF1ZSBudWVzdHJhcyBwcmVkaWNjaW9uZXMgc2VhbiBsYXMgbWVqb3Jlcy4KCkFsZ3VpZW4gZGlyw6EgcXVlIGNhc2kgc2VndXJvIGVudHJlIGxhcyBwcmVkaWNjaW9uZXMgc3ViLcOzcHRpbWFzIG9idGVuaWRhcyBwb3IgZWwgYWxnb3JpdG1vIGNvbiBzdSBleHRyYcOxYSBtZXpjbGEgZGUgY3JpdGVyaW9zIHkgbGFzIHByZWRpY2Npb25lcyDDs3B0aW1hcyBkZSB2ZXJkYWQgbm8gaGFicsOhIG11Y2hhIGRpZmVyZW5jaWEuIFRvdGFsLCBxdWUgbcOhcyBkYSB1bmEgZnVuY2nDs24gZGUgdmVyb3NpbWlsaXR1ZCBxdWUgdW4gY3JpdGVyaW8gZGUgaW5mb3JtYWNpw7NuIHF1ZSB1bmEgbWVkaWRhIGRlbCBlcnJvciBtZWRpby4gUGVybyBsbyBjaWVydG8gZXMgcXVlIG5vIGxvIHNhYmVtb3MsIG5vIHRlbmVtb3MgbmkgaWRlYSBkZSBsYSBkaXN0YW5jaWEgcXVlIGhheSBlbnRyZSBsbyDDs3B0aW1vIHkgbG8gc3ViLcOzcHRpbW8sIHkgc2kgZWwgY29zdGUgZGUgZXF1aXZvY2FybWUgZW4gbGFzIHByZWRpY2Npb25lcyBlcyBhbHRvLCBwdWVkZSBxdWUgaW5jbHVzbyB1bmEgcGVxdWXDsWEgZGlmZXJlbmNpYSBzZWEgcmVsZXZhbnRlLgoKRXN0YSByZWZsZXhpw7NuIHJlYWxpemFkYSBlbiBlbCBjb250ZXh0byBkZSBzZXJpZXMgdGVtcG9yYWxlcyB5IHBhcmEgbGEgZnVuY2nDs24gYGV0c2AgZXMgYXBsaWNhYmxlIGEgdG9kb3MgbG9zIGNhc29zIGRvbmRlIGRlamFtb3MgcXVlIHVuIGFsZ29yaXRtbyB5YSBwcm9ncmFtYWRvIGVsaWphIGVsIG1lam9yIG1vZGVsbywgeSBzZSBiYXNhIGVuIGVsIGhlY2hvIGRlIHF1ZSByYXJhIHZleiBsb3MgY3JpdGVyaW9zIGRlIGVzdGltYWNpw7NuIHkgZWxlY2Npw7NuIHF1ZSB1c2FuIGxvcyBhbGdvcml0bW9zIGNvaW5jaWRlbiBjb24gZWwgY29uY2VwdG8gZGUgY2FsaWRhZCBkZSBhanVzdGUgcXVlIGVzdGFtb3MgaW50ZXJlc2Fkb3MuCgpBIHBlc2FyIGRlIGxvIGFxdcOtIGV4cHVlc3RvLCBjb21vIGVzIG3DoXMgY8OzbW9kbyAoeSByw6FwaWRvKSB0aXJhciBkZSBydXRpbmFzIHlhIHByb2dyYW1hZGFzIHF1ZSBlc2NyaWJpciB0dSBwcm9waW8gY8OzZGlnbywgc2VndWlyZW1vcyB0cmFiYWphbmRvIGNvbiBtb2RlbG9zIHN1Yi3Ds3B0aW1vcyB5IG9idGVuaWVuZG8gZXN0aW1hY2lvbmVzIHN1Yi3Ds3B0aW1hcywgcGVybyBkaWNpZW5kbyBxdWUgc29uIGxhcyBtZWpvcmVzLgoKXAoKIyMjIFJlc2lkdW8gYWRpdGl2byB2ZXJzdXMgcmVzaWR1byBtdWx0aXBsaWNhdGl2byB7LX0KCkVuIGxvcyBtb2RlbG9zIGRlIGFsaXNhZG8gZXN0aW1hZG9zIHBvciBsYSBmdW5jacOzbiBgZXRzYCBsYSBmw7NybXVsYSBwYXJhIGVsIGPDoWxjdWxvIGRlbCByZXNpZHVvIGVzdGltYWRvIGRlcGVuZGUgZGUgc3UgbmF0dXJhbGV6YSBhZGl0aXZhIG8gbXVsdGlwbGljYXRpdmEuCgpTaSBlbCBfX3Jlc2lkdW8gZXMgYWRpdGl2b19fLCBlbnRvbmNlcyBlbCBtb2RlbG8gZXMgJHlfdCA9IFxoYXR7eX1fdCArIFxoYXR7XHZhcmVwc2lsb259X3QkIHkgZWwgcmVzaWR1byBzZSBkZWZpbmUgZGUgbGEgZm9ybWEgdXN1YWwgCiQkXGhhdHtcdmFyZXBzaWxvbn1fdCA9IHlfdCAtIFxoYXR7eX1fdC4kJApBaG9yYSBiaWVuLCBzaSBlbCBfX3Jlc2lkdW8gZXMgbXVsdGlwbGljYXRpdm9fXywgZW50b25jZXMgZWwgbW9kZWxvIGVzICR5X3QgPSBcaGF0e3l9X3QgXGNkb3QgKDEgKyBcaGF0e1x2YXJlcHNpbG9ufV90KSQsIHkgbm8gJHlfdCA9IFxoYXR7eX1fdCBcY2RvdCBcaGF0e1x2YXJlcHNpbG9ufV90JCwgY29tbyBzZSBwb2Ryw61hIGVzcGVyYXIuIFBvciB0YW50bywgZWwgcmVzaWR1byBtdWx0aXBsaWNhdGl2byBzZSBkZWZpbmUgY29tbyAKJCRcdmFyZXBzaWxvbl90ID0gKHlfdCAtIFxoYXR7eX1fdCkvXGhhdHt5fV90LiQkCkRlIGVzdGEgZm9ybWEgZW4gYW1ib3MgY2Fzb3MgZWwgcmVzaWR1byBldm9sdWNpb25hIGFscmVkZWRvciBkZWwgdmFsb3IgMCB5IHNlIGxlIHB1ZWRlbiBpbXBvbmVyIGxhcyBoaXDDs3Rlc2lzIHVzdWFsZXMgZGUgcnVpZG8gYmxhbmNvLiAKCkxhIGZ1bmNpw7NuIGByZXNpZHVhbGAgcGVybWl0ZSBleHRyYWVyIGRlIHVuIG9iamV0byBgZXRzYCBlbCByZXNpZHVvIGRlbCBtb2RlbG8uIFNpIGVsIG1vZGVsbyB0aWVuZSByZXNpZHVvIG11bHRpcGxpY2F0aXZvIHkgc2UgZGVzZWEgb2J0ZW5lciBlbCByZXNpZHVvIGFkaXRpdm8sIHNlIGRlYmUgdXNhciBjb24gZWwgYXJndW1lbnRvIGB0eXBlID0gInJlc3BvbnNlImAuCgpcClwKCiMgRWplbXBsbyBkZSBhcGxpY2FjacOzbjogTGlicm9zCgpcCgojIyBJZGVudGlmaWNhY2nDs24geSBlc3RpbWFjacOzbiBkZWwgbWVqb3IgbW9kZWxvCgpTaSBlc3RpbWFtb3MgZWwgbWVqb3IgbW9kZWxvIGRlIGFsaXNhZG8gZXhwb25lbmNpYWwgcGFyYSBsYSBzZXJpZSBMaWJyb3Mgc2luIG5pbmfDum4gdGlwbyBkZSByZXN0cmljY2nDs24sIG5vcyBlbmNvbnRyYW1vczoKCmBgYHtyfQpsaWJyb3NFdHMgPC0gZXRzKGxpYnJvcykKc3VtbWFyeShsaWJyb3NFdHMpIApgYGAKCkVsIG1vZGVsbyBlc3RpbWFkbyBlcyBFVFMoTSxOLE4pIG8gIk1OTiIsIHVuIG1vZGVsbyBzaW4gcGVuZGllbnRlIG5pIGVzdGFjaW9uYWxpZGFkIHkgY29uIGVycm9yIG11bHRpcGxpY2F0aXZvLiBFcyBkZWNpciwgJHlfe3QrMX0gPSBsX3QgXGNkb3QgKDEgKyBcdmFyZXBzaWxvbl97dCsxfSkkLiAKCkVsIHZhbG9yIGRlICRcYWxwaGEkIHTDqWNuaWNhbWVudGUgZXMgMSwgaW5kaWNhbmRvIHF1ZSBlbCBuaXZlbCBkZSBsYSBzZXJpZSB2YXJpYSBlbiBlbCB0aWVtcG8geSBxdWUgcmVhbG1lbnRlIGVzdGFtb3MgdXNhbmRvIHBhcmEgbGFzIHByZXZpc2lvbmVzIGVsIG3DqXRvZG8gaW5nZW51byBJLgoKUmVzcGVjdG8gZGUgbGEgY2FsaWRhZCBkZWwgbW9kZWxvLCBlbCB2YWxvciBkZSBNQVBFPSAkYHIgcm91bmQoYWNjdXJhY3kobGlicm9zRXRzKVs1XSwxKWAkJSBldmlkZW5jaWEgcXVlIGVzdGFtb3MgYW50ZSB1biBtb2RlbG8gcXVlIGFqdXN0YSByYXpvbmFibGVtZW50ZSBiaWVuIGEgbG9zIGRhdG9zLCB5IE1BU0U9ICRgciByb3VuZChhY2N1cmFjeShsaWJyb3NFdHMpWzZdLDIpYCQgaW5kaWNhIHF1ZSBlbCBtb2RlbG8gZGUgYWxpc2FkbyBleHBvbmVuY2lhbCBzaW1wbGUgcmVkdWNlIGVuIHNvbG8gdW4gJGByIDEwMCAtIHJvdW5kKDEwMCphY2N1cmFjeShsaWJyb3NFdHMpWzZdLDApYCQlIGVsIGVycm9yIGRlbCBtw6l0b2RvIGluZ2VudW8gSS4KCgojIyBQcmVkaWNjacOzbgoKTWVkaWFudGUgbGEgZnVuY2nDs24gYGZvcmVjYXN0YCBwb2RlbW9zIHByZWRlY2lyIGxvcyBjYXNvcyBkZSBMaWJyb3MuIFBvciB0cmF0YXJzZSBkZSB1biBtb2RlbG8gZGUgYWxpc2FkbyBleHBvbmVuY2lhbCBzaW1wbGUsIGxhIHByZWRpY2Npw7NuIGVzIGNvbnN0YW50ZSBlbiBlbCB0aWVtcG8gKHbDqWFzZSBmaWd1cmEgMTEpLgoKYGBge3J9CmxpYnJvc0V0c1ByZSA8LSBmb3JlY2FzdChsaWJyb3NFdHMsIGggPSA1KQpsaWJyb3NFdHNQcmUKYXV0b3Bsb3QobGlicm9zRXRzUHJlLAogICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgIHlsYWIgPSAiVMOtdHVsb3MiLAogICAgICAgICBtYWluID0gIkZpZ3VyYSAxMS4gTGlicm9zIHkgcHJlZGljY2nDs24gYSA1IGHDsW9zIHZpc3RhIikKYGBgCgojIyBBbsOhbGlzaXMgZGVsIGVycm9yCgpFbCBlcnJvciBkZSB1biBtb2RlbG8gZGUgYWxpc2FkbyBfY29udGllbmVfIGxhIGNvbXBvbmVudGUgZGUgX19JbnRlcnZlbmNpw7NuX18geSBlbCBwcm9waW8gdMOpcm1pbm8gZGUgX19FcnJvcl9fLiBWZXIgbnVtw6lyaWNhIG8gZ3LDoWZpY2FtZW50ZSBlbCBlcnJvciBwZXJtaXRlIGlkZW50aWZpY2FyIGbDoWNpbG1lbnRlIGxhIHByZXNlbmNpYSBkZSB2YWxvcmVzIGF0w61waWNvcyAoaW50ZXJ2ZW5jacOzbikuCgpFbCBtb2RlbG8gZGUgYWxpc2FkbyB0aWVuZSBlcnJvciBtdWx0aXBsaWNhdGl2byBhc8OtIHF1ZSBkZWJlbW9zIHVzYXIgZWwgYXJndW1lbnRvIGB0eXBlID0gInJlc3BvbnNlImAgcGFyYSBvYnRlbmVyIGVsIGVycm9yIGFkaXRpdm8gY29uIGByZXNpZHVhbHNgLgoKYGBge3J9CmVycm9yIDwtIHJlc2lkdWFscyhsaWJyb3NFdHMsIHR5cGUgPSAicmVzcG9uc2UiKQpzZGVycm9yIDwtIHNkKGVycm9yKQoKYXV0b3Bsb3QoZXJyb3IsIHNlcmllcz0iRXJyb3IiLAogICAgICAgICBjb2xvdXIgPSAiYmxhY2siLAogICAgICAgICB4bGFiID0gIlBlcmlvZG8iLAogICAgICAgICB5bGFiID0gIkVycm9yIiwKICAgICAgICAgbWFpbiA9ICJGaWd1cmEgMTI6IEVycm9yICsgSW50ZXJ2ZW5jacOzbiIpICsKICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSBjKC0zLCAtMiwgMiAsMykqc2RlcnJvciwgCiAgICAgICAgICAgICBjb2xvdXIgPSBjKCJyZWQiLCAiYmx1ZSIsICJibHVlIiwgInJlZCIpLCBsdHkgPSAyKSArIAogIHNjYWxlX3hfY29udGludW91cyhicmVha3M9IHNlcSgxOTkzLCAyMDE5LCAyKSkgCmBgYAoKTGEgZmlndXJhIDEyIG11ZXN0cmEgcXVlIGF1bnF1ZSBhbGfDum4gZXJyb3Igc3VwZXJhIGxhcyBkb3MgZGVzdmlhY2lvbmVzIHTDrXBpY2FzLCBuaW5ndW5vIHB1ZWRlIHNlciBjb25zaWRlcmFkbyBjb21vIGNsYXJhbWVudGUgYXTDrXBpY28uCgojIyBWYWxpZGFjacOzbjogZXJyb3IgZXh0cmEtbXVlc3RyYWwKClZhbW9zIGEgbWVqb3JhciBsYSBlc3RpbWFjacOzbiBkZSBsYSBjYWxpZGFkIGRlIGxhcyBwcmVkaWNjaW9uZXMgb2J0ZW5pZW5kbyBlbCBNQVBFIHBhcmEgX19wcmV2aXNpb25lcyBleHRyYS1tdWVzdHJhbGVzIGEgdmFyaW9zIHBlcmlvZG9zIHZpc3RhX18uIFBhcmEgZWxsbyB2YW1vcyBhIHJlc2VydmFyLCBwb3IgZWplbXBsbywgbGFzIMO6bHRpbWFzIDYgb2JzZXJ2YWNpb25lcyBkZSBsYSBzZXJpZSBMaWJyb3MgeSBhanVzdGFyIGVsIG1vZGVsbyBjb24gbGFzIHJlc3RhbnRlcy4gRGVzcHXDqXMgdXNhcmVtb3MgZXN0ZSBtb2RlbG8gcGFyYSBjYWxjdWxhciBsYXMgcHJlZGljY2lvbmVzIGEgNiBwZXJpb2RvcyB2aXN0YSB5IGNvbXBhcmFybGFzIGNvbiBsb3MgdmFsb3JlcyByZWFsZXMgZGUgbGEgc2VyaWUgTGlicm9zLiAKClJlY29yZGVtb3MgcXVlIGxvcyByZXN1bHRhZG9zIGRlcGVuZGVuIHRyZW1lbmRhbWVudGUgZGVsIHB1bnRvIGRlIGNvcnRlIHRlbXBvcmFsIHNlbGVjY2lvbmFkby4KCgpgYGB7cn0KIyBEZWZpbmltb3MgbGFzIG9ic2VydmFjaW9uZXMgaW50cmEtIHkgZXh0cmEtbXVlc3RyYWxlcwpsaWJyb3NJbnRyYSA8LSBzdWJzZXQobGlicm9zLCBlbmQgPSBsZW5ndGgobGlicm9zKSAtIDYpCmxpYnJvc0V4dHJhIDwtIHN1YnNldChsaWJyb3MsIHN0YXJ0ID0gbGVuZ3RoKGxpYnJvcykgLSA1KQoKIyBFc3RpbWFtb3MgZWwgbW9kZWxvIGNvbiB0b2RvcyBsb3MgZGF0b3MgbWVub3MgbG9zIDYgdWx0aW1vcwpsaWJyb3NJbnRyYUV0cyA8LSBldHMobGlicm9zSW50cmEsIG1vZGVsID0gIk1OTiIpCgojIFByZWRlY2ltb3MgbG9zIDcgYcOxb3MgcXVlIGhlbW9zIHF1aXRhZG8gZGUgbGEgc2VyaWUgeSAKIyB2ZW1vcyBsYSBjYWxpZGFkIGRlbCBhanVzdGUuCmxpYnJvc0V4dHJhUHJlIDwtIGZvcmVjYXN0KGxpYnJvc0ludHJhRXRzLCBoID0gNikKYWNjdXJhY3kobGlicm9zRXh0cmFQcmUsIGxpYnJvc0V4dHJhKQpgYGAKCmBgYHtyLCBlY2hvPUZBTFNFfQplcnJvci5tdWVzdHJhbC4xIDwtIHJvdW5kKGFjY3VyYWN5KGxpYnJvc0V4dHJhUHJlLCBsaWJyb3NFeHRyYSlbMSw1XSwgMSkKZXJyb3IuZXh0cmFtdWVzdHJhbC5uIDwtIHJvdW5kKGFjY3VyYWN5KGxpYnJvc0V4dHJhUHJlLCBsaWJyb3NFeHRyYSlbMiw1XSwxKQpgYGAKQXRlbmRpZW5kbyBhbCBNQVBFIHNlIHRpZW5lIHF1ZSBlbCBlcnJvciBkZSBfX3ByZXZpc2nDs24gYSB1biBwZXJpb2RvIHZpc3RhX18gZW4gZWwgX19wZXJpb2RvIGludHJhLW11ZXN0cmFsX18gZGUgX18xOTkzIGEgMjAxMl9fIGVzIGRlbCBgciBlcnJvci5tdWVzdHJhbC4xYCU7IG1pZW50cmFzIHF1ZSBlbCBlcnJvciBkZSBfX3ByZXZpc2nDs24gYSBsYXJnbyBwbGF6b19fIGVuIGVsIF9fcGVyaW9kbyBleHRyYS1tdWVzdHJhbF9fIGRlIF9fMjAxMyBhIDIwMThfXyBlcyBkZWwgYHIgZXJyb3IuZXh0cmFtdWVzdHJhbC5uYCUuIEFkZW1hcywgcGFyYSBlbCBwZXJpb2RvIGV4dHJhLW11ZXN0cmFsIGVsIGVycm9yIG1lZGlvIChNRSkgZXMgbmVnYXRpdm8geSBtdXkgZWxldmFkbywgdW4gaW5kaWNhdGl2byBkZSBxdWUgbGFzIHByZXZpc2lvbmVzIGVzdMOhbiBzZWdhZGFzLiBFbiByZXN1bWVuLCBsYSBjYWxpZGFkIGRlbCBtb2RlbG8gc2UgZGV0ZXJpb3JhIG11eSByw6FwaWRhbWVudGUgZW4gY3VhbnRvIG5vcyBzYWxpbW9zIGRlIGxhcyBjb25kaWNpb25lcyDDs3B0aW1hcy4gCgpVbiBncsOhZmljbyBwdWVkZSBheXVkYXIgYSBlbnRlbmRlciBlc3RlIHByb2Nlc28gZGUgdmFsaWRhY2nDs24uIEVuIGxhIGZpZ3VyYSAxMzoKCiogTGEgbMOtbmVhIGRlIHB1bnRvcyB2ZXJ0aWNhbCBzZXBhcmEgZWwgcGVyaW9kbyBtdWVzdHJhbCAoMTk5My0yMDEyKSB1c2FkbyBwYXJhIGVzdGltYXIgZWwgbW9kZWxvLCBkZWwgcGVyaW9kbyBleHRyYS1tdWVzdHJhbCAoMjAxMy0yMDE4KSB1c2FkbyBzw7NsbyBwYXJhIGhhY2VyIGxhcyBwcmV2aXNpb25lcy4KKiBMYSBzZXJpZSBMaWJyb3MgYXBhcmVjZSBjb21vIHVuYSBsw61uZWEgc8OzbGlkYSBlbiBuZWdybywgZGVzZGUgMTk5MyBoYXN0YSAyMDE4LgoqIExhIHByZXZpc2nDs24gX2ludHJhXy1tdWVzdHJhbCAoYSB1biBwZXJpb2RvIHZpc3RhKSBkZSBsYSBzZXJpZSBMaWJyb3MgYXBhcmVjZSBjb21vIHVuYSBsw61uZWEgYXp1bC4KKiBMYSBsw61uZWEgZW4gcm9qbyBlcyBsYSBwcmV2aXNpw7NuIF9leHRyYV8tbXVlc3RyYWwgYSBsYXJnbyBwbGF6bzogJFxoYXR7eX1fe1QraH09bF9UJCwgZG9uZGUgJFQ9MjAxMiQuIE9ic2VydmEgcXVlIHRvZGFzIGxhcyBwcmV2aXNpb25lcyBlc3TDoW4gcG9yIGVuY2ltYSBkZWwgdmFsb3IgcmVhbCBkZSBsYSBzZXJpZS4KKiBBbCBsYWRvIGRlIGNhZGEgcHJldmlzacOzbiBzZSBoYSBpbmRpY2FkbyBlbCBlcnJvciBlc3RpbWFkbyAoTUFQRSkuCgpDbGFyYW1lbnRlIGVzdG9zIHJlc3VsdGFkb3MgZGVwZW5kZW4gZGVsIHB1bnRvIGRlIGNvcnRlIHNlbGVjY2lvbmFkby4KCmBgYHtyLGVjaG89RkFMU0V9CmF1dG9wbG90KGxpYnJvcywgc2VyaWVzID0gIkxpYnJvcyIsCiAgICAgICAgIG1haW49IkZpZ3VyYSAxMy4gTGlicm9zLCBwcmVkaWNjacOzbiBpbnRyYS0geSBleHRyYS1tdWVzdHJhbCIsCiAgICAgICAgIHhsYWI9IiIsIAogICAgICAgICB5bGFiPSJUw610dWxvcyIKICAgICAgICAgKSArCiAgYXV0b2xheWVyKGZpdHRlZChsaWJyb3NJbnRyYUV0cyksIHNlcmllcyA9ICJMaWJyb3MgKGFqdXN0YWRhKSIpICsgCiAgYXV0b2xheWVyKGxpYnJvc0V4dHJhUHJlJG1lYW4sIHNlcmllcyA9ICJQcmVkaWNjacOzbiIpICsgCiAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMjAxMi41LCBsdHkgPSAyLCBjb2wgPSAiYmxhY2siKSArCiAgc2NhbGVfY29sb3VyX21hbnVhbCh2YWx1ZXM9YygiTGlicm9zIj0iYmxhY2siLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkxpYnJvcyAoYWp1c3RhZGEpIj0iYmx1ZSIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlByZWRpY2Npw7NuIiA9ICJyZWQiKSkgKwogIGd1aWRlcyhjb2xvdXIgPSBndWlkZV9sZWdlbmQodGl0bGUgPSAiU2VyaWVzIikpICsKICBhbm5vdGF0ZSgidGV4dCIsIHg9MTk5OSwgeT02NTAwMCwgbGFiZWw9IjcuMiUiLCBjb2xvdXIgPSAiYmx1ZSIpICsKICBhbm5vdGF0ZSgidGV4dCIsIHg9MjAxNiwgeT03MjAwMCwgbGFiZWw9IjE3LjglIiwgY29sb3VyID0gInJlZCIpICsKICB0aGVtZShsZWdlbmQucG9zaXRpb249YygwLjAyLDAuOTgpLCBsZWdlbmQuanVzdGlmaWNhdGlvbj1jKDAsMSkpIApgYGAKClwKXAoKX19Ob3RhOl9fIExhIHByZXNlbmNpYSBkZSB0ZW5kZW5jaWEsIHByaW1lcm8gY3JlY2llbnRlIHkgbHVlZ28gZGVjcmVjaWVudGUsIGVuIGxhIHNlcmllIExpYnJvcyBwdWVkZSBoYWNlcm5vcyBwZW5zYXIgcXVlIHVuIG1vZGVsbyBtw6FzIGFkZWN1YWRvIHBhcmEgc3UgYWp1c3RlIHkgcHJlZGljY2nDs24gc2Vyw61hIEVUUyhNLEEsTiksIGZvcnphbmRvIGEgcXVlIGhheWEgcGVuZGllbnRlLiBEZSBoZWNobywgZWwgZXJyb3IgZGUgZXN0aW1hY2nDs24gZGUgZXN0ZSBtb2RlbG8gZXMgZGVsIDYuMiUsIGZyZW50ZSBhbCA3JSBwYXJhIGVsIG1vZGVsbyBFVFMoTSxOLE4pLiBTaW4gZW1iYXJnbywgZWwgZXJyb3IgZGUgcHJldmlzacOzbiBleHRyYS1tdWVzdHJhbCBhIGxhcmdvIHBsYXpvIHBhcmEgZWwgbW9kZWxvIEVUUyhNLEEsTikgZXMgZGVsIDMxLjUlLCBmcmVudGUgYWwgMTcuOCUgcGFyYSBlbCBtb2RlbG8gRVRTKE0sTixOKS4gRGUgbnVldm8sIGluY2lkaXIgZW4gcXVlIG1heW9yIGNhbGlkYWQgZGUgYWp1c3RlIG5vIGltcGxpY2EgbWF5b3IgY2FsaWRhZCBkZSBwcmVkaWNjacOzbjsgeSBlbiBxdWUgZXN0b3MgcmVzdWx0YWRvcyBkZXBlbmRlbiBkZWwgcHVudG8gZGUgY29ydGUgc2VsZWNjaW9uYWRvLgoKIyBFamVtcGxvIGRlIGFwbGljYWNpw7NuOiBOYWNpbWllbnRvcwoKVmVhbW9zIHVuIHNlZ3VuZG8gZWplbXBsbyBjb24gbGEgc2VyaWUgTmFjaW1pZW50b3MgKGRlc2RlIGVsIGHDsW8gMjAwMCkuCgojIyBJZGVudGlmaWNhY2nDs24geSBlc3RpbWFjacOzbiBkZWwgbWVqb3IgbW9kZWxvCgpTaSBkYW1vcyB0b3RhbCBsaWJlcnRhZCBhbCBwcm9jZXNvIGRlIHNlbGVjY2nDs24gZGVsIG1lam9yIG1vZGVsbywgZWwgw7NwdGltbyB0aWVuZSB0ZW5kZW5jaWEgYW1vcnRpZ3VhZGEgY29uIHVuIHBhcsOhbWV0cm8gJFxwaGkgPSAwLjk4JCwgc3UgbcOheGltbyB2YWxvciBwZXJtaXRpZG8uIEVzdGUgcmVzdWx0YWRvIGFjb25zZWphIHJlcGV0aXIgZWwgcHJvY2VzbyBkZSBzZWxlY2Npw7NuIGRlbCBtb2RlbG8gcmVzdHJpbmdpZG8gYSBhcXVlbGxvcyBzaW4gYW1vcnRpZ3VhbWllbnRvLgoKYGBge3J9Cm5hY2ltaWVudG9zRXRzIDwtIGV0cyhuYWNpbWllbnRvc2IsIGRhbXBlZCA9IEZBTFNFKQpzdW1tYXJ5KG5hY2ltaWVudG9zRXRzKSAKYGBgCgpFbCBtb2RlbG8gZXN0aW1hZG8gZXMgRVRTKE0sQSxBKSwgZXMgZGVjaXIsICR5X3t0KzF9ID0gKGxfdCArIGJfdCArICBzX3t0KzEtbX0pIFxjZG90ICgxKyBcdmFyZXBzaWxvbl97dCsxfSkkLgoKRWwgYmFqbyB2YWxvciBkZSAkXGJldGEkIHkgJFxnYW1tYSQgaW5kaWNhbiBxdWUgYW1iYXMsIGxhIHBlbmRpZW50ZSB5IGxhIGVzdGFjaW9uYWxpZGFkLCB2YXLDrWFuIG11eSBsZW50YW1lbnRlIGVuIGVsIHRpZW1wbyAodsOpYXNlIGxhIGZpZ3VyYSAxNCkuIAoKYGBge3J9CmF1dG9wbG90KG5hY2ltaWVudG9zRXRzLAogICAgICAgICB4bGFiID0gIlBlcmlvZG8iLAogICAgICAgICBtYWluID0gIkZpZ3VyYSAxNC4gQ29tcG9uZW50ZXMgZGVsIG1vZGVsbyDDs3B0aW1vIHBhcmEgTmFjaW1pZW50b3MiKQpgYGAKClJlc3BlY3RvIGRlIGxhIGNhbGlkYWQgZGVsIG1vZGVsbywgZWwgTUFQRSBkZSBgciByb3VuZChhY2N1cmFjeShuYWNpbWllbnRvc0V0cylbNV0sMSlgJSBpbmRpY2EgcXVlIGVzdGFtb3MgYW50ZSB1biBtb2RlbG8gcXVlIHNlIGFqdXN0YSBtdXkgYmllbiBhIGxvcyBkYXRvczsgeSBlbCB2YWxvciBkZSBNQVNFIGlndWFsIGEgYHIgcm91bmQoc3VtbWFyeShuYWNpbWllbnRvc0V0cylbNl0sMilgIGluZGljYSBxdWUgZXN0ZSBtb2RlbG8gcmVkdWNlIGVuIHVuIGByIDEwMCAtIHJvdW5kKDEwMCpzdW1tYXJ5KG5hY2ltaWVudG9zRXRzKVs2XSwwKWAlIGVsIGVycm9yIGRlbCBtw6l0b2RvIGluZ2VudW8gY29uIGVzdGFjaW9uYWxpZGFkLCBlbCBtw6FzIHNlbmNpbGxvIHBvc2libGUsIHF1ZSB5YSB1dGlsaXphbW9zIGVuIGVsIGVww61ncmFmZSAzIChhdW5xdWUgcGFyYSBsYSBzZXJpZSBuYWNpbWllbnRvcyBjb21wbGV0YSkuCiAgICAgIApQb2RlbW9zIHZlciBsb3Mgw7psdGltb3MgdmFsb3JlcyBlc3RpbWFkb3MgZGVsIG5pdmVsLCBsYSBwZW5kaWVudGUgeSBsYSBlc3RhY2lvbmFsaWRhZCBwYXJhIGludGVycHJldGFybG9zLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KVFQgPC0gbnJvdyhuYWNpbWllbnRvc0V0cyRzdGF0ZXMpCm5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCxdCmBgYAoKYGBge3IsIGVjaG8gPSBGQUxTRX0KVFQgPC0gbnJvdyhuYWNpbWllbnRvc0V0cyRzdGF0ZXMpCnJvdW5kKG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCxdLDIpWzE6N10Kcm91bmQobmFjaW1pZW50b3NFdHMkc3RhdGVzW1RULF0sMilbODoxNF0KYGBgCgpUYW1iacOpbiBwb2RlbW9zIHVzYXJsb3MgcGFyYSBwcmVkZWNpciB1biBhw7FvOgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpuYWNpbWllbnRvc0V0cyRzdGF0ZXNbVFQsIDFdICsgKDE6MTIpICogbmFjaW1pZW50b3NFdHMkc3RhdGVzW1RULCAyXSArIAogIG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCwgMTQ6M10KYGBgCgpgYGB7ciwgZWNobyA9IEZBTFNFfQpuYWNpbWllbnRvc0V0cyRzdGF0ZXNbVFQsIDFdICsgKDE6MTIpICogbmFjaW1pZW50b3NFdHMkc3RhdGVzW1RULCAyXSArIG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCwgMTQ6M10KYGBgCgpGZWJyZXJvIGVzIGVsIG1lcyBjb24gbWVub3IgbsO6bWVybyBkZSBuYWNpbWllbnRvczogbmFjZW4gYHIgYWJzKHRydW5jKG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCwxM10pKWAgYmViw6lzIG1lbm9zLCByZXNwZWN0byBkZSBsYSBtZWRpYSBhbnVhbC4gRW4gb2N0dWJyZSBlcyBjdWFuZG8gbcOhcyBuacOxb3MgbmFjZW46IGByIHRydW5jKG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCw1XSlgIG3DoXMgcXVlIGxhIG1lZGlhIGFudWFsLgoKTnVlc3RyYSBwcmVkaWNjacOzbiBwYXJhIGVuZXJvIGRlIDIwMTkgZXMgZGUgYHIgYXMuaW50ZWdlcigobmFjaW1pZW50b3NFdHMkc3RhdGVzW1RULCAxXSArICBuYWNpbWllbnRvc0V0cyRzdGF0ZXNbVFQsIDJdKSArIG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCwgMTRdKWAgYmViw6lzIHkgcGFyYSBkaWNpZW1icmUgZGUgMjAxOSBkZSBgciBhcy5pbnRlZ2VyKChuYWNpbWllbnRvc0V0cyRzdGF0ZXNbVFQsIDFdICsgMTIgKiBuYWNpbWllbnRvc0V0cyRzdGF0ZXNbVFQsIDJdKSArIG5hY2ltaWVudG9zRXRzJHN0YXRlc1tUVCwgM10pYCBiZWLDqXMuCgojIyBQcmVkaWNjacOzbgoKU2kgcGVkaW1vcyBsb3MgdmFsb3JlcyBkZSBwcmVkaWNjacOzbiB0ZW5lbW9zIChzw7NsbyBzZSBtdWVzdHJhbiBsb3MgcHJpbWVyb3MgbWVzZXMpOgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpuYWNpbWllbnRvc0V0c1ByZSA8LSBmb3JlY2FzdChuYWNpbWllbnRvc0V0cywgaCA9IDI0LCBsZXZlbCA9IDk1KQpuYWNpbWllbnRvc0V0c1ByZQpgYGAKCmBgYHtyLCBlY2hvID0gRkFMU0V9Cm5hY2ltaWVudG9zRXRzUHJlIDwtIGZvcmVjYXN0KG5hY2ltaWVudG9zRXRzLCBoID0gMjQsIGxldmVsID0gOTUpCmZvcmVjYXN0KG5hY2ltaWVudG9zRXRzLCBoID0gNSwgbGV2ZWwgPSA5NSkKYGBgCgpHcsOhZmljYW1lbnRlLApgYGB7cn0KYXV0b3Bsb3QobmFjaW1pZW50b3NFdHNQcmUsCiAgICAgICAgIHhsYWIgPSAiIiwKICAgICAgICAgeWxhYiA9ICJCZWLDqXMiLAogICAgICAgICBtYWluID0gIkZpZ3VyYSAxNS4gTmFjaW1pZW50b3MgeSBwcmVkaWNjacOzbiIpCmBgYAoKIyMgQW7DoWxpc2lzIGRlbCBlcnJvcgoKRWwgbW9kZWxvIGRlIGFsaXNhZG8gdGllbmUgZXJyb3IgbXVsdGlwbGljYXRpdm8gYXPDrSBxdWUgZGViZW1vcyB1c2FyIGVsIGFyZ3VtZW50byBgdHlwZSA9ICJyZXNwb25zZSJgIHBhcmEgb2J0ZW5lciBlbCBlcnJvciBhZGl0aXZvIGNvbiBgcmVzaWR1YWxzYC4KCmBgYHtyfQplcnJvciA8LSByZXNpZHVhbHMobmFjaW1pZW50b3NFdHMsIHR5cGUgPSAicmVzcG9uc2UiKQpzZGVycm9yIDwtIHNkKGVycm9yKQoKYXV0b3Bsb3QoZXJyb3IsIHNlcmllcz0iRXJyb3IiLAogICAgICAgICBjb2xvdXIgPSAiYmxhY2siLAogICAgICAgICB4bGFiID0gIlBlcmlvZG8iLAogICAgICAgICB5bGFiID0gIkVycm9yIiwKICAgICAgICAgbWFpbiA9ICJGaWd1cmEgMTY6IEVycm9yICsgSW50ZXJ2ZW5jacOzbiIpICsKICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSBjKC0zLCAtMiwgMiAsMykqc2RlcnJvciwgCiAgICAgICAgICAgICBjb2xvdXIgPSBjKCJyZWQiLCAiYmx1ZSIsICJibHVlIiwgInJlZCIpLCBsdHkgPSAyKSArIAogIHNjYWxlX3hfY29udGludW91cyhicmVha3M9IHNlcSgyMDAwLCAyMDE5LCAyKSkgCmBgYAoKU2UgaWRlbnRpZmljYSB1biB2YWxvciBjbGFyYW1lbnRlIGF0w61waWNvIC0tc3VwZXJhIGxhcyA0IGRlc3ZpYWNpb25lcyB0w61waWNhcy0tIHF1ZSBjb3JyZXNwb25kZSBhIGVuZXJvIGRlIDIwMTEuIEFicmlsIGRlIDIwMDggZXMgb3RybyBjYW5kaWRhdG8gYSBpbnRlcnZlbmNpw7NuIHBvciBhbGNhbnphciBsYXMgMyBkZXN2aWFjaW9uZXMgdMOtcGljYXMuCgojIyBWYWxpZGFjacOzbjogZXJyb3IgZXh0cmEtbXVlc3RyYWwKCkVuIGVzdGUgY2FzbyB2YW1vcyBhIGFwbGljYXIgbGEgbWV0b2RvbG9nw61hIF9fb3JpZ2VuIGRlIHByZWRpY2Npw7NuIG3Ds3ZpbF9fIChfcm9sbGluZyBmb3JlY2FzdCBvcmlnaW5fKSBvIF9yb2xsaW5nIHdpbmRvd3NfLiBBc3VtaW1vcyBxdWUgc2UgcHJlY2lzYW4gZGlleiBhw7FvcyBwYXJhIGhhY2VyIHVuYSBidWVuYSBlc3RpbWFjacOzbiwgJGs9MTIwJCwgeSBxdWUgZWwgaG9yaXpvbnRlIHRlbXBvcmFsIGVzIGRlIDEyIG1lc2VzLCAkaCA9IDEyJC4gTGEgc2lndWllbnRlIHJ1dGluYSBwZXJtaXRlIG9idGVuZXIgZWwgTUFQRSBwYXJhIHByZXZpc2lvbmVzIGNvbiB1biBob3Jpem9udGUgdGVtcG9yYWwgZGVzZGUgdW5vIGEgZG9jZSBtZXNlcy4KICAKYGBge3J9ICAKayA8LSAxMjAgICAgICAgICAgICAgICAgICAjTWluaW1vIG51bWVybyBkZSBkYXRvcyBwYXJhIGVzdGltYXIKaCA8LSAxMiAgICAgICAgICAgICAgICAgICAjSG9yaXpvbnRlIGRlIGxhcyBwcmVkaWNpY2lvbmVzClRUIDwtIGxlbmd0aChuYWNpbWllbnRvc2IpICAgICNMb25naXR1ZCBzZXJpZQpzIDwtIFRUIC0gayAtIGggICAgICAgICAgICNUb3RhbCBkZSBlc3RpbWFjaW9uZXMKCm1hcGVFdHMgPC0gbWF0cml4KE5BLCBzICsgMSwgaCkKZm9yIChpIGluIDA6cykgewogIHRyYWluLnNldCA8LSBzdWJzZXQobmFjaW1pZW50b3NiLCBzdGFydCA9IGkgKyAxLCBlbmQgPSBpICsgaykKICB0ZXN0LnNldCA8LSAgc3Vic2V0KG5hY2ltaWVudG9zYiwgc3RhcnQgPSBpICsgayArIDEsIGVuZCA9IGkgKyBrICsgaCkKICAKICBmaXQgPC0gZXRzKHRyYWluLnNldCwgIG1vZGVsID0gIk1BQSIsIGRhbXBlZCA9IEZBTFNFKQogIGZjYXN0IDwtIGZvcmVjYXN0KGZpdCwgaCA9IGgpCiAgbWFwZUV0c1tpICsgMSxdIDwtIDEwMCphYnModGVzdC5zZXQgLSBmY2FzdCRtZWFuKS90ZXN0LnNldAp9CgptYXBlRXRzIDwtIGNvbE1lYW5zKG1hcGVFdHMpCnJvdW5kKG1hcGVFdHMsIDIpCmBgYAoKRWwgZXJyb3IgZXh0cmEtbXVlc3RyYWwgYSB1biBwZXJpb2RvIHZpc3RhIGVzIGNvbXBhcmFibGUgYWwgZXJyb3IgaW50cmEtbXVlc3RyYWwgKDEuOSUgZnJlbnRlIGEgMS44JSkuIEF1bnF1ZSBlbCBlcnJvciBkZSBwcmV2aXNpw7NuIGF1bWVudGEgY29uZm9ybWUgbG8gaGFjZSBlbCBob3Jpem9udGUgdGVtcG9yYWwsIHNpZW1wcmUgc2UgbWFudGllbmUgbXV5IGJham8uIFBvciBlamVtcGxvLCBlbiBsYXMgcHJldmlzaW9uZXMgYSAxMiBtZXNlcyB2aXN0YSBlbCBlcnJvciBlcyBkZWwgMy41JS4KClwKCiMjIE90cmFzIGFsdGVybmF0aXZhcyBwYXJhIHByZWRlY2lyIE5hY2ltaWVudG9zCgpBIGxhIGhvcmEgZGUgcHJlZGVjaXIgaGF5IHF1ZSBzZXIgdW4gcG9jbyBpbWFnaW5hdGl2b3MsIGRlZGljYXJsZSB0aWVtcG8geSBwcm9iYXIgY29zYXMuIFBvciBlamVtcGxvLCBwb2Ryw61hbW9zIHByZWRlY2lyIGxvcyBuYWNpbWllbnRvcyBhIHBhcnRpciBkZWwgYWp1c3RlIGRlIGxhIHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EuIE8gcG9kZW1vcyBwcm9iYXIgYSBjYW1iaWFyIGVsIGNyaXRlcmlvIGRlIGVzdGltYWNpw7NuIGRlIGxvcyBwYXLDoW1ldHJvcyBvIGVsIGRlIHNlbGVjY2nDs24gZGVsIG1vZGVsbyDDs3B0aW1vLgoKWWVuZG8gdW4gcG9jbyBtw6FzIGxlam9zLCB5IGRhZG8gcXVlIGVsIG7Dum1lcm8gZGUgbmFjaW1pZW50b3MgZGVwZW5kZSBmb3J6b3NhbWVudGUgZGVsIG7Dum1lcm8gZGUgZMOtYXMgZGVsIG1lcywgcG9kZW1vcyBwcmVkZWNpciBsb3MgbmFjaW1pZW50b3MgbWVkaW9zIHBvciBkw61hIChjb2NpZW50ZSBlbnRyZSBsb3MgbmFjaW1pZW50b3MgZGUgY2FkYSBtZXMgeSBlbCBuw7ptZXJvIGRlIGTDrWFzIGRlbCBtZXMpLiBFc3RhIHNlcmllIHRlbmRyw6EgdW5hIGNvbXBvbmVudGUgZXN0YWNpb25hbCBtw6FzIHN1YXZlLCBlbGltaW5hIGVsIGVmZWN0byBkZSBsb3MgZmVicmVyb3MgYmlzaWVzdG9zIHkgdGVuZHLDoSwgcHJldmlzaWJsZW1lbnRlIHVuIG1lam9yIGFqdXN0ZS4KClRhbWJpw6luIHBvZGVtb3MgbWV6Y2xhciB2YXJpb3MgZGUgbG9zIGVuZm9xdWVzIHByZXZpb3MgbyBzZXIgYcO6biBtw6FzIGltYWdpbmF0aXZvcy4KCkVsIHNpZ3VpZW50ZSBjw7NkaWdvIG11ZXN0cmEgZWwgTUFQRSAocGFyYSBwcmV2aXNpb25lcyBpbnRyYS1tdWVzdHJhbGVzIGEgdW4gcGVyaW9kbyB2aXN0YSkgcGFyYSB2YXJpYXMgZGUgZXN0YXMgb3BjaW9uZXMuIFB1ZWRlcyBkZWR1Y2lyIHF1ZSBzZSBlc3TDoSBoYWNpZW5kbyBlbiBjYWRhIGNhc28gYSBwYXJ0aXIgZGVsIGPDs2RpZ28uIFNlcsOtYSBtw6FzIGFkZWN1YWRvIHVzYXIgb3RybyBjcml0ZXJpbyBkZSB2YWxpZGFjacOzbiBkaWZlcmVudGUsIHBlcm8gZWwgb2JqZXRpdm8gZGUgZXN0ZSBlcMOtZ3JhZmUgZXMgcmVjYWxjYXIgcXVlIG5vIGhheSBxdWUgcXVlZGFyc2UgY29uIGxvIGlubWVkaWF0byAocHJlZGVjaXIgTmFjaW1pZW50b3MgY29uIGxhcyBvcGNpb25lcyBwb3IgZGVmZWN0byBkZSBsYXMgZnVuY2lvbmVzKSwgc2lubyBwcm9iYXIgeSBwcm9iYXIuCgpgYGB7cn0KIyBTZXJpZSBOYWNpbWllbnRvcwphY2N1cmFjeShldHMobmFjaW1pZW50b3NiLCAKICAgICAgICAgICAgIGRhbXBlZCA9IEZBTFNFKSlbNV0KYWNjdXJhY3koZXRzKG5hY2ltaWVudG9zYiwgCiAgICAgICAgICAgICBkYW1wZWQgPSBGQUxTRSwgCiAgICAgICAgICAgICBvcHQuY3JpdCA9ICJtc2UiKSlbNV0KCiMgVHJhbnNmb3JtYWNpw7NuIGxvZ2Fyw610bWljYQphY2N1cmFjeShldHMobmFjaW1pZW50b3NiLCAKICAgICAgICAgICAgIGxhbWJkYSA9IDAsIAogICAgICAgICAgICAgZGFtcGVkID0gRkFMU0UpKVs1XQphY2N1cmFjeShldHMobmFjaW1pZW50b3NiLCAKICAgICAgICAgICAgIGxhbWJkYSA9IDAsIAogICAgICAgICAgICAgZGFtcGVkID0gRkFMU0UsIAogICAgICAgICAgICAgb3B0LmNyaXQgPSAibXNlIikpWzVdCgojIFRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EgaW5zZXNnYWRhCmFjY3VyYWN5KGV0cyhuYWNpbWllbnRvc2IsIAogICAgICAgICAgICAgbGFtYmRhID0gMCwgCiAgICAgICAgICAgICBiaWFzYWRqID0gVFJVRSwKICAgICAgICAgICAgIGRhbXBlZCA9IEZBTFNFKSlbNV0KYWNjdXJhY3koZXRzKG5hY2ltaWVudG9zYiwgCiAgICAgICAgICAgICBsYW1iZGEgPSAwLCAKICAgICAgICAgICAgIGJpYXNhZGogPSBUUlVFLAogICAgICAgICAgICAgZGFtcGVkID0gRkFMU0UsIAogICAgICAgICAgICAgb3B0LmNyaXQgPSAibXNlIikpWzVdCgojIE5hY2ltaWVudG9zIHBvciBkaWEKYWNjdXJhY3koZXRzKG5hY2ltaWVudG9zYi9tb250aGRheXMobmFjaW1pZW50b3NiKSwgCiAgICAgICAgICAgICBkYW1wZWQgPSBGQUxTRSkpWzVdCmFjY3VyYWN5KGV0cyhuYWNpbWllbnRvc2IvbW9udGhkYXlzKG5hY2ltaWVudG9zYiksIAogICAgICAgICAgICAgZGFtcGVkID0gRkFMU0UsIAogICAgICAgICAgICAgb3B0LmNyaXQgPSAibXNlIikpWzVdCmBgYAoKTGEgcHJpbmNpcGFsIGNvbmNsdXNpw7NuIGVuIGVzdGUgY2FzbyBlcyBxdWUgc2FsaXJzZSBkZSBsYSBlc3RpbWFjacOzbiBkaXJlY3RhIHNvYnJlIGxhIHNlcmllIG9yaWdpbmFsIG5vIHJlZHVjZSBlbCBlcnJvciBzaWduaWZpY2F0aXZhbWVudGUuIFNpbiBlbWJhcmdvLCBjYWJlIGRlc3RhY2FyIHF1ZSwgCgoqIEVsIGVycm9yIGRlIGVzdGltYWNpw7NuIGRlIGxvcyBuYWNpbWllbnRvcyBwb3IgZMOtYSBlcyBtZW5vciwgYWwgdHJhdGFyc2UgZGUgdW5hIHNlcmllIGNvbiBtZWpvciBjb21wb3J0YW1pZW50bywgYXVucXVlIGxhIGdhbmFuY2lhIG5vIGVzIG11Y2hhLiAoVsOpYW5zZSBsb3MgZG9zIMO6bHRpbW9zIG1vZGVsb3MgcmVzcGVjdG8gZGUgbG9zIGRvcyBwcmltZXJvcykKKiBVc2FyIGxhIHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EgKGNvbiBvIHNpbiBwcmVkaWNjaW9uZXMgaW5zZXNnYWRhcykgbm8gbWVqb3JhIGxhIGNhcGFjaWRhZCBwcmVkaWN0aXZhIGRlbCBtb2RlbG8uIChWw6lhbnNlIGxvcyBtb2RlbG9zIDMgYSA2IHJlc3BlY3RvIGRlIGxvcyBtb2RlbG9zIDEgeSAyKQoqIEVsIG1lam9yIG1vZGVsbyBlc3RpbWEgbG9zIG5hY2ltaWVudG9zIHBvciBkw61hIHkgZXN0aW1hIGxvcyBwYXLDoW1ldHJvcyBtaW5pbWl6YW5kbyBlbCBlcnJvciBjdWFkcsOhdGljbyBtZWRpbyAoIm1zZSIpLiBUb2RvIG1lbm9zIGxvIF9kaXJlY3RvXy4KCgpcClwKCiMgUmVzdW1lbiBkZSBsb3MgY29tYW5kb3MgdXRpbGl6YWRvcwoKCnxGdW5jacOzbiAgfFBhcXVldGUgfCBEZXNjcmlwY2nDs24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfAp8Oi0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18CnxgbWVhbmZgICAgICAgICB8Zm9yZWNhc3QgIHxQcmVkaWNjacOzbiBwb3IgbWVkaWEgfAp8YG5haXZlYCAgICAgICAgfGZvcmVjYXN0ICB8UHJlZGljY2nDs24gcG9yIG3DqXRvZG8gaW5nZW51byBJIHwKfGByd2ZgICAgICAgICAgIHxmb3JlY2FzdCAgfFByZWRpY2Npw7NuIGNvbiB0ZW5kZW5jaWEgbWVkaWEgfAp8YHNuYWl2ZWAJICAgICAgfGZvcmVjYXN0ICB8UHJlZGljY2nDs24gcG9yIG3DqXRvZG8gaW5nZW51byBjb24gZXN0YWNpb25hbGlkYWQgfAp8YGFjY3VyYWN5YAkgICAgfGZvcmVjYXN0ICB8Q2FsY3VsbyBkZSBsYSBwcmVjaXNpw7NuIGRlbCBtb2RlbG8gfAp8YGZvcmVjYXN0YCAgICAgfGZvcmVjYXN0ICB8UHJlZGljZSB2YWxvcmVzIGV4dHJhLW11ZXN0cmFsZXMgZnV0dXJvcyBkZSBsYSBzZXJpZSB8Cnxgc2VzYCAgICAgICAgICB8Zm9yZWNhc3QgIHxFc3RpbWFjacOzbiBkZWwgbW9kZWxvIGRlIGFsaXNhZG8gZXhwb25lbmNpYWwgc2ltcGxlfAp8YGhvbHRgICAgICAgICAgfGZvcmVjYXN0ICAgfEVzdGltYWNpw7NuIGRlbCBtb2RlbG8gZGUgYWxpc2FkbyBleHBvbmVuY2lhbCBkZSBIb2x0fAp8YGh3YCAgICAgICAgICAgfGZvcmVjYXN0IHxFc3RpbWFjacOzbiBkZWwgbW9kZWxvIGRlIGFsaXNhZG8gZXhwb25lbmNpYWwgZGUgSG9sdC1XaW50ZXJzfAp8YGV0c2AgICAgICAgICAgfGZvcmVjYXN0ICB8RXN0aW1hY2nDs24gZGUgdW5hIGFtcGxpYSBmYW1pbGlhIGRlIG3DqXRvZG9zIGRlIGFsaXNhZG8gZXhwb25lbmNpYWx8CnxgcmVzaWR1YWxzYCAgICB8c3RhdHMgICB8T2J0aWVuZSBlbCByZXNpZHVvIGRlIHVuIG1vZGVsbyBlc3RpbWFkb3wKfGBmaXR0ZWRgICAgICAgIHxzdGF0cyAgICAgfE9idGllbmUgbGFzIHByZWRpY2Npb25lcyBhIHVuIHBlcmlvZG8gdmlzdGEgaW50cmEtbXVlc3RyYWxlc3wKClwKXAoKIyBSZWZlcmVuY2lhcwoKKiBCcm93biwgUi4gRy4gKDE5NTkpLiBfU3RhdGlzdGljYWwgZm9yZWNhc3RpbmcgZm9yIGludmVudG9yeSBjb250cm9sXy4gRWQuIE1jR3Jhdy9IaWxsLgoKKiBHYXJkbmVyLCBKciwgRS4gUy4geSBNY0tlbnppZSwgRS4gKDE5ODUpIF9Gb3JlY2FzdGluZyB0cmVuZHMgaW4gdGltZSBzZXJpZXNfLCBNYW5hZ2VtZW50IFNjaWVuY2UsIDMxKDEwKSwgcHAuIDEyMzfigJMxMjQ2LiBkb2k6MTAuMTI4Ny9tbnNjLjMxLjEwLjEyMzcKCiogSG9sdCwgQy4gRS4gKDE5NTcpLiBfRm9yZWNhc3Rpbmcgc2Vhc29uYWxzIGFuZCB0cmVuZHMgYnkgZXhwb25lbnRpYWxseSB3ZWlnaHRlZCBhdmVyYWdlc18gTy5OLlIuIE1lbW9yYW5kdW0gTm8uIDUyLiBDYXJuZWdpZSBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgUGl0dHNidXJnaCBVU0EuIGRvaToxMC4xMDE2L2ouaWpmb3JlY2FzdC4yMDAzLjA5LjAxNQoKKiBIeW5kbWFuLCBSLiBKLiB5IEtoYW5kYWthciwgWS4gKDIwMDgpIF9BdXRvbWF0aWMgVGltZSBTZXJpZXMgRm9yZWNhc3Rpbmc6IFRoZSBmb3JlY2FzdCBQYWNrYWdlIGZvciBSXy4gSm91cm5hbCBvZiBTdGF0aXN0aWNhbCBTb2Z0d2FyZSwgMjcoMyksIHBwLiAxLTIyLiBkb2k6MTAuMTg2MzcvanNzLnYwMjcuaTAzCgoqIEh5bmRtYW4sIFIuIEouLCBLb2VobGVyLCBBLiwgQi4sIE9yZCwgSi4gSy4geSBTbnlkZXIsIFIuIEQuICgyMDA4KSBfRm9yZWNhc3Rpbmcgd2l0aCBFeHBvbmVudGlhbCBTbW9vdGhpbmc6IHRoZSBTdGF0ZSBTcGFjZSBBcHByb2FjaF8uIEVkLiBTcHJpbmdlci4KCiogTWFrcmlkYWtpcywgUy4geSAgSGlib24sIE0uICgyMDAwKS4gX1RoZSBNMy1Db21wZXRpdGlvbjogcmVzdWx0cywgY29uY2x1c2lvbnMgYW5kIGltcGxpY2F0aW9uc18uIEludGVybmF0aW9uYWwgSm91cm5hbCBvZiBGb3JlY2FzdGluZywgMTYoNCksIHBwLiA0NTHigJM0NzYuIGRvaToxMC4xMDE2L1MwMTY5LTIwNzAoMDApMDAwNTctMQoKKiBXaW50ZXJzLCBQLiBSLiAoMTk2MCkuIF9Gb3JlY2FzdGluZyBzYWxlcyBieSBleHBvbmVudGlhbGx5IHdlaWdodGVkIG1vdmluZyBhdmVyYWdlc18uIE1hbmFnZW1lbnQgU2NpZW5jZSwgNiwgcHAuIDMyNOKAkzM0Mi4gIGRvaToxMC4xMjg3L21uc2MuNi4zLjMyNAoKXApcClwKXAo=</div>
<footer class="footer">
  
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
<br>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.  <div class="text-muted">Website created by Iv&aacute;n Arribas. &copy;  2020. If you find any bugs please report them to <a href="mailto:ivan.arribas@uv.es"> ivan.arribas@uv.es</a>.</div>
  
</footer>




</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("03-02-Tema2.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
