<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Iván Arribas (Depto. Análisis Económico. Universitat de València)">

<title>Series Temporales - Bootstrapping para obtener intervalos de predicción</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Series Temporales</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./01-Guia-curso.html"> 
<span class="menu-text">Guía del curso</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./02-Logistica.html"> 
<span class="menu-text">Logística</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-diapos" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Diapos</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-diapos">    
        <li class="dropdown-header">Teoría</li>
        <li>
    <a class="dropdown-item" href="./03-01-Tema1.html">
 <span class="dropdown-text">Tema 1: Definicion y Componentes</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-02-Tema2.html">
 <span class="dropdown-text">Tema 2: Alisado</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-03-Tema3.html">
 <span class="dropdown-text">Tema 3: Procesos estocásticos</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-04-Tema4.html">
 <span class="dropdown-text">Tema 4: ARIMA</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-05-Tema5.html">
 <span class="dropdown-text">Tema 5: SARIMA</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Ejemplo de aplicación</li>
        <li>
    <a class="dropdown-item" href="./03-06-Ejemplo1.html">
 <span class="dropdown-text">Ejemplo Tema 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-07-Ejemplo2.html">
 <span class="dropdown-text">Ejemplo Tema 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-08-Ejemplo3.html">
 <span class="dropdown-text">Ejemplo Tema 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-09-Ejemplo4.html">
 <span class="dropdown-text">Ejemplo Tema 4</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./03-10-Ejemplo5.html">
 <span class="dropdown-text">Ejemplo Tema 5</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Otro ejemplo</li>
        <li>
    <a class="dropdown-item" href="./03-11-Ejemplo-Pasajeros.html">
 <span class="dropdown-text">Ejemplo de Pasajeros</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-píldoras" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Píldoras</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-píldoras">    
        <li>
    <a class="dropdown-item" href="./04-01-Bootstrapping.html">
 <span class="dropdown-text">Bootstrapping para IC</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-02-Multiples_CS.html">
 <span class="dropdown-text">Múltiples componentes estacionales</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-03-Redes_neuronales.html">
 <span class="dropdown-text">Predicción con Redes Neuronales</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-04-Series_acotadas.html">
 <span class="dropdown-text">Series acotadas</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-05-Valores_perdidos_Outliers.html">
 <span class="dropdown-text">Valores perdidos y outliers</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-06-Covid_Nacimientos.html">
 <span class="dropdown-text">Efecto de la Covid-19 en Nacimientos</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-07-Combinando_predicciones.html">
 <span class="dropdown-text">Combinación de predicciones</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04-08-Series_interrumpidas.html">
 <span class="dropdown-text">Series interrumpidas</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="./05-Recursos-R.html"> 
<span class="menu-text">Recursos de la asignatura</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./06-Practica.html"> 
<span class="menu-text">Practica</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-más" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Más</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-más">    
        <li class="dropdown-header">R</li>
        <li>
    <a class="dropdown-item" href="https://cran.r-project.org">
 <span class="dropdown-text">Dónde está R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://rstudio.com">
 <span class="dropdown-text">Donde está RStudio</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Markdown</li>
        <li>
    <a class="dropdown-item" href="https://bookdown.org/yihui/rmarkdown/">
 <span class="dropdown-text">Markdown</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://rmarkdown.rstudio.com/lesson-1.html">
 <span class="dropdown-text">R Markdown</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">
 <span class="dropdown-text">R Markdown (pdf)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://quarto.org/docs/tools/rstudio.html">
 <span class="dropdown-text">Quatro</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Otros</li>
        <li>
    <a class="dropdown-item" href="https://www.r-bloggers.com">
 <span class="dropdown-text">Blog sobre R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://bookdown.org">
 <span class="dropdown-text">Libros online que debes conocer</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bootstrapping para obtener intervalos de predicción</h1>
<p class="subtitle lead">Máster de Bioestadística (Modelización Estadística)</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Iván Arribas (Depto. Análisis Económico. Universitat de València) </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p><br>
<br>
</p>
<section id="antecedentes" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Antecedentes</h1>
<p>En el curso hemos aprendido como obtener predicciones puntuales con diferentes métodos: Ingenuo I, Deriva, Ingenuo con estacionalidad, Alisado Exponencial… Por <em>aprendido</em> quiero decir que conocemos la fórmula para calcular la predicción, que sabríamos hacer las predicciones a mano y que en algunas clases de práctica así lo hemos hecho.</p>
<p>También hemos aprendido a obtener intervalos de predicción, aunque nunca hemos visto las fórmulas que hay detrás de estos intervalos. De forma general, si <span class="math inline">\(\hat y_{T+h|T}\)</span> es la predicción a <span class="math inline">\(h\)</span> periodos vista, su intervalo de predicción se puede escribir como</p>
<p><span class="math display">\[[\hat y_{T+h|T} - c\cdot \hat \sigma_h,\;\; \hat y_{T+h|T} + c\cdot \hat \sigma_h]\]</span> donde <span class="math inline">\(c\)</span> depende del nivel de confianza del intervalo de predicción, por ejemplo <span class="math inline">\(c=1.96\)</span> para un nivel de confianza del 95%; y <span class="math inline">\(\hat \sigma_h\)</span> es una estimación de la desviación típica del error de predicción <span class="math inline">\(h\)</span> periodos adelante. Observa que, por su forma de cálculo, estos intervalos siempre son simétricos en torno a la predicción.</p>
<p>Bajo ciertos supuestos sobre la serie temporal y su residuo, se puede obtener matemáticamente la expresión de <span class="math inline">\(\hat \sigma_h\)</span>. Por ejemplo,</p>
<ul>
<li><p>Método Ingenuo I: <span class="math inline">\(\hat \sigma_h = \hat \sigma \sqrt{h}\)</span>, donde <span class="math inline">\(\hat \sigma\)</span> es la desviación típica del error del modelo.</p></li>
<li><p>Método Ingenuo con estacionalidad <span class="math inline">\(\hat \sigma_h = \hat \sigma \sqrt{s +1}\)</span>, donde <span class="math inline">\(s=\lfloor(h-1)/m\rfloor\)</span>.</p></li>
<li><p>Método de la deriva: <span class="math inline">\(\hat \sigma_h = \hat \sigma \sqrt{h(1 + h/T)}\)</span>.</p></li>
<li><p>Alisado simple: <span class="math inline">\(\hat \sigma_h = \hat \sigma \sqrt{1 + (h-1)\alpha^2}\)</span>.</p></li>
<li><p>Alisado de Holt: <span class="math inline">\(\hat \sigma_h = \hat \sigma \sqrt{1 + (h-1)(\alpha^2 + \alpha\beta h + \frac{1}{6}\beta^2 h (2 h -1))}\)</span>.</p></li>
<li><p>Arima(0, 0, q): <span class="math inline">\(\hat \sigma_h = \hat \sigma \sqrt{1 + \sum_{i=1}^h \theta_i^2}\)</span>, donde <span class="math inline">\(\theta_i = 0\)</span> para <span class="math inline">\(i&gt;q\)</span>.</p></li>
</ul>
<p>Para otros métodos de alisado o ARIMA la fórmula es más compleja.</p>
<p>Entre los supuestos sobre el residuo necesarios para que estas formulas sean correctas están que se distribuya como una normal y que sea incorrelado (¿recuerdas el ACF1 de los indicadores de calidad?). Cuando alguno de estos dos supuestos no se da, el intervalo de confianza de las predicciones obtenido con estas fórmulas es incorrecto y, entonces, bootstrapping es una buena alternativa para obtener el intervalo de confianza de la predicción.</p>
<p><br>
</p>
</section>
<section id="bootstrapping-para-obtener-intervalos-de-predicción" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Bootstrapping para obtener intervalos de predicción</h1>
<p>Lo que viene a continuación no es del todo preciso porque para series temporales se usa algo denominado “block bootstrapping”, pero aquí solo pretendo que tengáis una idea aproximada del procedimiento que se sigue para obtener un intervalo de predicción usando bootstrapping.</p>
<section id="idea-general" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="idea-general">Idea general</h2>
<p>Veamos primero la idea general y luego los detalles:</p>
<ol type="1">
<li><p>Partimos de una serie temporal <span class="math inline">\(\{y_t\}_{t=1}^T\)</span> y un horizonte de predicción <span class="math inline">\(h\)</span>.</p></li>
<li><p>A partir de la serie original vamos a generar una nueva serie que es <em>similar</em> a la original. Luego veremos como.</p></li>
<li><p>Ajustamos nuestro modelo a la nueva serie y obtenemos una predicción <span class="math inline">\(h\)</span> periodos hacia adelante, que llamaremos <span class="math inline">\(\hat y_{T+h|T}^1\)</span>.</p></li>
<li><p>Repetimos los pasos 2 y 3 un numero <span class="math inline">\(n\)</span> de veces (típicamente <span class="math inline">\(n=5000\)</span>), de forma que al final del proceso tenemos <span class="math inline">\(n\)</span> predicciones <span class="math inline">\(h\)</span> periodos hacia adelante, <span class="math inline">\(\hat y_{T+h|T}^1,\; \hat y_{T+h|T}^2,\; \ldots,\; \hat y_{T+h|T}^n\)</span>, obtenidas a partir de <span class="math inline">\(n\)</span> series similares a la original.</p></li>
<li><p>Por último, obtenemos el intervalo de predicción calculando los percentiles correspondientes a partir de estas <span class="math inline">\(n\)</span> predicciones.</p></li>
</ol>
<p>Este proceso hay que repetirlo para cada horizonte de predicción en que estemos interesados.</p>
</section>
<section id="detalles" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="detalles">Detalles</h2>
<p>La clave del proceso es el paso 2, donde se obtiene una <em>nueva serie similar a la original</em>. También vale la pena aclarar un poco más el paso 5.</p>
<p><strong>Paso 2: nueva serie</strong></p>
<p>En lo que viene a continuación no voy a ser riguroso para no perdernos en cuestiones matemáticas, pero sí suficientemente preciso para entender bien el proceso.</p>
<ul>
<li><p>Dada la serie original, la descomponemos en sus tres componentes: tendencia, estacionalidad y error.</p></li>
<li><p>A continuación, obtenemos una versión barajada de la componente del error. (Aquí es donde no estoy siendo preciso porque el proceso de barajado se tiene que hacer por bloques y es con reemplazamiento.)</p></li>
<li><p>Ahora se combinan –sumando o multiplicando, según el esquema– la tendencia, la estacionalidad y el <strong>error barajado</strong> para obtener una nueva serie que se parecerá a la original porque tiene la misma tendencia y estacionalidad, pero diferente error.</p></li>
</ul>
<p>Veamos un ejemplo muy sencillo para una serie simulada de orden estacional 5.</p>
<ul>
<li><p>La dos primeras columnas indican la estación de cada dato y el valor de la serie, para un total de 15 observaciones.</p></li>
<li><p>Las columnas <em>Tendencia</em>, <em>Estacionalidad</em> y <em>Error</em> han sido obtenidas aplicando el método de descomposición por regresiones locales ponderadas. Observa que cada dato de la serie es la suma de estas tres componentes.</p></li>
<li><p>La columna <em>ErrorBootstrapping</em> se ha obtenido como un muestreo con reemplazamiento de los datos de la columna <em>Error</em>. Como es una muestra con reemplazamiento, hay algunos errores repetidos.</p></li>
<li><p>Por último, la nueva serie (columna <em>NuevaSerie</em>) se ha obtenido sumando las columnas <em>Tendencia</em>, <em>Estacionalidad</em> y <em>ErrorBootstrapping</em>. Esta serie tiene la misma tendencia y estacionalidad que la serie original y solo se diferencia en el error, así que la nueva serie debería parecerse a la serie original.</p></li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output cell-output-stdout">
<pre><code>   Estacion Serie Tendencia Estacionalidad  Error ErrorBootstrapping NuevaSerie
1         1 27.00     19.96           9.60  -2.56              -2.96      26.59
2         2 16.72     25.12         -13.33   4.93               9.43      21.22
3         3 15.08     30.14         -12.09  -2.96              -2.56      15.49
4         4 18.79     34.77          -9.11  -6.87               3.10      28.76
5         5 75.53     38.58          24.94  12.01              12.01      75.53
6         1 63.31     39.24           9.60  14.47               3.10      51.94
7         2 17.28     38.48         -13.33  -7.87               9.43      34.58
8         3 18.00     34.84         -12.09  -4.75              -6.87      15.88
9         4 24.84     30.85          -9.11   3.10              -0.40      21.34
10        5 54.67     30.13          24.94  -0.40              -6.87      48.21
11        1 30.85     31.11           9.60  -9.86              12.01      52.72
12        2 22.02     30.52         -13.33   4.84              -9.86       7.32
13        3 26.51     29.17         -12.09   9.43               3.10      20.18
14        4 24.14     27.94          -9.11   5.31              -7.87      10.96
15        5 41.31     26.54          24.94 -10.17              12.01      63.49</code></pre>
</div>
</div>
<p><strong>Paso 5: Predicción por intervalos</strong></p>
<p>Partimos de <span class="math inline">\(n\)</span> predicciones a <span class="math inline">\(h\)</span> periodos vista (<span class="math inline">\(\hat y_{T+h|T}^1,\; \hat y_{T+h|T}^2,\; \ldots,\; \hat y_{T+h|T}^n\)</span>) y queremos obtener a partir de ellas el intervalo de confianza.</p>
<p>Supongamos que el nivel de confianza deseado es del 95%. Entonces, debemos calcular para las predicciones el percentil 2.5% y 97.5%. Recuerda que el percentil 2.5% es el valor numérico que deja un 2.5% de las predicciones por debajo de él; y que el percentil 97.5% es el valor numérico que deja un 97.5% de las predicciones por debajo de él. La función de <code>R</code> <code>quantile()</code> permite obtener estos valores.</p>
<p>Si denominamos <span class="math inline">\(l_h\)</span> al percentil 2.5% y <span class="math inline">\(u_h\)</span> al percentil 97.5%, el intervalo de confianza de la predicción a <span class="math inline">\(h\)</span> periodos vista es <span class="math inline">\([l_h,\; u_h]\)</span>.</p>
<p><strong>¿Y la prediccion puntual?</strong></p>
<p>Para la predicción puntual tenemos dos opciones: obtener la predicción a partir de la serie original (como hemos visto en clase); u obtenerla como media de las <span class="math inline">\(n\)</span> predicciones obtenidas</p>
<p><span class="math display">\[\frac{1}{n}\sum_{j=1}^n \hat y_{T+h|T}^j\]</span></p>
<p>Este segundo método es el usual y se denomina bagging de <strong>b</strong>ootstrap <strong>agg</strong>regat<strong>ing</strong>.</p>
</section>
</section>
<section id="ejemplo" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Ejemplo</h1>
<p>Vamos a ver un sencillo ejemplo con la serie de nacimientos desde el año 2000 y hasta el año 2019.</p>
<p>En primer lugar y con propósito meramente ilustrativo, hemos calculado 10 versiones de la serie original de nacimientos obtenidas por bootstraping (paso 2 de la idea general). La <a href="#fig-NacimientosBT" class="quarto-xref">Figura&nbsp;1</a> muestra la serie original (en negro) y las 10 simulaciones.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>bootseries <span class="ot">&lt;-</span> <span class="fu">bld.mbb.bootstrap</span>(nacimientos, <span class="dv">10</span>) <span class="sc">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">%&gt;%</span> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ts</span>(<span class="at">start=</span><span class="dv">2000</span>, <span class="at">frequency=</span><span class="dv">12</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(bootseries, <span class="at">colour=</span><span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">autolayer</span>(nacimientos, <span class="at">colour=</span><span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"Nacimientos"</span>) <span class="sc">+</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">""</span>) <span class="sc">+</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">guides</span>(<span class="at">colour=</span><span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-NacimientosBT" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-NacimientosBT-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-01-Bootstrapping_files/figure-html/fig-NacimientosBT-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-NacimientosBT-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;1: Nacimientos y diez simulaciones
</figcaption>
</figure>
</div>
</div>
</div>
<p>Ahora vamos a ajustar la serie por Alisado Exponencial y obtener las predicciones y sus intervalos a 12 meses vista. Vamos a realizar estos cálculos de dos formas, usando la fórmula teórica –que solo es correcta bajo ciertos supuestos sobre el residuo– y por bootstrapping. Para el segundo caso necesitamos la función de <code>R</code> <code>baggedETS</code>, que por defecto genera 100 nuevas series por bootstrapping.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>nacimientosETS <span class="ot">&lt;-</span> <span class="fu">ets</span>(nacimientos)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>etsfc <span class="ot">&lt;-</span> <span class="fu">forecast</span>(nacimientosETS,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">h=</span><span class="dv">12</span>, </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                  <span class="at">level=</span><span class="dv">95</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>etsfc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Point Forecast    Lo 95    Hi 95
Jan 2020       29220.93 27947.01 30494.86
Feb 2020       25797.89 24529.51 27066.28
Mar 2020       28796.81 27311.06 30282.55
Apr 2020       27610.45 26045.43 29175.48
May 2020       29160.49 27434.66 30886.32
Jun 2020       27661.49 25863.50 29459.49
Jul 2020       29792.04 27825.15 31758.92
Aug 2020       29439.48 27365.52 31513.44
Sep 2020       29866.65 27667.42 32065.87
Oct 2020       30324.00 27998.17 32649.83
Nov 2020       28222.61 25828.51 30616.70
Dec 2020       28330.11 25825.06 30835.16</code></pre>
</div>
</div>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>nacimientosBagETS<span class="ot">&lt;-</span> <span class="fu">baggedETS</span>(nacimientos)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>baggedetsfc <span class="ot">&lt;-</span> <span class="fu">forecast</span>(nacimientosBagETS,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">h=</span><span class="dv">12</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">level=</span><span class="dv">95</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>baggedetsfc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Point Forecast   Lo 100   Hi 100
Jan 2020       29560.64 28636.32 30917.23
Feb 2020       26544.78 25337.42 27873.40
Mar 2020       29170.54 28523.40 30879.06
Apr 2020       28188.87 27302.44 29781.00
May 2020       29521.22 28799.15 31277.46
Jun 2020       28238.07 27232.52 29918.75
Jul 2020       30100.60 29159.95 31723.78
Aug 2020       29834.80 28874.77 31496.45
Sep 2020       30148.91 29186.34 32023.53
Oct 2020       30609.14 29319.27 32499.63
Nov 2020       28845.80 27603.96 30796.82
Dec 2020       28916.78 27903.01 30988.78</code></pre>
</div>
</div>
<p>Observa que ni las predicciones puntuales ni sus intervalos coinciden. Las predicciones son muy parecidas, pero en este caso las obtenidas con bootstrapping son algo superiores a las obtenidas por Alisado (véase <a href="#fig-NacimientosPre" class="quarto-xref">Figura&nbsp;2</a> a). Además, los intervalos de confianza obtenidos por bootstrapping no son simétricos respecto de la predicción y son más pequeños que los estimados usando las fórmulas clásicas (véase <a href="#fig-NacimientosPre" class="quarto-xref">Figura&nbsp;2</a> b).</p>
<div class="cell" data-layout-nrow="2" data-layout-align="center">
<div id="fig-NacimientosPre" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-NacimientosPre-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-NacimientosPre" style="flex-basis: 100.0%;justify-content: center;">
<div id="fig-NacimientosPre-1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-NacimientosPre-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-01-Bootstrapping_files/figure-html/fig-NacimientosPre-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-ref-parent="fig-NacimientosPre">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-NacimientosPre-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Nacimientos y predicciones puntuales para el año 2020
</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-NacimientosPre" style="flex-basis: 100.0%;justify-content: center;">
<div id="fig-NacimientosPre-2" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-NacimientosPre-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-01-Bootstrapping_files/figure-html/fig-NacimientosPre-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-ref-parent="fig-NacimientosPre">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-NacimientosPre-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Intervalos de confianza
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-NacimientosPre-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2: Nacimientos y predicciones puntuales y por intervalo con bootstrapping
</figcaption>
</figure>
</div>
</div>
<p>En media, bagging da mejores predicciones que la simple aplicación de <code>ets()</code> a la serie original. Pero como nada es gratis, esta mejora es a costa de un incremento significativo en los tiempos de computación. En concreto, por Alisado los cálculos tardan 0.46 segundos y por bootstrapping tardan 38.28 segundos, ¡y solo hemos pedido 100 simulaciones, no las habituales 5000!</p>
<p><br>
<br>
<br>
<br>
</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2023, Iván Arribas. If you find any bugs please report them to <a href="mailto:ivan.arribas@uv.es">ivan.arribas@uv.es</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This page is built with <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>